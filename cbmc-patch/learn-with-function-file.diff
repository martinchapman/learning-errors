Index: goto_instrument_parse_options.h
===================================================================
--- goto_instrument_parse_options.h	(revision 5163)
+++ goto_instrument_parse_options.h	(working copy)
@@ -39,6 +39,7 @@
   "(nondet-volatile)(isr):" \
   "(stack-depth):(nondet-static)" \
   "(function-enter):(function-exit):(branch):" \
+  "(learn)(learn-functions):" \
   "(signed-overflow-check)(unsigned-overflow-check)(float-overflow-check)" \
   "(show-goto-functions)(show-value-sets)(show-local-may-alias)" \
   "(show-local-bitvector-analysis)" \
@@ -54,7 +55,7 @@
   "(verbosity):(version)(xml-ui)(show-loops)" \
   "(accelerate)" \
   "(k-induction):(step-case)(base-case)" \
-  "(show-call-sequences)(check-call-sequence)" \
+  "(show-call-sequences)(check-call-sequence):(call-sequence-bound):" \
   "(interpreter)(show-reaching-definitions)(count-eloc)" \
   "(list-symbols)(list-undefined-functions)" \
   "(z3)"
Index: goto_instrument_parse_options.cpp
===================================================================
--- goto_instrument_parse_options.cpp	(revision 5163)
+++ goto_instrument_parse_options.cpp	(working copy)
@@ -67,6 +67,7 @@
 #include "havoc_loops.h"
 #include "k_induction.h"
 #include "function.h"
+#include "learn.h"
 #include "branch.h"
 #include "wmm/weak_memory.h"
 #include "call_sequences.h"
@@ -242,8 +243,14 @@
 
     if(cmdline.isset("check-call-sequence"))
     {
+      int bound = -1;
+      if (cmdline.isset("call-sequence-bound"))
+        bound=unsafe_string2int(cmdline.get_value("call-sequence-bound"));
       remove_returns(symbol_table, goto_functions);
-      check_call_sequence(goto_functions);
+      check_call_sequence(
+        goto_functions,
+        cmdline.get_value("check-call-sequence"),
+        bound);
       return 0;
     }
 
@@ -857,6 +864,12 @@
     havoc_loops(goto_functions);
   }
 
+  if(cmdline.isset("learn"))
+  {
+    status() << "_Learn_function_enter and Learn_trap instrumentation" << eom;
+    instrument_functions_for_learn(symbol_table, goto_functions, cmdline.get_value("learn-functions"));
+  }
+
   if(cmdline.isset("k-induction"))
   {
     bool base_case=cmdline.isset("base-case");
Index: learn.h
===================================================================
--- learn.h	(revision 0)
+++ learn.h	(working copy)
@@ -0,0 +1,11 @@
+/*******************************************************************
+ Module: Learn environment instrumentation
+
+ Author: Pascal Kesseli, pascal.kesseli@stx.ox.ac.uk
+
+ \*******************************************************************/
+
+#include <string>
+
+void instrument_functions_for_learn(class symbol_tablet &st,
+    class goto_functionst &gf, const std::string &ff);
Index: learn.cpp
===================================================================
--- learn.cpp	(revision 0)
+++ learn.cpp	(working copy)
@@ -0,0 +1,215 @@
+#include <cstring>
+#include <fstream>
+#include <iterator>
+#include <algorithm>
+#include <util/prefix.h>
+#include <util/cprover_prefix.h>
+#include <util/simplify_expr.h>
+#include <ansi-c/c_types.h>
+#include <goto-instrument/function.h>
+
+// Helper Functions
+namespace {
+const char LEARN_ENTER[] = "_Learn_function_enter";
+const char LEARN_TRAP[] = "Learn_trap";
+const char EXIT[] = "exit";
+const char MAIN[] = "main";
+const char NONDET_PREFIX[] = "nondet";
+const char *NO_INSTR[] = { "assume", "exit", "Learn_Assert", "_Learn_function_enter" , "_Learn_Assert", "_Learn_assert", "Learn_trap", "_start" };
+
+bool is_internal_function(const std::string &function_name) {
+  return has_prefix(function_name, CPROVER_PREFIX) || has_prefix(function_name, NONDET_PREFIX);
+}
+
+bool is_instrumentation_function(const std::string &function_name) {
+  const char **end(NO_INSTR + sizeof(NO_INSTR) / sizeof(NO_INSTR[0]));
+  return end != std::find(NO_INSTR, end, function_name);
+}
+
+const char BUILTIN[] = "<built-in-additions>";
+const char STDLIB[] = "/std";
+
+bool is_builtin(const locationt &loc) {
+  const std::string &file(id2string(loc.get_file()));
+  return file.find(BUILTIN) != std::string::npos || file.find(STDLIB) != std::string::npos;
+  
+}
+
+bool should_not_be_instrumented(const std::string &fn, const locationt &loc) {
+  return is_builtin(loc) || is_internal_function(fn) || is_instrumentation_function(fn);
+}
+
+symbol_tablet::symbolst::const_iterator find_or_add_indexed_function(
+    symbol_tablet &st, const irep_idt &fn) {
+  const irep_idt full_id(id2string(fn));
+  const symbol_tablet::symbolst::const_iterator s_it(st.symbols.find(full_id));
+  if (s_it != st.symbols.end()) {
+    const typet &type(s_it->second.type);
+    if (type.id() == ID_code) {
+      const code_typet::parameterst &params(to_code_type(type).parameters());
+      if (params.size() == 1 && params.begin()->type().id() == ID_signedbv) {
+        return s_it;
+      }
+    }
+    throw "Function `" + id2string(fn) + "` has wrong signature.";
+  }
+  const typet arg_type(signed_int_type());
+  code_typet function_type;
+  function_type.return_type() = empty_typet();
+  function_type.parameters().push_back(code_typet::parametert(arg_type));
+  symbolt new_symbol;
+  new_symbol.name = full_id;
+  new_symbol.base_name = fn;
+  new_symbol.type = function_type;
+  st.move(new_symbol);
+  return st.symbols.find(full_id);
+}
+
+symbol_tablet::symbolst::const_iterator find_or_add_void_function(
+    symbol_tablet &st, const irep_idt &fn) {
+  const irep_idt full_id(id2string(fn));
+  const symbol_tablet::symbolst::const_iterator s_it(st.symbols.find(full_id));
+  if (s_it != st.symbols.end()) {
+    const typet &type(s_it->second.type);
+    if (type.id() == ID_code && to_code_type(type).parameters().empty()) {
+      return s_it;
+    }
+    throw "Function `" + id2string(fn) + "` has wrong signature.";
+  }
+  code_typet function_type;
+  function_type.return_type() = empty_typet();
+  symbolt new_symbol;
+  new_symbol.name = full_id;
+  new_symbol.base_name = fn;
+  new_symbol.type = function_type;
+  st.move(new_symbol);
+  return st.symbols.find(full_id);
+}
+
+code_function_callt to_indexed_function_call(symbol_tablet &st,
+    const irep_idt &fn, int index) {
+  const symbol_tablet::symbolst::const_iterator s_it(
+      find_or_add_indexed_function(st, fn));
+  assert(st.symbols.end() != s_it);
+  code_function_callt call;
+  call.function() = symbol_exprt(s_it->second.name, s_it->second.type);
+  const typet arg_type(signed_int_type());
+  const mp_integer width(string2integer(arg_type.get_string(ID_width)));
+  const std::string binary_value(integer2string(index, 2));
+  std::string bv_value((width - binary_value.length()).to_ulong(), '0');
+  bv_value += binary_value;
+  constant_exprt arg(bv_value, arg_type);
+  call.arguments().push_back(arg);
+  return call;
+}
+
+code_function_callt to_void_function_call(symbol_tablet &st,
+    const irep_idt &fn) {
+  const symbol_tablet::symbolst::const_iterator s_it(
+      find_or_add_void_function(st, fn));
+  assert(st.symbols.end() != s_it);
+  code_function_callt call;
+  call.function() = symbol_exprt(s_it->second.name, s_it->second.type);
+  return call;
+}
+
+void instrument_function_enter(symbol_tablet &st,
+    goto_functionst::function_mapt::iterator f_it, int index) {
+  goto_programt &body(f_it->second.body);
+  goto_programt::instructionst &instrs(body.instructions);
+  goto_programt::targett instr(body.insert_before(instrs.begin()));
+  instr->make_function_call(to_indexed_function_call(st, LEARN_ENTER, index));
+  instr->function = f_it->first;
+}
+
+void instrument_main_exit(symbol_tablet &st,
+    goto_functionst::function_mapt::iterator f_it) {
+  goto_programt &body(f_it->second.body);
+  goto_programt::instructionst &instrs(body.instructions);
+  if (instrs.empty() || !instrs.back().is_end_function()) {
+    body.add_instruction(END_FUNCTION);
+  }
+  for (typeof(instrs.begin()) it(instrs.begin()); it != instrs.end(); ++it) {
+    if (it->is_return()) {
+      goto_programt::instructiont call;
+      call.function=f_it->first;
+      call.make_function_call(to_void_function_call(st, LEARN_TRAP));
+      body.insert_before_swap(it, call);
+      ++it;
+    }
+  }
+}
+
+void instrument_learn_trap(symbol_tablet &st,
+    goto_functionst::function_mapt::iterator f_it) {
+  goto_programt &body(f_it->second.body);
+  goto_programt::instructionst &instrs(body.instructions);
+  for (typeof(instrs.begin()) it(instrs.begin()); it != instrs.end(); ++it) {
+    if (it->is_function_call()) {
+      const code_function_callt &call(to_code_function_call(it->code));
+      const exprt &f(call.function());
+      if (ID_symbol == f.id()) {
+        if (EXIT == id2string(to_symbol_expr(f).get_identifier())) {
+          goto_programt::instructiont call;
+          call.function=f_it->first;
+          call.make_function_call(to_void_function_call(st, LEARN_TRAP));
+          body.insert_before_swap(it, call);
+          ++it;
+        }
+      }
+    }
+  }
+  if (MAIN == id2string(f_it->first)) {
+    instrument_main_exit(st, f_it);
+  }
+}
+
+std::set<std::string> read_learn_functions(const std::string &path) {
+  std::set<std::string> result;
+  if (path.empty()) {
+    return result;
+  }
+  std::ifstream ifs(path.c_str());
+  std::copy(std::istream_iterator<std::string>(ifs),
+      std::istream_iterator<std::string>(),
+      std::inserter(result, result.end()));
+  return result;
+}
+
+bool is_permitted_by_learn_functions_file(const std::set<std::string> &fs, const std::string &f) {
+  return fs.empty() || fs.find(f) != fs.end();
+}
+}
+
+/*******************************************************************
+ Function: learn_enter
+
+ Inputs:
+
+ Outputs:
+
+ Purpose:
+
+ \*******************************************************************/
+
+void instrument_functions_for_learn(symbol_tablet &st, goto_functionst &gf, const std::string &ff) {
+  std::set<std::string> fs(read_learn_functions(ff));
+  goto_functionst::function_mapt &fm(gf.function_map);
+  std::vector<std::string> funcs;
+  int function_index(-1);
+  for (typeof(fm.begin()) f_it(fm.begin()); f_it != fm.end(); ++f_it) {
+    const std::string &fn(id2string(f_it->first));
+    if (should_not_be_instrumented(fn, f_it->second.type.location())) {
+      continue;
+    }
+    if (MAIN != fn && is_permitted_by_learn_functions_file(fs, fn)) {
+      funcs.push_back(fn);
+      instrument_function_enter(st, f_it, ++function_index);
+    }
+    instrument_learn_trap(st, f_it);
+  }
+  std::ofstream ofs("func_names.data");
+  for (typeof(funcs.begin()) it(funcs.begin()); it != funcs.end(); ++it) {
+    ofs << "  " << *it << std::endl;
+  }
+}
