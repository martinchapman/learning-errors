Index: src/goto-instrument/Makefile
===================================================================
--- src/goto-instrument/Makefile	(revision 5628)
+++ src/goto-instrument/Makefile	(working copy)
@@ -4,7 +4,7 @@
       object_id.cpp show_locations.cpp points_to.cpp \
       alignment_checks.cpp race_check.cpp \
       nondet_volatile.cpp interrupt.cpp function.cpp branch.cpp \
-      mmio.cpp stack_depth.cpp nondet_static.cpp \
+      learn.cpp mmio.cpp stack_depth.cpp nondet_static.cpp \
       concurrency.cpp dump_c.cpp dot.cpp havoc_loops.cpp \
       call_sequences.cpp unwind.cpp function_modifies.cpp \
       accelerate/accelerate.cpp accelerate/polynomial.cpp \
Index: src/goto-instrument/call_sequences.cpp
===================================================================
--- src/goto-instrument/call_sequences.cpp	(revision 5628)
+++ src/goto-instrument/call_sequences.cpp	(working copy)
@@ -10,6 +10,8 @@
 
 #include <stack>
 #include <iostream>
+#include <fstream>
+#include <algorithm>
 
 #include <util/std_expr.h>
 
@@ -33,10 +35,10 @@
   const goto_programt::const_targett start)
 {
   std::cout << "# From " << function << std::endl;
-      
+
   std::stack<goto_programt::const_targett> stack;
   std::set<goto_programt::const_targett> seen;
-  
+
   if(start!=goto_program.instructions.end())
     stack.push(start);
 
@@ -44,10 +46,10 @@
   {
     goto_programt::const_targett t=stack.top();
     stack.pop();
-    
+
     if(!seen.insert(t).second)
       continue; // seen it already
-    
+
     if(t->is_function_call())
     {
       const exprt &function2=to_code_function_call(t->code).function();
@@ -63,7 +65,7 @@
     // get successors
     goto_programt::const_targetst s;
     goto_program.get_successors(t, s);
-    
+
     // add to stack
     for(goto_programt::const_targetst::const_iterator
         it=s.begin(); it!=s.end(); it++)
@@ -88,24 +90,24 @@
   const goto_programt &goto_program)
 {
   // this is quadratic
-  
+
   std::cout << "# " << function << std::endl;
-  
+
   show_call_sequences(
     function,
     goto_program,
     goto_program.instructions.begin());
-  
+
   forall_goto_program_instructions(i_it, goto_program)
   {
     if(!i_it->is_function_call())
       continue;
-      
+
     const exprt &f1=to_code_function_call(i_it->code).function();
-    
+
     if(f1.id()!=ID_symbol)
       continue;
-      
+
     // find any calls reachable from this one
     goto_programt::const_targett next=i_it;
     next++;
@@ -115,7 +117,7 @@
       goto_program,
       next);
   }
-  
+
   std::cout << std::endl;
 }
 
@@ -156,17 +158,22 @@
 public:
   explicit check_call_sequencet(
     const goto_functionst &_goto_functions,
-    const std::vector<irep_idt> &_sequence):
+    const std::vector<irep_idt> &_sequence,
+    const std::set<irep_idt> &_interesting_set,
+    int _bound):
     goto_functions(_goto_functions),
-    sequence(_sequence)
+    sequence(_sequence),
+    interesting_set(_interesting_set), bound(_bound)
   {
-  }  
+  }
 
   void operator()();
-  
+
 protected:
   const goto_functionst &goto_functions;
   const std::vector<irep_idt> &sequence;
+  const std::set<irep_idt> &interesting_set;
+  int bound;
 
   struct call_stack_entryt
   {
@@ -173,7 +180,7 @@
     goto_functionst::function_mapt::const_iterator f;
     goto_programt::const_targett return_address;
   };
-  
+
   friend bool operator==(const call_stack_entryt &e1,
                          const call_stack_entryt &e2)
   {
@@ -180,7 +187,7 @@
     return e1.f->first==e2.f->first &&
            e1.return_address==e2.return_address;
   }
-  
+
   struct statet
   {
     goto_functionst::function_mapt::const_iterator f;
@@ -196,7 +203,7 @@
              s1.index==s2.index;
     }
   };
-  
+
   class state_hash
   {
   public:
@@ -205,13 +212,13 @@
       size_t pc_hash=
         s.pc==s.f->second.body.instructions.end()?0:
         (size_t)&*s.pc;
-      
+
       return hash_string(s.f->first)^
              pc_hash^
              s.index^s.call_stack.size();
     }
   };
-    
+
   typedef hash_set_cont<statet, state_hash> statest;
   statest states;
 };
@@ -225,7 +232,7 @@
     std::cout << "empty sequence given\n";
     return;
   }
-  
+
   irep_idt entry=sequence.front();
 
   goto_functionst::function_mapt::const_iterator f_it=
@@ -238,12 +245,17 @@
     queue.top().pc=f_it->second.body.instructions.begin();
     queue.top().index=1;
   }
-  
+
+  bool all_interesting = interesting_set.empty();
+  bool is_bounded = (bound > -1);
+  unsigned ending_index = 0;
+  int non_interesting_counter = 0;
+
   while(!queue.empty())
   {
     statet &e=queue.top();
-    
-    // seen already?
+    if (e.index > ending_index) ending_index = e.index;
+    // seen already (control-flow join points)
     if(states.find(e)!=states.end())
     {
       // drop, continue
@@ -250,10 +262,10 @@
       queue.pop();
       continue;
     }
-    
+
     // insert
     states.insert(e);
-    
+
     // satisfies sequence?
     if(e.index==sequence.size())
     {
@@ -261,7 +273,7 @@
       return;
     }
 
-    // new, explore
+    // reached end of function, return
     if(e.pc==e.f->second.body.instructions.end())
     {
       if(e.call_stack.empty())
@@ -280,14 +292,24 @@
       if(function.id()==ID_symbol)
       {
         irep_idt identifier=to_symbol_expr(function).get_identifier();
-        
-        if(sequence[e.index]==identifier)
+
+        if (sequence[e.index]==identifier ||   // found it
+            // the other option is to counter a case in which a
+            // non-interesting function is recursive and hence we may diverge
+            (!all_interesting &&
+             interesting_set.find(identifier) == interesting_set.end() && // it is not an interesting function
+             !(is_bounded && non_interesting_counter > bound))) // we did not yet cross the bound
         {
-          e.index++; // yes, we have seen it
-        
+
+          if(sequence[e.index]==identifier) {
+            e.index++; // yes, we have seen it
+            non_interesting_counter = 0;
+          }
+          else non_interesting_counter++;
+
           goto_functionst::function_mapt::const_iterator f_call_it=
             goto_functions.function_map.find(identifier);
-          
+
           if(f_call_it==goto_functions.function_map.end())
             e.pc++;
           else
@@ -323,7 +345,7 @@
     }
   }
 
-  std::cout << "sequence not feasible\n";
+  std::cout << "sequence not feasible\n" << ending_index << "\n";
 }
 
 /*******************************************************************\
@@ -338,22 +360,48 @@
 
 \*******************************************************************/
 
-void check_call_sequence(const goto_functionst &goto_functions)
+void check_call_sequence(
+  const goto_functionst &goto_functions,
+  const std::string &in_file_prefix,
+  int bound)
 {
-  // read the sequence from stdin
-  
+  std::ifstream in_file;
+  std::string in_file_name = in_file_prefix + ".seq";
+  in_file.open(in_file_name.c_str());
+
   std::vector<irep_idt> sequence;
-  
+
   std::string line;
-  while(std::getline(std::cin, line))
+  while(std::getline(in_file, line))
   {
     if(line!="" && line[line.size()-1]=='\r')
       line.resize(line.size()-1);
-      
+
     if(line!="")
       sequence.push_back(line);
   }
+  in_file.close();
+  // read the 'interesting set', i.e., set of function names that we want to
+  // follow (others cause an \epsilon transition). It is assumed (but not
+  // checked) that (name \in sequence ==> name \in interesting_set)
+  in_file_name = in_file_prefix + ".is";
+  in_file.open(in_file_name.c_str());
 
-  check_call_sequencet(goto_functions, sequence)();
+  std::set<irep_idt> interesting_set;
+
+  if (in_file.is_open())
+  {
+    //std::cerr << "Reading set of interesting functions from " << in_file_name << " \n";
+    while(std::getline(in_file, line))
+    {
+      if(line!="" && line[line.size()-1]=='\r')
+        line.resize(line.size()-1);
+
+      if(line!="")
+        interesting_set.insert(line);
+    }
+  }
+
+  check_call_sequencet(goto_functions, sequence, interesting_set, bound)();
 }
 
Index: src/goto-instrument/call_sequences.h
===================================================================
--- src/goto-instrument/call_sequences.h	(revision 5628)
+++ src/goto-instrument/call_sequences.h	(working copy)
@@ -14,6 +14,9 @@
 #include <goto-programs/goto_functions.h>
 
 void show_call_sequences(const goto_functionst &goto_functions);
-void check_call_sequence(const goto_functionst &goto_functions);
+void check_call_sequence(
+  const goto_functionst &goto_functions,
+  const std::string &in_file_prefix,
+  int bound);
 
 #endif
Index: src/goto-instrument/goto_instrument_parse_options.cpp
===================================================================
--- src/goto-instrument/goto_instrument_parse_options.cpp	(revision 5628)
+++ src/goto-instrument/goto_instrument_parse_options.cpp	(working copy)
@@ -68,6 +68,7 @@
 #include "havoc_loops.h"
 #include "k_induction.h"
 #include "function.h"
+#include "learn.h"
 #include "branch.h"
 #include "wmm/weak_memory.h"
 #include "call_sequences.h"
@@ -244,8 +245,14 @@
 
     if(cmdline.isset("check-call-sequence"))
     {
+      int bound = -1;
+      if (cmdline.isset("call-sequence-bound"))
+        bound=unsafe_string2int(cmdline.get_value("call-sequence-bound"));
       remove_returns(symbol_table, goto_functions);
-      check_call_sequence(goto_functions);
+      check_call_sequence(
+        goto_functions,
+        cmdline.get_value("check-call-sequence"),
+        bound);
       return 0;
     }
 
@@ -899,6 +906,26 @@
     havoc_loops(goto_functions);
   }
 
+  if (cmdline.isset("learn")) {
+    status() << "_Learn_function_enter and Learn_trap instrumentation" << eom;
+    instrument_functions_for_learn(symbol_table, goto_functions,
+        cmdline.get_value("learn-functions"));
+  }
+
+  if (cmdline.isset("learn-word-length")) {
+    status() << "Estimating minimumg learn word length" << eom;
+    size_t function_length(0);
+    if (cmdline.isset("fl")) {
+      function_length = string2integer(cmdline.get_value("fl")).to_ulong();
+    }
+    size_t call_sites(0);
+    if (cmdline.isset("cs")) {
+      call_sites = string2integer(cmdline.get_value("cs")).to_ulong();
+    }
+    show_learn_word_length(symbol_table, goto_functions,
+        cmdline.get_value("learn-functions"), function_length, call_sites);
+  }
+
   if(cmdline.isset("k-induction"))
   {
     bool base_case=cmdline.isset("base-case");
Index: src/goto-instrument/goto_instrument_parse_options.h
===================================================================
--- src/goto-instrument/goto_instrument_parse_options.h	(revision 5628)
+++ src/goto-instrument/goto_instrument_parse_options.h	(working copy)
@@ -39,6 +39,7 @@
   "(nondet-volatile)(isr):" \
   "(stack-depth):(nondet-static)" \
   "(function-enter):(function-exit):(branch):" \
+  "(learn)(learn-functions):(learn-word-length)(fl):(cs):" \
   "(signed-overflow-check)(unsigned-overflow-check)(float-overflow-check)" \
   "(show-goto-functions)(show-value-sets)(show-local-may-alias)" \
   "(show-local-bitvector-analysis)" \
@@ -54,7 +55,7 @@
   "(verbosity):(version)(xml-ui)(show-loops)" \
   "(accelerate)" \
   "(k-induction):(step-case)(base-case)" \
-  "(show-call-sequences)(check-call-sequence)" \
+  "(show-call-sequences)(check-call-sequence):(call-sequence-bound):" \
   "(interpreter)(show-reaching-definitions)(count-eloc)" \
   "(list-symbols)(list-undefined-functions)" \
   "(z3)(add-library)" \
Index: src/goto-instrument/learn.cpp
===================================================================
--- src/goto-instrument/learn.cpp	(revision 0)
+++ src/goto-instrument/learn.cpp	(working copy)
@@ -0,0 +1,473 @@
+#include <cstring>
+#include <iostream>
+#include <fstream>
+#include <iterator>
+#include <stack>
+#include <queue>
+#include <algorithm>
+#include <util/prefix.h>
+#include <util/cprover_prefix.h>
+#include <util/simplify_expr.h>
+#include <ansi-c/c_types.h>
+#include <goto-programs/cfg.h>
+#include <goto-instrument/function.h>
+
+// "--learn" helper functions
+namespace {
+const char LEARN_ENTER[] = "_Learn_function_enter";
+const char LEARN_TRAP[] = "Learn_trap";
+const char EXIT[] = "exit";
+const char MAIN[] = "main";
+const char NONDET_PREFIX[] = "nondet";
+const char *NO_INSTR[] = { "assume", "exit", "Learn_Assert",
+    "_Learn_function_enter", "_Learn_Assert", "_Learn_assert", "Learn_trap",
+    "_start" };
+
+bool is_internal_function(const std::string &function_name) {
+  return has_prefix(function_name, CPROVER_PREFIX)
+      || has_prefix(function_name, NONDET_PREFIX);
+}
+
+bool is_instrumentation_function(const std::string &function_name) {
+  const char **end(NO_INSTR + sizeof(NO_INSTR) / sizeof(NO_INSTR[0]));
+  return end != std::find(NO_INSTR, end, function_name);
+}
+
+const char BUILTIN[] = "<built-in-additions>";
+const char STDLIB[] = "/std";
+
+bool is_builtin(const locationt &loc) {
+  const std::string &file(id2string(loc.get_file()));
+  return file.find(BUILTIN) != std::string::npos
+      || file.find(STDLIB) != std::string::npos;
+
+}
+
+bool should_not_be_instrumented(const std::string &fn, const locationt &loc) {
+  return is_builtin(loc) || is_internal_function(fn)
+      || is_instrumentation_function(fn);
+}
+
+symbol_tablet::symbolst::const_iterator find_or_add_indexed_function(
+    symbol_tablet &st, const irep_idt &fn) {
+  const irep_idt full_id(id2string(fn));
+  const symbol_tablet::symbolst::const_iterator s_it(st.symbols.find(full_id));
+  if (s_it != st.symbols.end()) {
+    const typet &type(s_it->second.type);
+    if (type.id() == ID_code) {
+      const code_typet::parameterst &params(to_code_type(type).parameters());
+      if (params.size() == 1 && params.begin()->type().id() == ID_signedbv) {
+        return s_it;
+      }
+    }
+    throw "Function `" + id2string(fn) + "` has wrong signature.";
+  }
+  const typet arg_type(signed_int_type());
+  code_typet function_type;
+  function_type.return_type() = empty_typet();
+  function_type.parameters().push_back(code_typet::parametert(arg_type));
+  symbolt new_symbol;
+  new_symbol.name = full_id;
+  new_symbol.base_name = fn;
+  new_symbol.type = function_type;
+  st.move(new_symbol);
+  return st.symbols.find(full_id);
+}
+
+symbol_tablet::symbolst::const_iterator find_or_add_void_function(
+    symbol_tablet &st, const irep_idt &fn) {
+  const irep_idt full_id(id2string(fn));
+  const symbol_tablet::symbolst::const_iterator s_it(st.symbols.find(full_id));
+  if (s_it != st.symbols.end()) {
+    const typet &type(s_it->second.type);
+    if (type.id() == ID_code && to_code_type(type).parameters().empty()) {
+      return s_it;
+    }
+    throw "Function `" + id2string(fn) + "` has wrong signature.";
+  }
+  code_typet function_type;
+  function_type.return_type() = empty_typet();
+  symbolt new_symbol;
+  new_symbol.name = full_id;
+  new_symbol.base_name = fn;
+  new_symbol.type = function_type;
+  st.move(new_symbol);
+  return st.symbols.find(full_id);
+}
+
+code_function_callt to_indexed_function_call(symbol_tablet &st,
+    const irep_idt &fn, int index) {
+  const symbol_tablet::symbolst::const_iterator s_it(
+      find_or_add_indexed_function(st, fn));
+  assert(st.symbols.end() != s_it);
+  code_function_callt call;
+  call.function() = symbol_exprt(s_it->second.name, s_it->second.type);
+  const typet arg_type(signed_int_type());
+  const mp_integer width(string2integer(arg_type.get_string(ID_width)));
+  const std::string binary_value(integer2string(index, 2));
+  std::string bv_value((width - binary_value.length()).to_ulong(), '0');
+  bv_value += binary_value;
+  constant_exprt arg(bv_value, arg_type);
+  call.arguments().push_back(arg);
+  return call;
+}
+
+code_function_callt to_void_function_call(symbol_tablet &st,
+    const irep_idt &fn) {
+  const symbol_tablet::symbolst::const_iterator s_it(
+      find_or_add_void_function(st, fn));
+  assert(st.symbols.end() != s_it);
+  code_function_callt call;
+  call.function() = symbol_exprt(s_it->second.name, s_it->second.type);
+  return call;
+}
+
+void instrument_function_enter(symbol_tablet &st,
+    goto_functionst::function_mapt::iterator f_it, int index) {
+  goto_programt &body(f_it->second.body);
+  goto_programt::instructionst &instrs(body.instructions);
+  goto_programt::targett instr(body.insert_before(instrs.begin()));
+  instr->make_function_call(to_indexed_function_call(st, LEARN_ENTER, index));
+  instr->function = f_it->first;
+}
+
+void instrument_main_exit(symbol_tablet &st,
+    goto_functionst::function_mapt::iterator f_it) {
+  goto_programt &body(f_it->second.body);
+  goto_programt::instructionst &instrs(body.instructions);
+  if (instrs.empty() || !instrs.back().is_end_function()) {
+    body.add_instruction(END_FUNCTION);
+  }
+  for (__typeof__(instrs.begin()) it(instrs.begin()); it != instrs.end(); ++it) {
+    if (it->is_return()) {
+      goto_programt::instructiont call;
+      call.function = f_it->first;
+      call.make_function_call(to_void_function_call(st, LEARN_TRAP));
+      body.insert_before_swap(it, call);
+      ++it;
+    }
+  }
+}
+
+void instrument_learn_trap(symbol_tablet &st,
+    goto_functionst::function_mapt::iterator f_it) {
+  goto_programt &body(f_it->second.body);
+  goto_programt::instructionst &instrs(body.instructions);
+  for (__typeof__(instrs.begin()) it(instrs.begin()); it != instrs.end(); ++it) {
+    if (it->is_function_call()) {
+      const code_function_callt &call(to_code_function_call(it->code));
+      const exprt &f(call.function());
+      if (ID_symbol == f.id()) {
+        if (EXIT == id2string(to_symbol_expr(f).get_identifier())) {
+          goto_programt::instructiont call;
+          call.function = f_it->first;
+          call.make_function_call(to_void_function_call(st, LEARN_TRAP));
+          body.insert_before_swap(it, call);
+          ++it;
+        }
+      }
+    }
+  }
+  if (MAIN == id2string(f_it->first)) {
+    instrument_main_exit(st, f_it);
+  }
+}
+
+std::set<std::string> read_functions(const std::string &path) {
+  std::set<std::string> result;
+  if (path.empty()) {
+    return result;
+  }
+  std::ifstream ifs(path.c_str());
+  std::copy(std::istream_iterator<std::string>(ifs),
+      std::istream_iterator<std::string>(),
+      std::inserter(result, result.end()));
+  return result;
+}
+
+bool is_permitted_by_learn_functions_file(const std::set<std::string> &fs,
+    const std::string &f) {
+  return fs.empty() || fs.find(f) != fs.end();
+}
+}
+
+/*******************************************************************
+ Function: instrument_functions_for_learn
+
+ Inputs:
+
+ Outputs:
+
+ Purpose:
+
+ \*******************************************************************/
+
+void instrument_functions_for_learn(symbol_tablet &st, goto_functionst &gf,
+    const std::string &ff) {
+  const std::set<std::string> fs(read_functions(ff));
+  goto_functionst::function_mapt &fm(gf.function_map);
+  std::vector<std::string> funcs;
+  int function_index(-1);
+  for (__typeof__(fm.begin()) f_it(fm.begin()); f_it != fm.end(); ++f_it) {
+    const std::string &fn(id2string(f_it->first));
+    if (should_not_be_instrumented(fn, f_it->second.type.location())) {
+      continue;
+    }
+    if (MAIN != fn && is_permitted_by_learn_functions_file(fs, fn)) {
+      funcs.push_back(fn);
+      instrument_function_enter(st, f_it, ++function_index);
+    }
+    instrument_learn_trap(st, f_it);
+  }
+  std::ofstream ofs("func_names.data");
+  for (__typeof__(funcs.begin()) it(funcs.begin()); it != funcs.end(); ++it) {
+    ofs << "  " << *it << std::endl;
+  }
+}
+
+// --learn-word-length helper functions
+namespace {
+class word_length_cfg_nodet {
+  bool visited;
+public:
+  word_length_cfg_nodet() :
+      visited(false) {
+  }
+  void mark_visited() {
+    visited = true;
+  }
+  bool is_visited() {
+    return visited;
+  }
+};
+
+typedef cfg_baset<word_length_cfg_nodet> cfgt;
+typedef std::stack<cfgt::iterator> call_stackt;
+typedef std::list<call_stackt> call_stackst;
+typedef std::pair<cfgt::iterator, call_stackt *> frontier_itemt;
+typedef std::queue<frontier_itemt> frontiert;
+frontier_itemt make_frontier_itemt(cfgt::iterator node,
+    call_stackt *call_stack) {
+  return std::make_pair(node, call_stack);
+}
+
+bool is_root(const cfgt::entry_mapt::value_type &entry) {
+  const goto_programt::const_targett &instruction(entry.first);
+  return goto_functionst::entry_point() == instruction->function
+      && instruction->location_number == 0;
+}
+
+bool is_function_call(const goto_programt::const_targett &instruction) {
+  if (!instruction->is_function_call()) {
+    return false;
+  }
+  return ID_symbol == to_code_function_call(instruction->code).function().id();
+}
+
+bool is_function_call(const cfgt::entryt &node) {
+  return is_function_call(node.PC);
+}
+
+const std::string &get_function_name(
+    const goto_programt::const_targett &instr) {
+  const exprt &f(to_code_function_call(instr->code).function());
+  return id2string(to_symbol_expr(f).get_identifier());
+}
+
+const std::string &get_function_name(const cfgt::entryt &node) {
+  return get_function_name(node.PC);
+}
+
+const char LEARN_ASSERT[] = "_Learn_assert";
+bool is_learn_assert(const cfgt::entryt &node) {
+  return is_function_call(node) && LEARN_ASSERT == get_function_name(node);
+}
+
+bool is_learn_enter(const cfgt::entryt &node) {
+  return is_function_call(node) && LEARN_ENTER == get_function_name(node);
+}
+
+bool is_call_of_inlined_function(const std::set<std::string> &inlined_functions,
+    const cfgt::entryt &node) {
+  if (!is_function_call(node)) {
+    return false;
+  }
+  return std::find(inlined_functions.begin(), inlined_functions.end(),
+      get_function_name(node)) != inlined_functions.end();
+}
+
+bool is_empty_function_call(cfgt::entry_mapt &nodes, const cfgt::entryt &node) {
+  goto_programt::const_targett next_instruction(node.PC);
+  cfgt::entry_mapt::iterator next_instruction_node(
+      nodes.find(++next_instruction));
+  assert(next_instruction_node != nodes.end());
+  return node.successors.size() == 1
+      && node.successors.front() == &next_instruction_node->second;
+}
+
+bool is_in_inlined_function(const std::set<std::string> &inlined_functions,
+    const cfgt::entryt &node) {
+  return std::find(inlined_functions.begin(), inlined_functions.end(),
+      id2string(node.PC->function)) != inlined_functions.end();
+}
+
+bool handle_inlining(cfgt::entry_mapt &nodes, frontiert &frontier,
+    call_stackst &call_stacks, const std::set<std::string> &inlined_functions,
+    frontier_itemt &item) {
+  cfgt::entryt &node(*item.first);
+  if (is_call_of_inlined_function(inlined_functions, node)
+      && !is_empty_function_call(nodes, node)) {
+    if (!is_in_inlined_function(inlined_functions, node)) {
+      node.mark_visited();
+    }
+    goto_programt::const_targett next_instruction(node.PC);
+    cfgt::entry_mapt::iterator next_instruction_node(
+        nodes.find(++next_instruction));
+    assert(next_instruction_node != nodes.end());
+    item.second->push(&next_instruction_node->second);
+    assert(node.successors.size() == 1);
+    frontier.push(make_frontier_itemt(node.successors.front(), item.second));
+    return true;
+  } else if (is_in_inlined_function(inlined_functions, node)) {
+    if (!node.PC->is_end_function()) {
+      return false;
+    }
+    assert(!item.second->empty());
+    frontier.push(make_frontier_itemt(item.second->top(), item.second));
+    item.second->pop();
+    return true;
+  }
+  node.mark_visited();
+  return false;
+}
+
+class call_stack_splittert {
+  call_stackst &call_stacks;
+  call_stackt &original_call_stack;
+  bool should_split;
+  bool is_first;
+public:
+  call_stack_splittert(call_stackst &call_stacks, frontier_itemt &item) :
+      call_stacks(call_stacks), original_call_stack(*item.second), should_split(
+          item.first->PC->is_goto() && !item.first->PC->guard.is_true()), is_first(
+          true) {
+  }
+  call_stackt *operator()() {
+    if (!should_split) {
+      return &original_call_stack;
+    }
+    if (is_first) {
+      is_first = false;
+      return &original_call_stack;
+    }
+    call_stacks.push_back(original_call_stack);
+    return &call_stacks.back();
+  }
+};
+
+void search_bfs(frontiert &frontier, call_stackst &call_stacks,
+    frontier_itemt &item) {
+  cfgt::entryt &node(*item.first);
+  cfgt::entriest &s(node.successors);
+  call_stack_splittert call_stack_slitter(call_stacks, item);
+  for (__typeof__(s.begin()) it(s.begin()); it != s.end(); ++it) {
+    if (!(*it)->is_visited()) {
+      call_stackt *call_stack(call_stack_slitter());
+      frontier.push(make_frontier_itemt(*it, call_stack));
+    }
+  }
+}
+
+size_t count_call_sites(const goto_functionst &gf, const std::string &fn) {
+  size_t count(0);
+  const __typeof__(gf.function_map) &fm(gf.function_map);
+  for (__typeof__(fm.begin()) f(fm.begin()); f != fm.end(); ++f) {
+    if (!f->second.body_available) {
+      continue;
+    }
+    const goto_programt::instructionst &i(f->second.body.instructions);
+    for (__typeof__(i.begin()) it(i.begin()); it != i.end(); ++it) {
+      if (is_function_call(it) && get_function_name(it) == fn) {
+        ++count;
+      }
+    }
+  }
+  return count;
+}
+
+void add_auto_inlining(const goto_functionst &gf,
+    std::set<std::string> &inlined_functions, const size_t method_length,
+    const size_t call_sites) {
+  if (method_length <= 0 || call_sites <= 0) {
+    return;
+  }
+  const __typeof__(gf.function_map) &fm(gf.function_map);
+  for (__typeof__(fm.begin()) f(fm.begin()); f != fm.end(); ++f) {
+    if (!f->second.body_available) {
+      continue;
+    }
+    const goto_programt &body(f->second.body);
+    if (body.instructions.size() < method_length) {
+      continue;
+    }
+    const std::string &fn(id2string(f->first));
+    if (count_call_sites(gf, fn) >= call_sites) {
+      inlined_functions.insert(fn);
+    }
+  }
+}
+
+std::set<std::string> read_inlined_functions(const std::string &file_path) {
+  std::set<std::string> result(read_functions(file_path));
+  result.insert(LEARN_ENTER);
+  return result;
+}
+}
+
+/*******************************************************************
+ Function: show_learn_word_length
+
+ Inputs:
+
+ Outputs:
+
+ Purpose:
+
+ \*******************************************************************/
+void show_learn_word_length(class symbol_tablet &st, class goto_functionst &gf,
+    const std::string &iff, const size_t function_length,
+    const size_t call_sites) {
+  std::set<std::string> inlined_functions(read_inlined_functions(iff));
+  add_auto_inlining(gf, inlined_functions, function_length, call_sites);
+  cfgt cfg;
+  cfg(gf);
+  cfgt::entry_mapt &nodes(cfg.entry_map);
+  call_stackst call_stacks(1, call_stackt());
+  frontiert frontier;
+  frontier.push(
+      make_frontier_itemt(
+          &std::find_if(nodes.begin(), nodes.end(), is_root)->second,
+          &call_stacks.back()));
+  size_t minimum_word_length(0);
+  while (!frontier.empty()) {
+    frontier_itemt &item(frontier.front());
+    cfgt::entryt &node(*item.first);
+    if (node.is_visited()) {
+      frontier.pop();
+      continue;
+    }
+    if (is_learn_assert(node)) {
+      ++minimum_word_length;
+      break;
+    }
+    if (is_learn_enter(node)) {
+      ++minimum_word_length;
+    }
+    if (!handle_inlining(nodes, frontier, call_stacks, inlined_functions,
+        item)) {
+      search_bfs(frontier, call_stacks, item);
+    }
+    frontier.pop();
+  }
+  std::cout << minimum_word_length << std::endl;
+}
Index: src/goto-instrument/learn.h
===================================================================
--- src/goto-instrument/learn.h	(revision 0)
+++ src/goto-instrument/learn.h	(working copy)
@@ -0,0 +1,15 @@
+/*******************************************************************
+ Module: Learn environment instrumentation
+
+ Author: Pascal Kesseli, pascal.kesseli@stx.ox.ac.uk
+
+ \*******************************************************************/
+
+#include <string>
+
+void instrument_functions_for_learn(class symbol_tablet &st,
+    class goto_functionst &gf, const std::string &ff);
+
+void show_learn_word_length(class symbol_tablet &st, class goto_functionst &gf,
+    const std::string &iff, const size_t function_length,
+    const size_t call_sites);
Index: src/goto-programs/remove_returns.cpp
===================================================================
--- src/goto-programs/remove_returns.cpp	(revision 5628)
+++ src/goto-programs/remove_returns.cpp	(working copy)
@@ -156,7 +156,8 @@
 {
   Forall_goto_program_instructions(i_it, goto_program)
   {
-    if(i_it->is_function_call())
+    if(i_it->is_function_call() &&
+       to_code_function_call(i_it->code).lhs().is_not_nil())
     {
       code_function_callt &function_call=to_code_function_call(i_it->code);
 
Index: src/goto-programs/xml_goto_trace.cpp
===================================================================
--- src/goto-programs/xml_goto_trace.cpp	(revision 5628)
+++ src/goto-programs/xml_goto_trace.cpp	(working copy)
@@ -201,11 +201,13 @@
         xml_call_return.set_attribute("thread", i2string(it->thread_nr));
         xml_call_return.set_attribute("step_nr", i2string(it->step_nr));
 
-        const symbolt &symbol=ns.lookup(it->identifier);
         xmlt &xml_function=xml_call_return.new_element("function");
-        xml_function.set_attribute("display_name", id2string(symbol.display_name()));
+        const symbolt *symbol;
+        if(!ns.lookup(it->identifier, symbol)) {
+          xml_function.set_attribute("display_name", id2string(symbol->display_name()));
+          xml_function.new_element()=xml(symbol->location);
+        }
         xml_function.set_attribute("identifier", id2string(it->identifier));
-        xml_function.new_element()=xml(symbol.location);
 
         if(xml_location.name!="")
           xml_call_return.new_element().swap(xml_location);
Index: src/path-symex/build_goto_trace.cpp
===================================================================
--- src/path-symex/build_goto_trace.cpp	(revision 5628)
+++ src/path-symex/build_goto_trace.cpp	(working copy)
@@ -52,6 +52,8 @@
       trace_step.type=goto_trace_stept::ASSIGNMENT;
       trace_step.full_lhs=step.full_lhs;
       trace_step.full_lhs_value=decision_procedure.get(step.ssa_lhs);
+      trace_step.lhs_object = step.ssa_lhs;
+      trace_step.lhs_object_value = step.ssa_rhs;
       break;
     
     case DECL:
@@ -59,6 +61,10 @@
       trace_step.full_lhs=step.full_lhs;
       trace_step.lhs_object=to_symbol_expr(step.full_lhs);
       trace_step.full_lhs_value=decision_procedure.get(step.ssa_lhs);
+      if (ID_symbol == step.full_lhs.id()) {
+        trace_step.lhs_object = to_symbol_expr(step.full_lhs);
+        trace_step.lhs_object_value = trace_step.full_lhs_value;
+      }
       break;
       
     case DEAD:
Index: src/path-symex/path_symex.cpp
===================================================================
--- src/path-symex/path_symex.cpp	(revision 5628)
+++ src/path-symex/path_symex.cpp	(working copy)
@@ -20,7 +20,7 @@
 
 #include "path_symex_class.h"
 
-//#define DEBUG
+#define DEBUG
 
 #ifdef DEBUG
 #include <iostream>
@@ -129,7 +129,7 @@
 
   // read the address of the lhs, with propagation
   exprt lhs_address=state.read(address_of_exprt(lhs));
-  
+
   // now SSA the lhs, no propagation
   exprt ssa_lhs=
     state.read_no_propagate(dereference_exprt(lhs_address));
@@ -170,7 +170,7 @@
       if(t.is_not_nil()) return t;
     }
   }
-  
+
   return nil_typet();
 }
 
@@ -181,16 +181,16 @@
 {
   if(code.operands().size()!=1)
     throw "malloc expected to have one operand";
-    
+
   // increment dynamic object counter
   unsigned dynamic_count=++state.var_map.dynamic_count;
-  
+
   exprt size=code.op0();
   typet object_type=nil_typet();
-  
+
   {
     exprt tmp_size=state.read(size); // to allow constant propagation
-    
+
     // special treatment for sizeof(T)*x
     if(tmp_size.id()==ID_mult &&
        tmp_size.operands().size()==2 &&
@@ -198,12 +198,12 @@
     {
       object_type=array_typet(
         c_sizeof_type_rec(tmp_size.op0()),
-        tmp_size.op1());      
+        tmp_size.op1());
     }
     else
     {
       typet tmp_type=c_sizeof_type_rec(tmp_size);
-      
+
       if(tmp_type.is_not_nil())
       {
         // Did the size get multiplied?
@@ -219,7 +219,7 @@
           else
           {
             mp_integer elements=alloc_size/elem_size;
-            
+
             if(elements*elem_size==alloc_size)
               object_type=array_typet(tmp_type, from_integer(elements, tmp_size.type()));
           }
@@ -226,18 +226,18 @@
         }
       }
     }
-    
+
     if(object_type.is_nil())
       object_type=array_typet(unsigned_char_type(), tmp_size);
 
     // we introduce a fresh symbol for the size
     // to prevent any issues of the size getting ever changed
-    
+
     if(object_type.id()==ID_array &&
        !to_array_type(object_type).size().is_constant())
     {
       exprt &size=to_array_type(object_type).size();
-    
+
       symbolt size_symbol;
 
       size_symbol.base_name="dynamic_object_size"+i2string(dynamic_count);
@@ -249,13 +249,13 @@
       //state.var_map(size_symbol.name, suffix, size_symbol.type);
 
       assign(state,
-             size_symbol.symbol_expr(), 
+             size_symbol.symbol_expr(),
              size);
 
       size=size_symbol.symbol_expr();
     }
   }
-  
+
   // value
   symbolt value_symbol;
 
@@ -269,7 +269,7 @@
   //state.var_map(value_symbol.name, suffix, value_symbol.type);
 
   address_of_exprt rhs;
-  
+
   if(object_type.id()==ID_array)
   {
     rhs.type()=pointer_typet(value_symbol.type.subtype());
@@ -283,7 +283,7 @@
     rhs.op0()=value_symbol.symbol_expr();
     rhs.type()=pointer_typet(value_symbol.type);
   }
-  
+
   if(rhs.type()!=lhs.type())
     rhs.make_typecast(lhs.type());
 
@@ -304,31 +304,31 @@
 
 void path_symext::assign_rec(
   path_symex_statet &state,
-  exprt::operandst &guard, 
-  const exprt &ssa_lhs, 
+  exprt::operandst &guard,
+  const exprt &ssa_lhs,
   const exprt &ssa_rhs)
 {
   //const typet &ssa_lhs_type=state.var_map.ns.follow(ssa_lhs.type());
-  
+
   #ifdef DEBUG
   std::cout << "assign_rec: " << ssa_lhs.pretty() << std::endl;
   //std::cout << "ssa_lhs_type: " << ssa_lhs_type.id() << std::endl;
   #endif
-  
+
   if(ssa_lhs.id()==ID_symbol)
   {
     // These are expected to be SSA symbols
     assert(ssa_lhs.get_bool(ID_C_SSA_symbol));
-    
+
     const symbol_exprt &symbol_expr=to_symbol_expr(ssa_lhs);
     const irep_idt &full_identifier=symbol_expr.get(ID_C_full_identifier);
-    
+
     #ifdef DEBUG
     const irep_idt &ssa_identifier=symbol_expr.get_identifier();
     std::cout << "SSA symbol identifier: " << ssa_identifier << std::endl;
     std::cout << "full identifier: " << full_identifier << std::endl;
     #endif
-    
+
     var_mapt::var_infot &var_info=state.var_map[full_identifier];
     assert(var_info.full_identifier==full_identifier);
 
@@ -368,7 +368,7 @@
       // record the step
       state.record_step();
       stept &step=*state.history;
-      
+
       if(!guard.empty()) step.guard=conjunction(guard);
       step.full_lhs=ssa_lhs;
       step.ssa_lhs=new_lhs;
@@ -390,7 +390,7 @@
 
     const typet &compound_type=
       state.var_map.ns.follow(struct_op.type());
-  
+
     if(compound_type.id()==ID_struct)
     {
       // We flatten the top-level structs, so this one is inside an
@@ -398,9 +398,9 @@
 
       exprt member_name(ID_member_name);
       member_name.set(ID_component_name, ssa_lhs_member_expr.get_component_name());
-            
+
       with_exprt new_rhs(struct_op, member_name, ssa_rhs);
-      
+
       assign_rec(state, guard, struct_op, new_rhs);
     }
     else if(compound_type.id()==ID_union)
@@ -409,7 +409,7 @@
       exprt offset=gen_zero(index_type());
 
       byte_extract_exprt new_lhs(byte_update_id(), struct_op, offset, ssa_rhs.type());
-      
+
       assign_rec(state, guard, new_lhs, ssa_rhs);
     }
     else
@@ -421,7 +421,7 @@
     std::cout << "assign_rec ID_index" << std::endl;
     #endif
 
-    throw "unexpected array index on lhs";    
+    throw "unexpected array index on lhs";
   }
   else if(ssa_lhs.id()==ID_dereference)
   {
@@ -444,7 +444,7 @@
     guard.push_back(cond);
     assign_rec(state, guard, lhs_if_expr.true_case(), ssa_rhs);
     guard.pop_back();
-    
+
     // false
     guard.push_back(not_exprt(cond));
     assign_rec(state, guard, lhs_if_expr.false_case(), ssa_rhs);
@@ -459,12 +459,12 @@
 
     const byte_extract_exprt &byte_extract_expr=
       to_byte_extract_expr(ssa_lhs);
-  
+
     // assignment to byte_extract operators:
     // turn into byte_update operator
-    
+
     irep_idt new_id;
-    
+
     if(ssa_lhs.id()==ID_byte_extract_little_endian)
       new_id=ID_byte_update_little_endian;
     else if(ssa_lhs.id()==ID_byte_extract_big_endian)
@@ -478,7 +478,7 @@
     new_rhs.op()=byte_extract_expr.op();
     new_rhs.offset()=byte_extract_expr.offset();
     new_rhs.value()=ssa_rhs;
-    
+
     const exprt new_lhs=byte_extract_expr.op();
 
     assign_rec(state, guard, new_lhs, new_rhs);
@@ -489,12 +489,12 @@
       to_struct_type(state.var_map.ns.follow(ssa_lhs.type()));
     const struct_typet::componentst &components=
       struct_type.components();
-    
+
     // split up into components
     const exprt::operandst &operands=ssa_lhs.operands();
-    
+
     assert(operands.size()==components.size());
-    
+
     for(unsigned i=0; i<components.size(); i++)
     {
       exprt new_rhs=
@@ -507,15 +507,15 @@
   else if(ssa_lhs.id()==ID_array)
   {
     const typet &ssa_lhs_type=state.var_map.ns.follow(ssa_lhs.type());
-  
+
     if(ssa_lhs_type.id()!=ID_array)
       throw "array constructor must have array type";
-      
+
     const array_typet &array_type=
       to_array_type(ssa_lhs_type);
-      
+
     const exprt::operandst &operands=ssa_lhs.operands();
-    
+
     // split up into elements
     for(unsigned i=0; i<operands.size(); i++)
     {
@@ -530,9 +530,9 @@
   {
     const vector_typet &vector_type=
       to_vector_type(state.var_map.ns.follow(ssa_lhs.type()));
-    
+
     const exprt::operandst &operands=ssa_lhs.operands();
-    
+
     // split up into elements
     for(unsigned i=0; i<operands.size(); i++)
     {
@@ -591,11 +591,11 @@
 
     if(f_it==state.locs.function_map.end())
       throw "failed to find `"+id2string(function_identifier)+"' in function_map";
-  
+
     const locst::function_entryt &function_entry=f_it->second;
 
     loc_reft function_entry_point=function_entry.first_loc;
-  
+
     // do we have a body?
     if(function_entry_point==loc_reft())
     {
@@ -606,7 +606,7 @@
       state.next_pc();
       return;
     }
-  
+
     // push a frame on the call stack
     path_symex_statet::threadt &thread=state.threads[state.get_current_thread()];
     thread.call_stack.push_back(path_symex_statet::framet());
@@ -624,7 +624,7 @@
         state.
       }
     }
-    
+
     // save the locals into the frame
     for(locst::local_variablest::const_iterator
         it=function_entry.local_variables.begin();
@@ -633,7 +633,7 @@
     {
       unsigned nr=state.var_map[*it].number;
       thread.call_stack.back().saved_local_vars[nr]=thread.local_vars[nr];
-    }    
+    }
     #endif
 
     const code_typet &code_type=function_entry.type;
@@ -641,7 +641,7 @@
     const code_typet::parameterst &function_parameters=code_type.parameters();
 
     const exprt::operandst &call_arguments=call.arguments();
-  
+
     // now assign the argument values to parameters
     for(unsigned i=0; i<call_arguments.size(); i++)
     {
@@ -654,7 +654,7 @@
           throw "function_call " + id2string(function_identifier) + " no identifier for function parameter";
 
         symbol_exprt lhs(identifier, function_parameter.type());
-            
+
         assign(state, lhs, call_arguments[i]);
       }
     }
@@ -674,9 +674,9 @@
   {
     const if_exprt &if_expr=to_if_expr(function);
     exprt guard=if_expr.cond();
-    
+
     // add a 'further state' for the false-case
-    
+
     {
       further_states.push_back(state);
       path_symex_statet &false_state=further_states.back();
@@ -723,7 +723,7 @@
   {
     // update statistics
     state.recursion_map[thread.call_stack.back().current_function]--;
-  
+
     // set PC to return location
     thread.pc=thread.call_stack.back().return_location;
 
@@ -763,17 +763,18 @@
   const goto_programt::instructiont &instruction=
     *state.get_instruction();
 
+  const loct &loc=state.locs[state.pc()];
+  assert(!loc.branch_target.is_nil());
+
   if(instruction.is_backwards_goto())
   {
     // we keep a statistic on how many times we execute backwards gotos
     state.unwinding_map[state.pc()]++;
+    state.backedge_map.insert(std::make_pair(state.pc(), loc.branch_target));
   }
 
-  const loct &loc=state.locs[state.pc()];
-  assert(!loc.branch_target.is_nil());
+  exprt guard=state.read(instruction.guard);
 
-  exprt guard=state.read(instruction.guard);
-  
   if(guard.is_true()) // branch taken always
   {
     state.record_step();
@@ -829,7 +830,7 @@
   }
 
   exprt guard=state.read(instruction.guard);
-  
+
   if(taken)
   {
     // branch taken case
@@ -865,9 +866,18 @@
   path_symex_statet &state,
   std::list<path_symex_statet> &further_states)
 {
+  for(__typeof__(state.backedge_map.begin()) it(state.backedge_map.begin()); it != state.backedge_map.end(); ++it) {
+    if(it->second == state.pc()) {
+      path_symex_statet::backedge_mapt::const_iterator edge(state.backedge_map.find(state.previous_pc));
+      if(state.backedge_map.end() == edge || edge->second != state.pc()) {
+        state.unwinding_map[it->first] = 0;
+      }
+    }
+  }
+  const loc_reft previous_pc(state.pc());
   const goto_programt::instructiont &instruction=
     *state.get_instruction();
-    
+
   #ifdef DEBUG
   std::cout << "path_symext::operator(): "
             << state.pc() << " "
@@ -882,7 +892,7 @@
     state.record_step();
     return_from_function(state, nil_exprt());
     break;
-    
+
   case RETURN:
     // pop the call stack
     {
@@ -892,15 +902,15 @@
       return_from_function(state, return_val);
     }
     break;
-    
+
   case START_THREAD:
     {
       const loct &loc=state.locs[state.pc()];
       assert(!loc.branch_target.is_nil());
-      
+
       state.record_step();
       state.next_pc();
-      
+
       // ordering of the following matters due to vector instability
       path_symex_statet::threadt &new_thread=state.add_thread();
       path_symex_statet::threadt &old_thread=state.threads[state.get_current_thread()];
@@ -908,26 +918,26 @@
       new_thread.local_vars=old_thread.local_vars;
     }
     break;
-    
+
   case END_THREAD:
     state.record_step();
     state.disable_current_thread();
     break;
-    
+
   case GOTO:
     do_goto(state, further_states);
     break;
-    
+
   case CATCH:
     // ignore for now
     state.record_step();
     state.next_pc();
     break;
-    
+
   case THROW:
     state.record_step();
     throw "THROW not yet implemented";
-    
+
   case ASSUME:
     state.record_step();
     state.next_pc();
@@ -939,7 +949,7 @@
       state.history->guard=guard;
     }
     break;
-    
+
   case ASSERT:
   case SKIP:
   case LOCATION:
@@ -971,17 +981,17 @@
     state.next_pc();
     state.inside_atomic_section=false;
     break;
-    
+
   case ASSIGN:
     assign(state, to_code_assign(instruction.code));
     state.next_pc();
     break;
-    
+
   case FUNCTION_CALL:
     state.record_step();
     function_call(state, to_code_function_call(instruction.code), further_states);
     break;
-    
+
   case OTHER:
     state.record_step();
 
@@ -1015,6 +1025,7 @@
   default:
     throw "path_symext: unexpected instruction";
   }
+  state.previous_pc = previous_pc;
 }
 
 /*******************************************************************\
Index: src/path-symex/path_symex_state.h
===================================================================
--- src/path-symex/path_symex_state.h	(revision 5628)
+++ src/path-symex/path_symex_state.h	(working copy)
@@ -185,6 +185,9 @@
   // counts how many times we have executed backwards edges
   typedef std::map<loc_reft, unsigned> unwinding_mapt;
   unwinding_mapt unwinding_map;
+  typedef std::map<loc_reft, loc_reft> backedge_mapt;
+  backedge_mapt backedge_map;
+  loc_reft previous_pc;
 
   // similar for recursive function calls
   typedef std::map<irep_idt, unsigned> recursion_mapt;
Index: src/symex/symex_parse_options.h
===================================================================
--- src/symex/symex_parse_options.h	(revision 5628)
+++ src/symex/symex_parse_options.h	(working copy)
@@ -27,6 +27,7 @@
   "(signed-overflow-check)(unsigned-overflow-check)(nan-check)" \
   "(float-overflow-check)" \
   "(no-assertions)(no-assumptions)" \
+  "(xml-ui)" \
   "(16)(32)(64)(LP64)(ILP64)(LLP64)(ILP32)(LP32)" \
   "(little-endian)(big-endian)" \
   "(error-label):(verbosity):(no-library)" \
