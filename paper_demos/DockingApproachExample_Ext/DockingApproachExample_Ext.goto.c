// #anon_enum$DATA_ITEM=0$MATRIX_ITEM=1$STRUCT_LOG_VAR_ITEM=2$SIGNALS_STRUCT_ITEM=3
// file ../R2013a/rtw/c/src/rt_logging.c line 92
enum anonymous$33 { DATA_ITEM=0, MATRIX_ITEM=1, STRUCT_LOG_VAR_ITEM=2, SIGNALS_STRUCT_ITEM=3 };

// #anon_enum$DIMENSION_PROPAGATION=0$TYPE_PROPAGATION=1$COMPLEX_PROPAGATION=2
// file ../R2013a/simulink/include/simstruc.h line 584
enum anonymous$49 { DIMENSION_PROPAGATION=0, TYPE_PROPAGATION=1, COMPLEX_PROPAGATION=2 };

// #anon_enum$EXTLOGTASK_TRIG_ARM=0$EXTLOGTASK_INIT_EVENT=1$EXTLOGTASK_TERM_INTERMEDIATE_ONESHOT=2$EXTLOGTASK_TERM_SESSION=3
// file ../R2013a/simulink/include/simstruc.h line 685
enum anonymous$51 { EXTLOGTASK_TRIG_ARM=0, EXTLOGTASK_INIT_EVENT=1, EXTLOGTASK_TERM_INTERMEDIATE_ONESHOT=2, EXTLOGTASK_TERM_SESSION=3 };

// #anon_enum$FALLING_ZERO_CROSSING=-1$ANY_ZERO_CROSSING=0$RISING_ZERO_CROSSING=1
// file ../R2013a/simulink/include/simstruc_types.h line 114
enum anonymous$41 { FALLING_ZERO_CROSSING=-1, ANY_ZERO_CROSSING=0, RISING_ZERO_CROSSING=1 };

// #anon_enum$FRAME_INHERITED=-1$FRAME_NO=0$FRAME_YES=1
// file ../R2013a/simulink/include/sl_common_types_def.h line 26
enum anonymous$46 { FRAME_INHERITED=-1, FRAME_NO=0, FRAME_YES=1 };

// #anon_enum$MINOR_TIME_STEP=0$MAJOR_TIME_STEP=1
// file ../R2013a/simulink/include/rtw_continuous.h line 29
enum anonymous$34 { MINOR_TIME_STEP=0, MAJOR_TIME_STEP=1 };

// #anon_enum$NO_LOGVALDIMS=0$LOGVALDIMS_EMPTYMX=1$LOGVALDIMS_VARDIMS=2
// file ../R2013a/rtw/c/src/rt_logging.h line 168
enum anonymous$36 { NO_LOGVALDIMS=0, LOGVALDIMS_EMPTYMX=1, LOGVALDIMS_VARDIMS=2 };

// #anon_enum$RTPARAM_NOT_TRANSFORMED=0$RTPARAM_TRANSFORMED=1$RTPARAM_MAKE_TRANSFORMED_TUNABLE=2
// file ../R2013a/simulink/include/sl_common_types_def.h line 168
enum anonymous$57 { RTPARAM_NOT_TRANSFORMED=0, RTPARAM_TRANSFORMED=1, RTPARAM_MAKE_TRANSFORMED_TUNABLE=2 };

// #anon_enum$SIM_PAUSE=0$SIM_CONTINUE=1
// file ../R2013a/simulink/include/simstruc.h line 591
enum anonymous$50 { SIM_PAUSE=0, SIM_CONTINUE=1 };

// #anon_enum$SL_JM_BD_AUTO=0$SL_JM_BD_SPARSE_PERTURBATION=1$SL_JM_BD_FULL_PERTURBATION=2$SL_JM_BD_SPARSE_ANALYTICAL=3$SL_JM_BD_FULL_ANALYTICAL=4
// file ../R2013a/simulink/include/rtw_solver.h line 33
enum anonymous$44 { SL_JM_BD_AUTO=0, SL_JM_BD_SPARSE_PERTURBATION=1, SL_JM_BD_FULL_PERTURBATION=2, SL_JM_BD_SPARSE_ANALYTICAL=3, SL_JM_BD_FULL_ANALYTICAL=4 };

// #anon_enum$SOLVER_MODE_AUTO=0$SOLVER_MODE_SINGLETASKING=1$SOLVER_MODE_MULTITASKING=2
// file ../R2013a/simulink/include/rtw_continuous.h line 22
enum anonymous$43 { SOLVER_MODE_AUTO=0, SOLVER_MODE_SINGLETASKING=1, SOLVER_MODE_MULTITASKING=2 };

// #anon_enum$SS_DOUBLE=0$SS_SINGLE=1$SS_INT8=2$SS_UINT8=3$SS_INT16=4$SS_UINT16=5$SS_INT32=6$SS_UINT32=7$SS_BOOLEAN=8
// file ../R2013a/simulink/include/sl_types_def.h line 18
enum anonymous$35 { SS_DOUBLE=0, SS_SINGLE=1, SS_INT8=2, SS_UINT8=3, SS_INT16=4, SS_UINT16=5, SS_INT32=6, SS_UINT32=7, SS_BOOLEAN=8 };

// #anon_enum$SS_DWORK_USED_AS_DWORK=0$SS_DWORK_USED_AS_DSTATE=1$SS_DWORK_USED_AS_SCRATCH=2$SS_DWORK_USED_AS_MODE=3
// file ../R2013a/simulink/include/simstruc_types.h line 197
enum anonymous$45 { SS_DWORK_USED_AS_DWORK=0, SS_DWORK_USED_AS_DSTATE=1, SS_DWORK_USED_AS_SCRATCH=2, SS_DWORK_USED_AS_MODE=3 };

// #anon_enum$SS_MATRIX_NONE=0$SS_MATRIX_CONSTANT=1$SS_MATRIX_TIMEDEP=2$SS_MATRIX_STATEDEP=3
// file ../R2013a/simulink/include/rtw_continuous.h line 15
enum anonymous$42 { SS_MATRIX_NONE=0, SS_MATRIX_CONSTANT=1, SS_MATRIX_TIMEDEP=2, SS_MATRIX_STATEDEP=3 };

// #anon_enum$SS_RTWGEN_UNKNOWN=0$SS_RTWGEN_RTW_CODE=1$SS_RTWGEN_ACCELERATOR=2$SS_RTWGEN_MODELREFERENCE_SIM_TARGET=3$SS_RTWGEN_MODELREFERENCE_RTW_TARGET=4
// file ../R2013a/simulink/include/simstruc_types.h line 64
enum anonymous$40 { SS_RTWGEN_UNKNOWN=0, SS_RTWGEN_RTW_CODE=1, SS_RTWGEN_ACCELERATOR=2, SS_RTWGEN_MODELREFERENCE_SIM_TARGET=3, SS_RTWGEN_MODELREFERENCE_RTW_TARGET=4 };

// #anon_enum$SS_SIMMODE_NORMAL=0$SS_SIMMODE_SIZES_CALL_ONLY=1$SS_SIMMODE_RTWGEN=2$SS_SIMMODE_EXTERNAL=3
// file ../R2013a/simulink/include/simstruc_types.h line 46
enum anonymous$52 { SS_SIMMODE_NORMAL=0, SS_SIMMODE_SIZES_CALL_ONLY=1, SS_SIMMODE_RTWGEN=2, SS_SIMMODE_EXTERNAL=3 };

// #anon_enum$mxUNKNOWN_CLASS=0$mxCELL_CLASS=1$mxSTRUCT_CLASS=2$mxLOGICAL_CLASS=3$mxCHAR_CLASS=4$mxRESERVED5_CLASS=5$mxDOUBLE_CLASS=6$mxSINGLE_CLASS=7$mxINT8_CLASS=8$mxUINT8_CLASS=9$mxINT16_CLASS=10$mxUINT16_CLASS=11$mxINT32_CLASS=12$mxUINT32_CLASS=13$mxINT64_CLASS=14$mxUINT64_CLASS=15$mxRESERVED16_CLASS=16$mxRESERVED17_CLASS=17$mxOBJECT_CLASS=18
// file ../R2013a/rtw/c/src/rt_mxclassid.h line 14
enum anonymous$32 { mxUNKNOWN_CLASS=0, mxCELL_CLASS=1, mxSTRUCT_CLASS=2, mxLOGICAL_CLASS=3, mxCHAR_CLASS=4, mxRESERVED5_CLASS=5, mxDOUBLE_CLASS=6, mxSINGLE_CLASS=7, mxINT8_CLASS=8, mxUINT8_CLASS=9, mxINT16_CLASS=10, mxUINT16_CLASS=11, mxINT32_CLASS=12, mxUINT32_CLASS=13, mxINT64_CLASS=14, mxUINT64_CLASS=15, mxRESERVED16_CLASS=16, mxRESERVED17_CLASS=17, mxOBJECT_CLASS=18 };

// tag-#anon#ST[*{V}$V$'blockIO'||*{cV}$cV$'constBlockIO'||*{V}$V$'defaultParam'||*{U8}$U8$'prevZCSigState'||*{F64}$F64$'contStates'||*{F64}$F64$'derivs'||*{V}$V$'zcSignalValues'||*{V}$V$'inputs'||*{V}$V$'outputs'||*{U8}$U8$'contStateDisabled'||U8'zCCacheNeedsReset'||U8'derivCacheNeedsReset'||U8'blkStateChange'||U40'$pad0'||*{V}$V$'dwork'|]
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.h line 889
struct anonymous$53;

// tag-#anon#ST[*{cV}$cV$'mappingInfo'||*{V}$V$'xpcData'|]
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.h line 937
struct anonymous$55;

// tag-#anon#ST[ARR4{U32}$U32$'checksums'||U32'options'||S32'numContStates'||S32'numU'||S32'numY'||S32'numSampTimes'||S32'numBlocks'||S32'numBlockIO'||S32'numBlockPrms'||S32'numDwork'||S32'numSFcnPrms'||S32'numSFcns'||S32'numIports'||S32'numOports'||S32'numNonSampZCs'||S32'sysDirFeedThru'||S32'rtwGenSfcn'|]
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.h line 912
struct anonymous$54;

// tag-#anon#ST[BF{U32}$U32$'DisableBoundsChecking'||BF{U32}$U32$'ExtModeUpload'||BF{U32}$U32$'rtwIdMustResolveToSignalObject'||BF{U32}$U32$'rtwIdDoneResolve'||BF{U32}$U32$'ensureResetForSizeVary'||BF{U32}$U32$'minMaxCheckpoint'||BF{U32}$U32$'optimizeInIR'||BF{U32}$U32$'reserved7'||BF{U32}$U32$'reserved16'|]
// file ../R2013a/simulink/include/simstruc.h line 920
struct anonymous$19;

// tag-#anon#ST[BF{U32}$U32$'alreadyWarned'||BF{U32}$U32$'reserved15'||BF{U32}$U32$'reserved16'|]
// file ../R2013a/simulink/include/simstruc.h line 2244
struct anonymous$18;

// tag-#anon#ST[BF{U32}$U32$'hasMdlDimensionsFcn'||BF{U32}$U32$'usesNumPorts'||BF{U32}$U32$'vectMode'||BF{U32}$U32$'blockReduction'||BF{U32}$U32$'treatAsAtomic'||BF{U32}$U32$'rtwcg'||BF{U32}$U32$'needAbsoluteTime'||BF{U32}$U32$'explicitFCSSCtrl'||BF{U32}$U32$'modelRefTsInhSupLevel'||BF{U32}$U32$'needElapseTime'||BF{U32}$U32$'hasSubFunctions'||BF{U32}$U32$'callsOutputInInit'||BF{U32}$U32$'disableMdlProjection'||BF{U32}$U32$'modelRefNormalModeSupport'||BF{U32}$U32$'simStateCompliance'||BF{U32}$U32$'simStateVisibility'||BF{U32}$U32$'disableMdlSlvrJacobian'||BF{U32}$U32$'isRapidAcceleratorActive'||BF{U32}$U32$'isConcurrentTasks'||BF{U32}$U32$'usesCustomCodeFcns'||BF{U32}$U32$'reserved'|]
// file ../R2013a/simulink/include/simstruc.h line 826
struct anonymous$2;

// tag-#anon#ST[BF{U32}$U32$'optimOpts'||BF{U32}$U32$'frameData'||BF{U32}$U32$'cToMergeBlk'||BF{U32}$U32$'constOutputExprInRTW'||BF{U32}$U32$'outputExprInRTW'||BF{U32}$U32$'trivialOutputExprInRTW'||BF{U32}$U32$'okToMerge'||BF{U32}$U32$'cecId'||BF{U32}$U32$'nonContPort'||BF{U32}$U32$'dimensionsMode'||BF{U32}$U32$'fedByBlockWithModesNoZCs'||BF{U32}$U32$'busMode'||BF{U32}$U32$'optimizeInIR'||BF{U32}$U32$'reserved13'|]
// file ../R2013a/simulink/include/simstruc.h line 1007
struct anonymous$24;

// tag-#anon#ST[BF{U32}$U32$'overWritable'||BF{U32}$U32$'optimOpts'||BF{U32}$U32$'frameData'||BF{U32}$U32$'contiguity'||BF{U32}$U32$'acceptExprInRTW'||BF{U32}$U32$'cinId'||BF{U32}$U32$'nonDerivPort'||BF{U32}$U32$'dimensionsMode'||BF{U32}$U32$'busMode'||BF{U32}$U32$'optimizeInIR'||BF{U32}$U32$'reserved1'||BF{U32}$U32$'reserved16'|]
// file ../R2013a/simulink/include/simstruc.h line 973
struct anonymous$22;

// tag-#anon#ST[BF{U32}$U32$'zcCacheNeedsReset'||BF{U32}$U32$'derivCacheNeedsReset'||BF{U32}$U32$'blkStateChange'||BF{U32}$U32$'reserved_1'||BF{U32}$U32$'forceSfcnExceptionHandling'||BF{U32}$U32$'inlineParameters'||BF{U32}$U32$'solverAssertCheck'||BF{U32}$U32$'minStepViolatedError'||BF{U32}$U32$'reservedone'||BF{U32}$U32$'noZCStateUpdate'||BF{U32}$U32$'computingJacobian'||BF{U32}$U32$'solverCheckingCIC'||BF{U32}$U32$'errorStatusIsMsg'||BF{U32}$U32$'timeTweakWarn'||BF{U32}$U32$'solverRequestingReset'||BF{U32}$U32$'firstInitCondCalled'||BF{U32}$U32$'sparseSlvrJacobian'||BF{U32}$U32$'frameUpgradeWarn'||BF{U32}$U32$'outputMethodComputed'||BF{U32}$U32$'reserved15'|]
// file ../R2013a/simulink/include/simstruc.h line 1653
struct anonymous$47;

// tag-#anon#ST[F32're'||F32'im'|]
// file ../R2013a/extern/include/tmwtypes.h line 555
struct anonymous$38;

// tag-#anon#ST[F64're'||F64'im'|]
// file ../R2013a/extern/include/tmwtypes.h line 564
struct anonymous$39;

// tag-#anon#ST[F64'stepSize'||U32'clockTick0'||U32'clockTickH0'||F64'stepSize0'||F64'tStart'||F64'tFinal'||F64'timeOfLastOutput'||*{V}$V$'timingData'||*{F64}$F64$'varNextHitTimesList'||EN#anon_enum$MINOR_TIME_STEP=0$MAJOR_TIME_STEP=1#{U32}$U32$'simTimeStep'||U8'stopRequestedFlag'||U24'$pad0'||*{F64}$F64$'sampleTimes'||*{F64}$F64$'offsetTimes'||*{S32}$S32$'sampleTimeTaskIDPtr'||*{S32}$S32$'sampleHits'||*{S32}$S32$'perTaskSampleHits'||*{F64}$F64$'t'||ARR1{F64}$F64$'sampleTimesArray'||ARR1{F64}$F64$'offsetTimesArray'||ARR1{S32}$S32$'sampleTimeTaskIDArray'||ARR1{S32}$S32$'sampleHitArray'||ARR1{S32}$S32$'perTaskSampleHitsArray'||U32'$pad1'||ARR1{F64}$F64$'tArray'|]
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.h line 947
struct anonymous$56;

// tag-#anon#ST[S32'sfEvent'||S8'OrbitalState_Position'||S8'OrbitalState_Velocity'||S8'OrbitalState_Attitude'||S8'OrbitalState_Time'||S8'InertialNavigation_AbsolutePosi'||S8'InertialNavigation_AbsoluteAtti'||S8'InertialNavigation_AbsoluteVelo'||S8'GPS_AbsoluteVelocity'||S8'GPS_AbsoluteTime'||S8'StarPlanetTracker_AbsoluteAttit'||S8'StarPlanetTracker_AbsolutePosit'||S8'StarPlanetTracker_AbsoluteTime'||S8'StarPlanetTracker_AbsoluteVeloc'||S8'GPS_AbsolutePosition'||S8'dockingSensor_RelativePosition'||S8'dockingSensor_RelativeVelocity'||S8'dockingSensor_RelativeAttitude'||S8'dockingSensor_targetState'||S8'thrust_status'||S8'fuel_status'||S8'DockingApproach_timer'||S8'CaptureApproach_timer'||S8'latch_status'||S8'LatchCapture_timer'||S8'dockingSensor_timer'||S8'InertialNavigation_timer'||S8'StarPlanetTracker_timer'||S8'GPS_timer'||U8'is_active_c1_DockingApproachExa'||U8'is_active_fuel'||U8'is_active_thrust'||U8'is_MissionPhaseStates'||U8'is_active_MissionPhaseStates'||U8'is_DockingApproach'||U8'is_active_DockingApproach'||U8'is_dockingSensor'||U8'is_active_dockingSensor'||U8'is_CaptureApproach'||U8'is_active_CaptureApproach'||U8'is_active_OrbitalState_Active'||U8'is_active_OrbitalState_Complex'||U8'is_OrbitalState'||U8'is_active_OrbitalState'||U8'is_OrbitalState2'||U8'is_active_OrbitalState2'||U8'is_GPS'||U8'is_active_GPS'||U8'is_StarPlanetTracker'||U8'is_active_StarPlanetTracker'||U8'is_InertialNavigation'||U8'is_active_InertialNavigation'||U8'is_LatchCaptureCheck'||U8'is_active_LatchCaptureCheck'||U8'is_latch'||U8'is_active_latch'||U8'VALID'|]
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.h line 771
struct anonymous$10;

// tag-#anon#ST[S32'sizeInBytes'||U32'$pad0'||*{S8}$S8$'pCurrVal'||*{S8}$S8$'pPrevVal'|]
// file ../R2013a/simulink/include/simstruc.h line 1593
struct anonymous$48;

// tag-#anon#ST[S32'stopExecutionFlag'||S32'isrOverrun'||ARR10{S32}$S32$'overrunFlags'||ARR10{S32}$S32$'eventFlags'||*{cS8}$cS8$'errmsg'|]
// file ../R2013a/rtw/c/grt/classic_main.c line 155
struct anonymous$20;

// tag-#anon#ST[S8'GroundTrack_OrbitalPosition'||S8'GroundTrack_OrbitalVelocity'||S8'dockVisibility_status'||U8'opticsAvailability_status'||U8'sunlight_status'||S8'GPS_satelliteVisibility_status'||U8'GPS_receiverAvailability_status'||S8'StarPlanetTracker_planetVisibil'||S8'StarPlanetTracker_starVisibilit'||U8'InertialNavigation_time'||S8'GroundTrack_Time'||S8'RealTimeClock_time'||S8'StageTransition'|]
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.h line 832
struct anonymous$11;

// tag-#anon#ST[SYM#tag-#anon#ST[U32'wordH'||U32'wordL'|]#'words'|]
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.h line 33
struct anonymous$59;

// tag-#anon#ST[SYM#tag-#anon#ST[U32'wordL'||U32'wordH'|]#'words'|]
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.h line 40
struct anonymous$61;

// tag-#anon#ST[SYM#tag-#anon#UN[F32'wordLreal'||U32'wordLuint'|]#'wordL'|]
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.h line 47
struct anonymous$28;

// tag-#anon#ST[SYM#tag-_ssSFcnModelMethods#'sFcn'|]
// file ../R2013a/simulink/include/simstruc.h line 2318
struct anonymous$4;

// tag-#anon#ST[U32'wordH'||U32'wordL'|]
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.h line 34
struct anonymous$58;

// tag-#anon#ST[U32'wordL'||U32'wordH'|]
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.h line 41
struct anonymous$60;

// tag-#anon#ST[U8'CaptureApproachComplete'||U8'DockingApproachComplete'||U8'AttemptingToDock'||U8'LatchCaptureComplete'||U8'DockingApproach'||U8'ApproachOrbitComplete'||U8'FarApproachComplete'||U8'ProximityOperationsComplete'||U8'FailedApproach'||U8'JointMission'||U8'CaptureApproachFailed'|]
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.h line 849
struct anonymous$13;

// tag-#anon#UN[*{*{cS8}$cS8$}$*{cS8}$cS8$$'cptr'||*{*{S8}$S8$}$*{S8}$S8$$'ptr'|]
// file ../R2013a/simulink/include/rtw_matlogging.h line 48
union anonymous$5;

// tag-#anon#UN[*{P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$)->V}$P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$)->V$'level2'||*{P(*{F64}$F64$|*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$)->V}$P(*{F64}$F64$|*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$)->V$'level1'|]
// file ../R2013a/simulink/include/simstruc.h line 2110
union anonymous$8;

// tag-#anon#UN[*{P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$)->V}$P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$)->V$'level2'||*{P(*{F64}$F64$|*{cF64}$cF64$|*{cF64}$cF64$|*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32)->V}$P(*{F64}$F64$|*{cF64}$cF64$|*{cF64}$cF64$|*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32)->V$'level1'|]
// file ../R2013a/simulink/include/simstruc.h line 2132
union anonymous$14;

// tag-#anon#UN[*{P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32)->V}$P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32)->V$'level2'||*{P(*{F64}$F64$|*{cF64}$cF64$|*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32)->V}$P(*{F64}$F64$|*{cF64}$cF64$|*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32)->V$'level1'|]
// file ../R2013a/simulink/include/simstruc.h line 2127
union anonymous$12;

// tag-#anon#UN[*{P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32)->V}$P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32)->V$'level2'||*{P(*{F64}$F64$|*{cF64}$cF64$|*{cF64}$cF64$|*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32)->V}$P(*{F64}$F64$|*{cF64}$cF64$|*{cF64}$cF64$|*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32)->V$'level1'|]
// file ../R2013a/simulink/include/simstruc.h line 2122
union anonymous$9;

// tag-#anon#UN[*{P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32|S32)->V}$P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32|S32)->V$'mdlSetInputPortComplexSignal'||*{P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$)->V}$P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$)->V$'mdlEnable'|]
// file ../R2013a/simulink/include/simstruc.h line 2140
union anonymous$15;

// tag-#anon#UN[*{P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32|S32)->V}$P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32|S32)->V$'mdlSetInputPortWidth'||*{P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32|*{cSYM#tag-DimsInfo_tag#}$cSYM#tag-DimsInfo_tag#$)->V}$P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32|*{cSYM#tag-DimsInfo_tag#}$cSYM#tag-DimsInfo_tag#$)->V$'mdlSetInputPortDims'|]
// file ../R2013a/simulink/include/simstruc.h line 2089
union anonymous$6;

// tag-#anon#UN[*{P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32|S32)->V}$P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32|S32)->V$'mdlSetOutputPortComplexSignal'||*{P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$)->V}$P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$)->V$'mdlDisable'|]
// file ../R2013a/simulink/include/simstruc.h line 2146
union anonymous$16;

// tag-#anon#UN[*{P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32|S32)->V}$P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32|S32)->V$'mdlSetOutputPortWidth'||*{P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32|*{cSYM#tag-DimsInfo_tag#}$cSYM#tag-DimsInfo_tag#$)->V}$P(*{SYM#tag-SimStruct_tag#}$SYM#tag-SimStruct_tag#$|S32|*{cSYM#tag-DimsInfo_tag#}$cSYM#tag-DimsInfo_tag#$)->V$'mdlSetOutputPortDims'|]
// file ../R2013a/simulink/include/simstruc.h line 2094
union anonymous$7;

// tag-#anon#UN[*{SYM#tag-_ssDWorkRecord#}$SYM#tag-_ssDWorkRecord#$'sfcn'||*{V}$V$'root'|]
// file ../R2013a/simulink/include/simstruc.h line 1084
union anonymous$31;

// tag-#anon#UN[*{V}$V$'vect'||*{c*{cF64}$cF64$}$c*{cF64}$cF64$$'uPtrs'|]
// file ../R2013a/simulink/include/simstruc.h line 2234
union anonymous$17;

// tag-#anon#UN[*{c*{cS8}$cS8$}$c*{cS8}$cS8$$'cptr'||*{*{S8}$S8$}$*{S8}$S8$$'ptr'|]
// file ../R2013a/simulink/include/rtw_matlogging.h line 81
union anonymous$23;

// tag-#anon#UN[*{cS8}$cS8$'str'||*{V}$V$'msg'|]
// file ../R2013a/simulink/include/simstruc.h line 2282
union anonymous$3;

// tag-#anon#UN[*{cSYM#tag-RTWLogSignalInfo_tag#}$cSYM#tag-RTWLogSignalInfo_tag#$'cptr'||*{SYM#tag-RTWLogSignalInfo_tag#}$SYM#tag-RTWLogSignalInfo_tag#$'ptr'|]
// file ../R2013a/simulink/include/rtw_matlogging.h line 116
union anonymous$37;

// tag-#anon#UN[*{cV}$cV$'vect'||*{c*{cV}$cV$}$c*{cV}$cV$$'ptrs'|]
// file ../R2013a/simulink/include/simstruc.h line 966
union anonymous$21;

// tag-#anon#UN[F32'wordLreal'||U32'wordLuint'|]
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.h line 48
union anonymous;

// tag-#anon#UN[S32'numInputPorts'||S32'numU'|]
// file ../R2013a/simulink/include/simstruc.h line 768
union anonymous$1;

// tag-#anon#UN[S32'numOutputPorts'||S32'numY'|]
// file ../R2013a/simulink/include/simstruc.h line 761
union anonymous$0;

// tag-#anon#UN[S32'numRtp'||*{V}$V$'placeholder'|]
// file ../R2013a/simulink/include/simstruc.h line 1069
union anonymous$29;

// tag-DimsInfo_tag
// file ../R2013a/simulink/include/simstruc_types.h line 160
struct DimsInfo_tag;

// tag-LogInfo_Tag
// file ../R2013a/rtw/c/src/rt_logging.c line 72
struct LogInfo_Tag;

// tag-LogVar_Tag
// file ../R2013a/rtw/c/src/rt_logging.h line 32
struct LogVar_Tag;

// tag-MatItem_tag
// file ../R2013a/rtw/c/src/rt_logging.c line 86
struct MatItem_tag;

// tag-MatrixData_Tag
// file ../R2013a/rtw/c/src/rt_logging.h line 35
struct MatrixData_Tag;

// tag-RTWLogDataTypeConvert_tag
// file ../R2013a/simulink/include/rtw_matlogging.h line 21
struct RTWLogDataTypeConvert_tag;

// tag-RTWLogSignalInfo_tag
// file ../R2013a/simulink/include/rtw_matlogging.h line 36
struct RTWLogSignalInfo_tag;

// tag-SignalsStruct_Tag
// file ../R2013a/rtw/c/src/rt_logging.h line 110
struct SignalsStruct_Tag;

// tag-SimStruct_tag
// file ../R2013a/simulink/include/simstruc.h line 141
struct SimStruct_tag;

// tag-SparseHeader_Tag
// file ../R2013a/simulink/include/simstruc_types.h line 227
struct SparseHeader_Tag;

// tag-StructLogVar_Tag
// file ../R2013a/rtw/c/src/rt_logging.h line 33
struct StructLogVar_Tag;

// tag-TimingData_Tag
// file ../R2013a/rtw/c/src/rt_sim.c line 49
struct TimingData_Tag;

// tag-ValDimsData_Tag
// file ../R2013a/rtw/c/src/rt_logging.h line 65
struct ValDimsData_Tag;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_RTWExtModeInfo_tag
// file ../R2013a/simulink/include/rtw_extmode.h line 17
struct _RTWExtModeInfo_tag;

// tag-_RTWLogInfo_tag
// file ../R2013a/simulink/include/rtw_matlogging.h line 77
struct _RTWLogInfo_tag;

// tag-_RTWRTModelMethodsInfo_tag
// file ../R2013a/simulink/include/rtw_continuous.h line 56
struct _RTWRTModelMethodsInfo_tag;

// tag-_rtTimingBridge_tag
// file ../R2013a/simulink/include/simstruc_types.h line 94
struct _rtTimingBridge_tag;

// tag-_ssBlkInfo
// file ../R2013a/simulink/include/simstruc.h line 1132
struct _ssBlkInfo;

// tag-_ssBlkInfo2
// file ../R2013a/simulink/include/simstruc.h line 1124
struct _ssBlkInfo2;

// tag-_ssCallSys
// file ../R2013a/simulink/include/simstruc.h line 1802
struct _ssCallSys;

// tag-_ssConstraintsInfo
// file ../R2013a/simulink/include/simstruc.h line 2074
struct _ssConstraintsInfo;

// tag-_ssDWorkAuxRecord
// file ../R2013a/simulink/include/simstruc.h line 916
struct _ssDWorkAuxRecord;

// tag-_ssDWorkRecord
// file ../R2013a/simulink/include/simstruc_types.h line 209
struct _ssDWorkRecord;

// tag-_ssInPortVarDims
// file ../R2013a/simulink/include/simstruc.h line 1097
struct _ssInPortVarDims;

// tag-_ssMassMatrixInfo
// file ../R2013a/simulink/include/simstruc.h line 2065
struct _ssMassMatrixInfo;

// tag-_ssMdlInfo
// file ../R2013a/simulink/include/simstruc.h line 1615
struct _ssMdlInfo;

// tag-_ssOutPortVarDims
// file ../R2013a/simulink/include/simstruc.h line 1105
struct _ssOutPortVarDims;

// tag-_ssPortInfo
// file ../R2013a/simulink/include/simstruc.h line 1036
struct _ssPortInfo;

// tag-_ssPortInfo2
// file ../R2013a/simulink/include/simstruc.h line 1114
struct _ssPortInfo2;

// tag-_ssPortInputs
// file ../R2013a/simulink/include/simstruc.h line 958
struct _ssPortInputs;

// tag-_ssPortOutputs
// file ../R2013a/simulink/include/simstruc.h line 998
struct _ssPortOutputs;

// tag-_ssRegDataType
// file ../R2013a/simulink/include/simstruc.h line 1848
struct _ssRegDataType;

// tag-_ssResolveCBK
// file ../R2013a/simulink/include/simstruc.h line 1819
struct _ssResolveCBK;

// tag-_ssSFcnModelMethods
// file ../R2013a/simulink/include/simstruc.h line 2082
struct _ssSFcnModelMethods;

// tag-_ssSFcnModelMethods2
// file ../R2013a/simulink/include/simstruc.h line 2172
struct _ssSFcnModelMethods2;

// tag-_ssSFcnModelMethods3
// file ../R2013a/simulink/include/simstruc.h line 2159
struct _ssSFcnModelMethods3;

// tag-_ssSFcnParams
// file ../R2013a/simulink/include/simstruc.h line 1061
struct _ssSFcnParams;

// tag-_ssSizes
// file ../R2013a/simulink/include/simstruc.h line 758
struct _ssSizes;

// tag-_ssSolverInfo_tag
// file ../R2013a/simulink/include/rtw_solver.h line 42
struct _ssSolverInfo_tag;

// tag-_ssStInfo
// file ../R2013a/simulink/include/simstruc.h line 1879
struct _ssStInfo;

// tag-_ssStates
// file ../R2013a/simulink/include/simstruc.h line 2233
struct _ssStates;

// tag-_ssStatesInfo2
// file ../R2013a/simulink/include/simstruc.h line 2225
struct _ssStatesInfo2;

// tag-_ssWork
// file ../R2013a/simulink/include/simstruc.h line 1077
struct _ssWork;

// tag-ssParamRec_tag
// file ../R2013a/simulink/include/sl_common_types_def.h line 194
struct ssParamRec_tag;

// tag-ssSparseMatrixInfo_tag
// file ../R2013a/simulink/include/simstruc.h line 737
struct ssSparseMatrixInfo_tag;

// tag-tag_RTM_DockingApproachExampl_T
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext_types.h line 20
struct tag_RTM_DockingApproachExampl_T;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// D_exit_internal_CaptureApproach
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 102
static void D_exit_internal_CaptureApproach(void);
// D_exit_internal_DockingApproach
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 996
static void D_exit_internal_DockingApproach(void);
// DockingAppr_OrbitalState_Active
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 277
static void DockingAppr_OrbitalState_Active(void);
// DockingAppro_InertialNavigation
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 149
static void DockingAppro_InertialNavigation(void);
// DockingAppro_MissionPhaseStates
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 1550
static void DockingAppro_MissionPhaseStates(void);
// DockingApproachExample_Ext
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2352
struct tag_RTM_DockingApproachExampl_T * DockingApproachExample_Ext(void);
// DockingApproachExample_Ext_initialize
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2176
void DockingApproachExample_Ext_initialize(void);
// DockingApproachExample_Ext_output
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2123
static void DockingApproachExample_Ext_output(void);
// DockingApproachExample_Ext_terminate
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2303
void DockingApproachExample_Ext_terminate(void);
// DockingApproachExample_Ext_update
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2153
static void DockingApproachExample_Ext_update(void);
// DockingApproach_DockingApproach
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 1136
static void DockingApproach_DockingApproach(void);
// MdlInitialize
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2337
void MdlInitialize(void);
// MdlInitializeSampleTimes
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2333
void MdlInitializeSampleTimes(void);
// MdlInitializeSizes
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2329
void MdlInitializeSizes(void);
// MdlOutputs
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2311
void MdlOutputs(signed int tid);
// MdlStart
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2341
void MdlStart(void);
// MdlTerminate
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2346
void MdlTerminate(void);
// MdlUpdate
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2320
void MdlUpdate(signed int tid);
// _Learn_assert
// file ../R2013a/rtw/c/grt/classic_main.c line 655 function main
signed int _Learn_assert(void);
// __assert_fail
// file /usr/include/assert.h line 67
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// displayUsage
// file ../R2013a/rtw/c/grt/classic_main.c line 382
static void displayUsage(void);
// enter_internal_OrbitalState_Act
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 1039
static void enter_internal_OrbitalState_Act(void);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// floor
// file /usr/include/bits/mathcalls.h line 184
extern double floor(double);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// ldexp
// file /usr/include/bits/mathcalls.h line 106
extern double ldexp(double, signed int);
// local_CreateStructLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 2012
static struct StructLogVar_Tag * local_CreateStructLogVar(struct _RTWLogInfo_tag *li, const double startTime, const double finalTime, const double inStepSize, const char **errStatus, const char *varName, unsigned char logTime, signed int maxRows, signed int decimation, double sampleTime, const struct RTWLogSignalInfo_tag *sigInfo, const char *blockName);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// remove
// file /usr/include/stdio.h line 178
extern signed int remove(const char *);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// rtGetInf
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rtGetInf.h line 23
extern double rtGetInf(void);
// rtGetInfF
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rtGetInf.h line 24
extern float rtGetInfF(void);
// rtGetMinusInf
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rtGetInf.h line 25
extern double rtGetMinusInf(void);
// rtGetMinusInfF
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rtGetInf.h line 26
extern float rtGetMinusInfF(void);
// rtGetNaN
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rtGetNaN.c line 28
extern double rtGetNaN(void);
// rtGetNaNF
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rtGetNaN.c line 76
extern float rtGetNaNF(void);
// rtIsInf
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.c line 49
extern unsigned char rtIsInf(double value);
// rtIsInfF
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.c line 55
extern unsigned char rtIsInfF(float value);
// rtIsNaN
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.c line 61
extern unsigned char rtIsNaN(double value);
// rtIsNaNF
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.c line 67
extern unsigned char rtIsNaNF(float value);
// rt_CreateLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 2898
extern struct LogVar_Tag * rt_CreateLogVar(struct _RTWLogInfo_tag *li, const double startTime, const double finalTime, const double inStepSize, const char **errStatus, const char *varName, enum anonymous$35 inpDataTypeID, signed int logical, signed int complex, signed int frameData, signed int nCols, signed int nDims, const signed int *dims, enum anonymous$36 logValDimsStat, void **currSigDims, signed int *currSigDimsSize, signed int maxRows, signed int decimation, double sampleTime, signed int appendToLogVarsList);
// rt_CreateLogVarWithConvert
// file ../R2013a/rtw/c/src/rt_logging.c line 2521
extern struct LogVar_Tag * rt_CreateLogVarWithConvert(struct _RTWLogInfo_tag *li, const double startTime, const double finalTime, const double inStepSize, const char **errStatus, const char *varName, enum anonymous$35 inpDataTypeID, const struct RTWLogDataTypeConvert_tag *pDataTypeConvertInfo, signed int logical, signed int complex, signed int frameData, signed int nCols, signed int nDims, const signed int *dims, enum anonymous$36 logValDimsStat, void **currSigDims, signed int *currSigDimsSize, signed int maxRows, signed int decimation, double sampleTime, signed int appendToLogVarsList);
// rt_CreateStructLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 2966
extern struct StructLogVar_Tag * rt_CreateStructLogVar(struct _RTWLogInfo_tag *li, const double startTime, const double finalTime, const double inStepSize, const char **errStatus, const char *varName, unsigned char logTime, signed int maxRows, signed int decimation, double sampleTime, const struct RTWLogSignalInfo_tag *sigInfo, const char *blockName);
// rt_DestroyLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 1399
static void rt_DestroyLogVar(struct LogVar_Tag *head);
// rt_DestroyStructLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 1429
static void rt_DestroyStructLogVar(struct StructLogVar_Tag *head);
// rt_FixupLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 1127
static const char * rt_FixupLogVar(struct LogVar_Tag *var, signed int verbose);
// rt_GetActualDTypeID
// file ../R2013a/rtw/c/src/rt_logging.c line 1383
static enum anonymous$35 rt_GetActualDTypeID(enum anonymous$35 dTypeID);
// rt_GetDataTypeConvertInfo
// file ../R2013a/rtw/c/src/rt_logging.c line 287
static struct RTWLogDataTypeConvert_tag rt_GetDataTypeConvertInfo(const struct RTWLogDataTypeConvert_tag *pDataTypeConvertInfo, enum anonymous$35 dTypeID);
// rt_GetDblValueFromOverSizedData
// file ../R2013a/rtw/c/src/rt_logging.c line 316
static double rt_GetDblValueFromOverSizedData(const void *pVoid, signed int bitsPerChunk, signed int numOfChunk, unsigned int isSigned, double fracSlope, signed int fixedExp, double bias);
// rt_GetMatIdFromMxId
// file ../R2013a/rtw/c/src/rt_logging.c line 485
static signed int rt_GetMatIdFromMxId(enum anonymous$32 mxID);
// rt_GetMxIdFromDTypeId
// file ../R2013a/rtw/c/src/rt_logging.c line 461
extern enum anonymous$32 rt_GetMxIdFromDTypeId(enum anonymous$35 dTypeID);
// rt_GetMxIdFromDTypeIdForRSim
// file ../R2013a/rtw/c/src/rt_logging.c line 430
extern enum anonymous$32 rt_GetMxIdFromDTypeIdForRSim(enum anonymous$35 dTypeID);
// rt_GetNextSampleHit
// file ../R2013a/rtw/c/src/rt_sim.c line 570
extern double rt_GetNextSampleHit(void);
// rt_GetNonBoolMxIdFromDTypeId
// file ../R2013a/rtw/c/src/rt_logging.c line 378
enum anonymous$32 rt_GetNonBoolMxIdFromDTypeId(enum anonymous$35 dTypeID);
// rt_GetSizeofComplexType
// file ../R2013a/rtw/c/src/rt_logging.c line 227
static unsigned long int rt_GetSizeofComplexType(enum anonymous$35 dTypeID);
// rt_GetSizeofDataType
// file ../R2013a/rtw/c/src/rt_logging.c line 185
static unsigned long int rt_GetSizeofDataType(enum anonymous$35 dTypeID);
// rt_InitInfAndNaN
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.c line 37
extern void rt_InitInfAndNaN(unsigned long int realSize);
// rt_InitSignalsStruct
// file ../R2013a/rtw/c/src/rt_logging.c line 1465
static const char * rt_InitSignalsStruct(struct _RTWLogInfo_tag *li, const double startTime, const double finalTime, const double inStepSize, const char **errStatus, struct StructLogVar_Tag *var, signed int maxRows, signed int decimation, double sampleTime, const struct RTWLogSignalInfo_tag *sigInfo);
// rt_InitTimingEngine
// file ../R2013a/rtw/c/src/rt_sim.c line 537
extern const char * rt_InitTimingEngine(struct SimStruct_tag *S);
// rt_LoadModifiedLogVarName
// file ../R2013a/rtw/c/src/rt_logging.c line 1350
static void rt_LoadModifiedLogVarName(const struct _RTWLogInfo_tag *li, const char *varName, char *logVarName);
// rt_ODECreateIntegrationData
// file ../R2013a/rtw/c/grt/classic_main.c line 664
extern void rt_ODECreateIntegrationData(struct _ssSolverInfo_tag *si);
// rt_ODEUpdateContinuousStates
// file ../R2013a/rtw/c/grt/classic_main.c line 667
extern void rt_ODEUpdateContinuousStates(struct _ssSolverInfo_tag *si);
// rt_OneStep
// file ../R2013a/rtw/c/grt/classic_main.c line 192
static void rt_OneStep(struct tag_RTM_DockingApproachExampl_T *S);
// rt_ProcessMatItem
// file ../R2013a/rtw/c/src/rt_logging.c line 554
static signed int rt_ProcessMatItem(struct _IO_FILE *fp, struct MatItem_tag *pItem, enum anonymous$33 itemKind, signed int cmd);
// rt_ReallocLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 2311
void rt_ReallocLogVar(struct LogVar_Tag *var, unsigned char isVarDims);
// rt_SimGetNextSampleHit
// file ../R2013a/rtw/c/src/rt_sim.c line 278
extern double rt_SimGetNextSampleHit(void);
// rt_SimInitTimingEngine
// file ../R2013a/rtw/c/src/rt_sim.c line 87
extern const char * rt_SimInitTimingEngine(signed int rtmNumSampTimes, double rtmStepSize, double *rtmSampleTimePtr, double *rtmOffsetTimePtr, signed int *rtmSampleHitPtr, signed int *rtmSampleTimeTaskIDPtr, double rtmTStart, enum anonymous$34 *rtmSimTimeStepPtr, void **rtmTimingDataPtr);
// rt_SimUpdateDiscreteTaskSampleHits
// file ../R2013a/rtw/c/src/rt_sim.c line 332
extern void rt_SimUpdateDiscreteTaskSampleHits(signed int rtmNumSampTimes, void *rtmTimingData, signed int *rtmSampleHitPtr, double *rtmTPtr);
// rt_StartDataLogging
// file ../R2013a/rtw/c/src/rt_logging.h line 249
extern const char * rt_StartDataLogging(struct _RTWLogInfo_tag *li, const double finalTime, const double stepSize, const char **errStatus);
// rt_StartDataLoggingForOutput
// file ../R2013a/rtw/c/src/rt_logging.c line 2156
const char * rt_StartDataLoggingForOutput(struct _RTWLogInfo_tag *li, const double startTime, const double finalTime, const double stepSize, const char **errStatus);
// rt_StartDataLoggingWithStartTime
// file ../R2013a/rtw/c/src/rt_logging.c line 3018
extern const char * rt_StartDataLoggingWithStartTime(struct _RTWLogInfo_tag *li, const double startTime, const double finalTime, const double stepSize, const char **errStatus);
// rt_StopDataLogging
// file ../R2013a/rtw/c/src/rt_logging.h line 264
extern void rt_StopDataLogging(const char *file, struct _RTWLogInfo_tag *li);
// rt_StopDataLoggingForRaccel
// file ../R2013a/rtw/c/src/rt_logging.c line 3938
extern void rt_StopDataLoggingForRaccel(const char *file, struct _RTWLogInfo_tag *li, signed int verbose);
// rt_UpdateDiscreteTaskSampleHits
// file ../R2013a/rtw/c/src/rt_sim.c line 553
extern void rt_UpdateDiscreteTaskSampleHits(struct SimStruct_tag *S);
// rt_UpdateLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 3209
extern void rt_UpdateLogVar(struct LogVar_Tag *var, const void *data, unsigned char isVarDims);
// rt_UpdateLogVarWithDiscontiguousData
// file ../R2013a/rtw/c/src/rt_logging.c line 2439
void rt_UpdateLogVarWithDiscontiguousData(struct LogVar_Tag *var, const signed char * const *data, const signed int *segmentLengths, signed int nSegments);
// rt_UpdateSigLogVars
// file ../R2013a/rtw/c/src/rt_logging.h line 260
extern void rt_UpdateSigLogVars(struct _RTWLogInfo_tag *li, double *tPtr);
// rt_UpdateStructLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 3693
extern void rt_UpdateStructLogVar(struct StructLogVar_Tag *var, const double *t, const void *data);
// rt_UpdateTXYLogVars
// file ../R2013a/rtw/c/src/rt_logging.h line 258
extern const char * rt_UpdateTXYLogVars(struct _RTWLogInfo_tag *li, double *tPtr);
// rt_WriteItemToMatFile
// file ../R2013a/rtw/c/src/rt_logging.c line 1039
static signed int rt_WriteItemToMatFile(struct _IO_FILE *fp, struct MatItem_tag *pItem, enum anonymous$33 itemKind);
// rt_WriteMat5FileHeader
// file ../R2013a/rtw/c/src/rt_logging.c line 1090
static signed int rt_WriteMat5FileHeader(struct _IO_FILE *fp);
// space_dummy_bool
// file ../R2013a/rtw/c/grt/classic_main.c line 30
void space_dummy_bool(void);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strchr
// file /usr/include/string.h line 232
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 140
extern signed int strcmp(const char *, const char *);
// strlen
// file /usr/include/string.h line 395
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 136
extern char * strncat(char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 128
extern char * strncpy(char *, const char *, unsigned long int);

struct anonymous$53
{
  // blockIO
  void *blockIO;
  // constBlockIO
  const void *constBlockIO;
  // defaultParam
  void *defaultParam;
  // prevZCSigState
  unsigned char *prevZCSigState;
  // contStates
  double *contStates;
  // derivs
  double *derivs;
  // zcSignalValues
  void *zcSignalValues;
  // inputs
  void *inputs;
  // outputs
  void *outputs;
  // contStateDisabled
  unsigned char *contStateDisabled;
  // zCCacheNeedsReset
  unsigned char zCCacheNeedsReset;
  // derivCacheNeedsReset
  unsigned char derivCacheNeedsReset;
  // blkStateChange
  unsigned char blkStateChange;
  // dwork
  void *dwork;
};

struct anonymous$55
{
  // mappingInfo
  const void *mappingInfo;
  // xpcData
  void *xpcData;
};

struct anonymous$54
{
  // checksums
  unsigned int checksums[4l];
  // options
  unsigned int options;
  // numContStates
  signed int numContStates;
  // numU
  signed int numU;
  // numY
  signed int numY;
  // numSampTimes
  signed int numSampTimes;
  // numBlocks
  signed int numBlocks;
  // numBlockIO
  signed int numBlockIO;
  // numBlockPrms
  signed int numBlockPrms;
  // numDwork
  signed int numDwork;
  // numSFcnPrms
  signed int numSFcnPrms;
  // numSFcns
  signed int numSFcns;
  // numIports
  signed int numIports;
  // numOports
  signed int numOports;
  // numNonSampZCs
  signed int numNonSampZCs;
  // sysDirFeedThru
  signed int sysDirFeedThru;
  // rtwGenSfcn
  signed int rtwGenSfcn;
};

struct anonymous$19
{
  // DisableBoundsChecking
  unsigned int DisableBoundsChecking : 1;
  // ExtModeUpload
  unsigned int ExtModeUpload : 1;
  // rtwIdMustResolveToSignalObject
  unsigned int rtwIdMustResolveToSignalObject : 2;
  // rtwIdDoneResolve
  unsigned int rtwIdDoneResolve : 1;
  // ensureResetForSizeVary
  unsigned int ensureResetForSizeVary : 1;
  // minMaxCheckpoint
  unsigned int minMaxCheckpoint : 2;
  // optimizeInIR
  unsigned int optimizeInIR : 1;
  // reserved7
  unsigned int reserved7 : 7;
  // reserved16
  unsigned int reserved16 : 16;
};

struct anonymous$18
{
  // alreadyWarned
  unsigned int alreadyWarned : 1;
  // reserved15
  unsigned int reserved15 : 15;
  // reserved16
  unsigned int reserved16 : 16;
};

struct anonymous$2
{
  // hasMdlDimensionsFcn
  unsigned int hasMdlDimensionsFcn : 1;
  // usesNumPorts
  unsigned int usesNumPorts : 1;
  // vectMode
  unsigned int vectMode : 4;
  // blockReduction
  unsigned int blockReduction : 1;
  // treatAsAtomic
  unsigned int treatAsAtomic : 1;
  // rtwcg
  unsigned int rtwcg : 1;
  // needAbsoluteTime
  unsigned int needAbsoluteTime : 1;
  // explicitFCSSCtrl
  unsigned int explicitFCSSCtrl : 1;
  // modelRefTsInhSupLevel
  unsigned int modelRefTsInhSupLevel : 2;
  // needElapseTime
  unsigned int needElapseTime : 1;
  // hasSubFunctions
  unsigned int hasSubFunctions : 1;
  // callsOutputInInit
  unsigned int callsOutputInInit : 1;
  // disableMdlProjection
  unsigned int disableMdlProjection : 1;
  // modelRefNormalModeSupport
  unsigned int modelRefNormalModeSupport : 2;
  // simStateCompliance
  unsigned int simStateCompliance : 4;
  // simStateVisibility
  unsigned int simStateVisibility : 1;
  // disableMdlSlvrJacobian
  unsigned int disableMdlSlvrJacobian : 1;
  // isRapidAcceleratorActive
  unsigned int isRapidAcceleratorActive : 1;
  // isConcurrentTasks
  unsigned int isConcurrentTasks : 1;
  // usesCustomCodeFcns
  unsigned int usesCustomCodeFcns : 1;
  // reserved
  unsigned int reserved : 4;
};

struct anonymous$24
{
  // optimOpts
  unsigned int optimOpts : 2;
  // frameData
  unsigned int frameData : 2;
  // cToMergeBlk
  unsigned int cToMergeBlk : 1;
  // constOutputExprInRTW
  unsigned int constOutputExprInRTW : 1;
  // outputExprInRTW
  unsigned int outputExprInRTW : 1;
  // trivialOutputExprInRTW
  unsigned int trivialOutputExprInRTW : 1;
  // okToMerge
  unsigned int okToMerge : 2;
  // cecId
  unsigned int cecId : 2;
  // nonContPort
  unsigned int nonContPort : 1;
  // dimensionsMode
  unsigned int dimensionsMode : 2;
  // fedByBlockWithModesNoZCs
  unsigned int fedByBlockWithModesNoZCs : 1;
  // busMode
  unsigned int busMode : 2;
  // optimizeInIR
  unsigned int optimizeInIR : 1;
  // reserved13
  unsigned int reserved13 : 13;
};

struct anonymous$22
{
  // overWritable
  unsigned int overWritable : 1;
  // optimOpts
  unsigned int optimOpts : 2;
  // frameData
  unsigned int frameData : 2;
  // contiguity
  unsigned int contiguity : 1;
  // acceptExprInRTW
  unsigned int acceptExprInRTW : 1;
  // cinId
  unsigned int cinId : 2;
  // nonDerivPort
  unsigned int nonDerivPort : 1;
  // dimensionsMode
  unsigned int dimensionsMode : 2;
  // busMode
  unsigned int busMode : 2;
  // optimizeInIR
  unsigned int optimizeInIR : 1;
  // reserved1
  unsigned int reserved1 : 1;
  // reserved16
  unsigned int reserved16 : 16;
};

struct anonymous$47
{
  // zcCacheNeedsReset
  unsigned int zcCacheNeedsReset : 1;
  // derivCacheNeedsReset
  unsigned int derivCacheNeedsReset : 1;
  // blkStateChange
  unsigned int blkStateChange : 1;
  // reserved_1
  unsigned int reserved_1 : 1;
  // forceSfcnExceptionHandling
  unsigned int forceSfcnExceptionHandling : 1;
  // inlineParameters
  unsigned int inlineParameters : 1;
  // solverAssertCheck
  unsigned int solverAssertCheck : 1;
  // minStepViolatedError
  unsigned int minStepViolatedError : 1;
  // reservedone
  unsigned int reservedone : 1;
  // noZCStateUpdate
  unsigned int noZCStateUpdate : 1;
  // computingJacobian
  unsigned int computingJacobian : 1;
  // solverCheckingCIC
  unsigned int solverCheckingCIC : 1;
  // errorStatusIsMsg
  unsigned int errorStatusIsMsg : 1;
  // timeTweakWarn
  unsigned int timeTweakWarn : 1;
  // solverRequestingReset
  unsigned int solverRequestingReset : 1;
  // firstInitCondCalled
  unsigned int firstInitCondCalled : 1;
  // sparseSlvrJacobian
  unsigned int sparseSlvrJacobian : 1;
  // frameUpgradeWarn
  unsigned int frameUpgradeWarn : 1;
  // outputMethodComputed
  unsigned int outputMethodComputed : 1;
  // reserved15
  unsigned int reserved15 : 13;
};

struct anonymous$38
{
  // re
  float re;
  // im
  float im;
};

struct anonymous$39
{
  // re
  double re;
  // im
  double im;
};

struct anonymous$56
{
  // stepSize
  double stepSize;
  // clockTick0
  unsigned int clockTick0;
  // clockTickH0
  unsigned int clockTickH0;
  // stepSize0
  double stepSize0;
  // tStart
  double tStart;
  // tFinal
  double tFinal;
  // timeOfLastOutput
  double timeOfLastOutput;
  // timingData
  void *timingData;
  // varNextHitTimesList
  double *varNextHitTimesList;
  // simTimeStep
  enum anonymous$34 simTimeStep;
  // stopRequestedFlag
  unsigned char stopRequestedFlag;
  // sampleTimes
  double *sampleTimes;
  // offsetTimes
  double *offsetTimes;
  // sampleTimeTaskIDPtr
  signed int *sampleTimeTaskIDPtr;
  // sampleHits
  signed int *sampleHits;
  // perTaskSampleHits
  signed int *perTaskSampleHits;
  // t
  double *t;
  // sampleTimesArray
  double sampleTimesArray[1l];
  // offsetTimesArray
  double offsetTimesArray[1l];
  // sampleTimeTaskIDArray
  signed int sampleTimeTaskIDArray[1l];
  // sampleHitArray
  signed int sampleHitArray[1l];
  // perTaskSampleHitsArray
  signed int perTaskSampleHitsArray[1l];
  // tArray
  double tArray[1l];
};

struct anonymous$10
{
  // sfEvent
  signed int sfEvent;
  // OrbitalState_Position
  signed char OrbitalState_Position;
  // OrbitalState_Velocity
  signed char OrbitalState_Velocity;
  // OrbitalState_Attitude
  signed char OrbitalState_Attitude;
  // OrbitalState_Time
  signed char OrbitalState_Time;
  // InertialNavigation_AbsolutePosi
  signed char InertialNavigation_AbsolutePosi;
  // InertialNavigation_AbsoluteAtti
  signed char InertialNavigation_AbsoluteAtti;
  // InertialNavigation_AbsoluteVelo
  signed char InertialNavigation_AbsoluteVelo;
  // GPS_AbsoluteVelocity
  signed char GPS_AbsoluteVelocity;
  // GPS_AbsoluteTime
  signed char GPS_AbsoluteTime;
  // StarPlanetTracker_AbsoluteAttit
  signed char StarPlanetTracker_AbsoluteAttit;
  // StarPlanetTracker_AbsolutePosit
  signed char StarPlanetTracker_AbsolutePosit;
  // StarPlanetTracker_AbsoluteTime
  signed char StarPlanetTracker_AbsoluteTime;
  // StarPlanetTracker_AbsoluteVeloc
  signed char StarPlanetTracker_AbsoluteVeloc;
  // GPS_AbsolutePosition
  signed char GPS_AbsolutePosition;
  // dockingSensor_RelativePosition
  signed char dockingSensor_RelativePosition;
  // dockingSensor_RelativeVelocity
  signed char dockingSensor_RelativeVelocity;
  // dockingSensor_RelativeAttitude
  signed char dockingSensor_RelativeAttitude;
  // dockingSensor_targetState
  signed char dockingSensor_targetState;
  // thrust_status
  signed char thrust_status;
  // fuel_status
  signed char fuel_status;
  // DockingApproach_timer
  signed char DockingApproach_timer;
  // CaptureApproach_timer
  signed char CaptureApproach_timer;
  // latch_status
  signed char latch_status;
  // LatchCapture_timer
  signed char LatchCapture_timer;
  // dockingSensor_timer
  signed char dockingSensor_timer;
  // InertialNavigation_timer
  signed char InertialNavigation_timer;
  // StarPlanetTracker_timer
  signed char StarPlanetTracker_timer;
  // GPS_timer
  signed char GPS_timer;
  // is_active_c1_DockingApproachExa
  unsigned char is_active_c1_DockingApproachExa;
  // is_active_fuel
  unsigned char is_active_fuel;
  // is_active_thrust
  unsigned char is_active_thrust;
  // is_MissionPhaseStates
  unsigned char is_MissionPhaseStates;
  // is_active_MissionPhaseStates
  unsigned char is_active_MissionPhaseStates;
  // is_DockingApproach
  unsigned char is_DockingApproach;
  // is_active_DockingApproach
  unsigned char is_active_DockingApproach;
  // is_dockingSensor
  unsigned char is_dockingSensor;
  // is_active_dockingSensor
  unsigned char is_active_dockingSensor;
  // is_CaptureApproach
  unsigned char is_CaptureApproach;
  // is_active_CaptureApproach
  unsigned char is_active_CaptureApproach;
  // is_active_OrbitalState_Active
  unsigned char is_active_OrbitalState_Active;
  // is_active_OrbitalState_Complex
  unsigned char is_active_OrbitalState_Complex;
  // is_OrbitalState
  unsigned char is_OrbitalState;
  // is_active_OrbitalState
  unsigned char is_active_OrbitalState;
  // is_OrbitalState2
  unsigned char is_OrbitalState2;
  // is_active_OrbitalState2
  unsigned char is_active_OrbitalState2;
  // is_GPS
  unsigned char is_GPS;
  // is_active_GPS
  unsigned char is_active_GPS;
  // is_StarPlanetTracker
  unsigned char is_StarPlanetTracker;
  // is_active_StarPlanetTracker
  unsigned char is_active_StarPlanetTracker;
  // is_InertialNavigation
  unsigned char is_InertialNavigation;
  // is_active_InertialNavigation
  unsigned char is_active_InertialNavigation;
  // is_LatchCaptureCheck
  unsigned char is_LatchCaptureCheck;
  // is_active_LatchCaptureCheck
  unsigned char is_active_LatchCaptureCheck;
  // is_latch
  unsigned char is_latch;
  // is_active_latch
  unsigned char is_active_latch;
  // VALID
  unsigned char VALID;
};

struct anonymous$48
{
  // sizeInBytes
  signed int sizeInBytes;
  // pCurrVal
  char *pCurrVal;
  // pPrevVal
  char *pPrevVal;
};

struct anonymous$20
{
  // stopExecutionFlag
  signed int stopExecutionFlag;
  // isrOverrun
  signed int isrOverrun;
  // overrunFlags
  signed int overrunFlags[10l];
  // eventFlags
  signed int eventFlags[10l];
  // errmsg
  const char *errmsg;
};

struct anonymous$11
{
  // GroundTrack_OrbitalPosition
  signed char GroundTrack_OrbitalPosition;
  // GroundTrack_OrbitalVelocity
  signed char GroundTrack_OrbitalVelocity;
  // dockVisibility_status
  signed char dockVisibility_status;
  // opticsAvailability_status
  unsigned char opticsAvailability_status;
  // sunlight_status
  unsigned char sunlight_status;
  // GPS_satelliteVisibility_status
  signed char GPS_satelliteVisibility_status;
  // GPS_receiverAvailability_status
  unsigned char GPS_receiverAvailability_status;
  // StarPlanetTracker_planetVisibil
  signed char StarPlanetTracker_planetVisibil;
  // StarPlanetTracker_starVisibilit
  signed char StarPlanetTracker_starVisibilit;
  // InertialNavigation_time
  unsigned char InertialNavigation_time;
  // GroundTrack_Time
  signed char GroundTrack_Time;
  // RealTimeClock_time
  signed char RealTimeClock_time;
  // StageTransition
  signed char StageTransition;
};

struct anonymous$58
{
  // wordH
  unsigned int wordH;
  // wordL
  unsigned int wordL;
};

struct anonymous$59
{
  // words
  struct anonymous$58 words;
};

struct anonymous$60
{
  // wordL
  unsigned int wordL;
  // wordH
  unsigned int wordH;
};

struct anonymous$61
{
  // words
  struct anonymous$60 words;
};

union anonymous
{
  // wordLreal
  float wordLreal;
  // wordLuint
  unsigned int wordLuint;
};

struct anonymous$28
{
  // wordL
  union anonymous wordL;
};

union anonymous$6
{
  // mdlSetInputPortWidth
  void (*mdlSetInputPortWidth)(struct SimStruct_tag *, signed int, signed int);
  // mdlSetInputPortDims
  void (*mdlSetInputPortDims)(struct SimStruct_tag *, signed int, const struct DimsInfo_tag *);
};

union anonymous$7
{
  // mdlSetOutputPortWidth
  void (*mdlSetOutputPortWidth)(struct SimStruct_tag *, signed int, signed int);
  // mdlSetOutputPortDims
  void (*mdlSetOutputPortDims)(struct SimStruct_tag *, signed int, const struct DimsInfo_tag *);
};

union anonymous$8
{
  // level2
  void (*level2)(struct SimStruct_tag *);
  // level1
  void (*level1)(double *, struct SimStruct_tag *);
};

union anonymous$9
{
  // level2
  void (*level2)(struct SimStruct_tag *, signed int);
  // level1
  void (*level1)(double *, const double *, const double *, struct SimStruct_tag *, signed int);
};

union anonymous$12
{
  // level2
  void (*level2)(struct SimStruct_tag *, signed int);
  // level1
  void (*level1)(double *, const double *, struct SimStruct_tag *, signed int);
};

union anonymous$14
{
  // level2
  void (*level2)(struct SimStruct_tag *);
  // level1
  void (*level1)(double *, const double *, const double *, struct SimStruct_tag *, signed int);
};

union anonymous$15
{
  // mdlSetInputPortComplexSignal
  void (*mdlSetInputPortComplexSignal)(struct SimStruct_tag *, signed int, signed int);
  // mdlEnable
  void (*mdlEnable)(struct SimStruct_tag *);
};

union anonymous$16
{
  // mdlSetOutputPortComplexSignal
  void (*mdlSetOutputPortComplexSignal)(struct SimStruct_tag *, signed int, signed int);
  // mdlDisable
  void (*mdlDisable)(struct SimStruct_tag *);
};

struct _ssSFcnModelMethods
{
  // mdlInitializeSizes
  void (*mdlInitializeSizes)(struct SimStruct_tag *);
  // mdlGetInputPortWidthLevel1
  signed int (*mdlGetInputPortWidthLevel1)(struct SimStruct_tag *, signed int);
  // mdlGetOutputPortWidthLevel1
  signed int (*mdlGetOutputPortWidthLevel1)(struct SimStruct_tag *, signed int);
  // mdlSetInputPortDimensions
  union anonymous$6 mdlSetInputPortDimensions;
  // mdlSetOutputPortDimensions
  union anonymous$7 mdlSetOutputPortDimensions;
  // mdlSetInputPortDataType
  void (*mdlSetInputPortDataType)(struct SimStruct_tag *, signed int, signed int);
  // mdlSetOutputPortDataType
  void (*mdlSetOutputPortDataType)(struct SimStruct_tag *, signed int, signed int);
  // mdlInitializeSampleTimes
  void (*mdlInitializeSampleTimes)(struct SimStruct_tag *);
  // mdlSetInputPortSampleTime
  void (*mdlSetInputPortSampleTime)(struct SimStruct_tag *, signed int, double, double);
  // mdlSetOutputPortSampleTime
  void (*mdlSetOutputPortSampleTime)(struct SimStruct_tag *, signed int, double, double);
  // mdlSetWorkWidths
  void (*mdlSetWorkWidths)(struct SimStruct_tag *);
  // mdlRTW
  void (*mdlRTW)(struct SimStruct_tag *);
  // mdlInitializeConditions
  union anonymous$8 mdlInitializeConditions;
  // mdlStart
  void (*mdlStart)(struct SimStruct_tag *);
  // mdlCheckParameters
  void (*mdlCheckParameters)(struct SimStruct_tag *);
  // mdlProcessParameters
  void (*mdlProcessParameters)(struct SimStruct_tag *);
  // mdlGetTimeOfNextVarHit
  void (*mdlGetTimeOfNextVarHit)(struct SimStruct_tag *);
  // mdlOutputs
  union anonymous$9 mdlOutputs;
  // mdlUpdate
  union anonymous$12 mdlUpdate;
  // mdlDerivatives
  union anonymous$14 mdlDerivatives;
  // mdlZeroCrossings
  void (*mdlZeroCrossings)(struct SimStruct_tag *);
  // mdlTerminate
  void (*mdlTerminate)(struct SimStruct_tag *);
  // fcnInEnable
  union anonymous$15 fcnInEnable;
  // fcnOutDisable
  union anonymous$16 fcnOutDisable;
};

struct anonymous$4
{
  // sFcn
  struct _ssSFcnModelMethods sFcn;
};

struct anonymous$13
{
  // CaptureApproachComplete
  unsigned char CaptureApproachComplete;
  // DockingApproachComplete
  unsigned char DockingApproachComplete;
  // AttemptingToDock
  unsigned char AttemptingToDock;
  // LatchCaptureComplete
  unsigned char LatchCaptureComplete;
  // DockingApproach
  unsigned char DockingApproach;
  // ApproachOrbitComplete
  unsigned char ApproachOrbitComplete;
  // FarApproachComplete
  unsigned char FarApproachComplete;
  // ProximityOperationsComplete
  unsigned char ProximityOperationsComplete;
  // FailedApproach
  unsigned char FailedApproach;
  // JointMission
  unsigned char JointMission;
  // CaptureApproachFailed
  unsigned char CaptureApproachFailed;
};

union anonymous$5
{
  // cptr
  const char **cptr;
  // ptr
  char **ptr;
};

union anonymous$31
{
  // sfcn
  struct _ssDWorkRecord *sfcn;
  // root
  void *root;
};

union anonymous$17
{
  // vect
  void *vect;
  // uPtrs
  const double * const *uPtrs;
};

union anonymous$23
{
  // cptr
  const signed char * const *cptr;
  // ptr
  signed char **ptr;
};

union anonymous$3
{
  // str
  const char *str;
  // msg
  void *msg;
};

union anonymous$37
{
  // cptr
  const struct RTWLogSignalInfo_tag *cptr;
  // ptr
  struct RTWLogSignalInfo_tag *ptr;
};

union anonymous$21
{
  // vect
  const void *vect;
  // ptrs
  const void * const *ptrs;
};

union anonymous$1
{
  // numInputPorts
  signed int numInputPorts;
  // numU
  signed int numU;
};

union anonymous$0
{
  // numOutputPorts
  signed int numOutputPorts;
  // numY
  signed int numY;
};

union anonymous$29
{
  // numRtp
  signed int numRtp;
  // placeholder
  void *placeholder;
};

struct DimsInfo_tag
{
  // width
  signed int width;
  // numDims
  signed int numDims;
  // dims
  signed int *dims;
  // nextSigDims
  struct DimsInfo_tag *nextSigDims;
};

struct LogInfo_Tag
{
  // t
  struct LogVar_Tag *t;
  // x
  void *x;
  // sl
  void *sl;
  // ny
  signed int ny;
  // y
  void **y;
  // xFinal
  void *xFinal;
  // logVarsList
  struct LogVar_Tag *logVarsList;
  // structLogVarsList
  struct StructLogVar_Tag *structLogVarsList;
  // haveLogVars
  unsigned char haveLogVars;
};

struct RTWLogDataTypeConvert_tag
{
  // conversionNeeded
  signed int conversionNeeded;
  // dataTypeIdLoggingTo
  enum anonymous$35 dataTypeIdLoggingTo;
  // dataTypeIdOriginal
  signed int dataTypeIdOriginal;
  // bitsPerChunk
  signed int bitsPerChunk;
  // numOfChunk
  signed int numOfChunk;
  // isSigned
  unsigned int isSigned;
  // fracSlope
  double fracSlope;
  // fixedExp
  signed int fixedExp;
  // bias
  double bias;
};

struct MatrixData_Tag
{
  // name
  char name[64l];
  // nRows
  signed int nRows;
  // nCols
  signed int nCols;
  // nDims
  signed int nDims;
  // _dims
  signed int _dims[2l];
  // dims
  signed int *dims;
  // re
  void *re;
  // im
  void *im;
  // dTypeID
  signed int dTypeID;
  // elSize
  unsigned long int elSize;
  // dataTypeConvertInfo
  struct RTWLogDataTypeConvert_tag dataTypeConvertInfo;
  // mxID
  enum anonymous$32 mxID;
  // logical
  unsigned int logical;
  // complex
  unsigned int complex;
  // frameData
  unsigned int frameData;
  // frameSize
  unsigned int frameSize;
};

struct LogVar_Tag
{
  // data
  struct MatrixData_Tag data;
  // valDims
  struct ValDimsData_Tag *valDims;
  // rowIdx
  signed int rowIdx;
  // wrapped
  signed int wrapped;
  // nDataPoints
  signed int nDataPoints;
  // usingDefaultBufSize
  signed int usingDefaultBufSize;
  // okayToRealloc
  signed int okayToRealloc;
  // decimation
  signed int decimation;
  // numHits
  signed int numHits;
  // coords
  signed int *coords;
  // strides
  signed int *strides;
  // currStrides
  signed int *currStrides;
  // next
  struct LogVar_Tag *next;
};

struct MatItem_tag
{
  // type
  signed int type;
  // nbytes
  unsigned int nbytes;
  // data
  const void *data;
};

struct RTWLogSignalInfo_tag
{
  // numSignals
  signed int numSignals;
  // numCols
  signed int *numCols;
  // numDims
  signed int *numDims;
  // dims
  signed int *dims;
  // isVarDims
  unsigned char *isVarDims;
  // currSigDims
  void **currSigDims;
  // currSigDimsSize
  signed int *currSigDimsSize;
  // dataTypes
  enum anonymous$35 *dataTypes;
  // complexSignals
  signed int *complexSignals;
  // frameData
  signed int *frameData;
  // labels
  union anonymous$5 labels;
  // titles
  char *titles;
  // titleLengths
  signed int *titleLengths;
  // plotStyles
  signed int *plotStyles;
  // blockNames
  union anonymous$5 blockNames;
  // stateNames
  union anonymous$5 stateNames;
  // crossMdlRef
  unsigned char *crossMdlRef;
  // dataTypeConvert
  struct RTWLogDataTypeConvert_tag *dataTypeConvert;
};

struct SignalsStruct_Tag
{
  // numActiveFields
  signed int numActiveFields;
  // fieldNames
  const char *fieldNames;
  // numSignals
  signed int numSignals;
  // values
  struct LogVar_Tag *values;
  // dimensions
  struct MatrixData_Tag *dimensions;
  // labels
  struct MatrixData_Tag *labels;
  // plotStyles
  struct MatrixData_Tag *plotStyles;
  // titles
  struct MatrixData_Tag *titles;
  // blockNames
  struct MatrixData_Tag *blockNames;
  // stateNames
  struct MatrixData_Tag *stateNames;
  // crossMdlRef
  struct MatrixData_Tag *crossMdlRef;
  // logValueDimensions
  unsigned char logValueDimensions;
  // isVarDims
  unsigned char *isVarDims;
};

struct _ssSizes
{
  // numContStates
  signed int numContStates;
  // numDiscStates
  signed int numDiscStates;
  // out
  union anonymous$0 out;
  // in
  union anonymous$1 in;
  // mexApiInt1
  signed int mexApiInt1;
  // sysDirFeedThrough
  signed int sysDirFeedThrough;
  // numSampleTimes
  signed int numSampleTimes;
  // numSFcnParams
  signed int numSFcnParams;
  // numIWork
  signed int numIWork;
  // numRWork
  signed int numRWork;
  // numPWork
  signed int numPWork;
  // numBlocks
  signed int numBlocks;
  // numSFunctions
  signed int numSFunctions;
  // numBlockIO
  signed int numBlockIO;
  // numBlockParams
  signed int numBlockParams;
  // checksums
  unsigned int checksums[4l];
  // simStructVer
  signed int simStructVer;
  // numNonsampledZCs
  signed int numNonsampledZCs;
  // numZCEvents
  signed int numZCEvents;
  // numModes
  signed int numModes;
  // options
  unsigned int options;
  // sizeofY
  signed int sizeofY;
  // sizeofU
  signed int sizeofU;
  // sizeofBlockIO
  signed int sizeofBlockIO;
  // sizeofGlobalBlockIO
  signed int sizeofGlobalBlockIO;
  // numDWork
  signed int numDWork;
  // sizeofDWork
  signed int sizeofDWork;
  // RTWGeneratedSFcn
  signed int RTWGeneratedSFcn;
  // flags
  struct anonymous$2 flags;
  // numJacobianNzMax
  signed int numJacobianNzMax;
  // rtModel
  void *rtModel;
  // constBlockIO
  const void *constBlockIO;
  // reservedForFuture
  signed int reservedForFuture[1l];
};

struct _ssPortInfo
{
  // regNumInputPortsFcn
  signed int (*regNumInputPortsFcn)(void *, signed int);
  // regNumInputPortsFcnArg
  void *regNumInputPortsFcnArg;
  // regNumOutputPortsFcn
  signed int (*regNumOutputPortsFcn)(void *, signed int);
  // regNumOutputPortsFcnArg
  void *regNumOutputPortsFcnArg;
  // inputs
  struct _ssPortInputs *inputs;
  // outputs
  struct _ssPortOutputs *outputs;
};

struct _ssSFcnParams
{
  // dlgNum
  signed int dlgNum;
  // dlgParams
  double **dlgParams;
  // dlgAttribs
  unsigned int *dlgAttribs;
  // numRtp
  union anonymous$29 numRtp;
  // rtp
  struct ssParamRec_tag **rtp;
};

struct _ssStates
{
  // U
  union anonymous$17 U;
  // Y
  void *Y;
  // contStates
  double *contStates;
  // discStates
  double *discStates;
  // flags
  struct anonymous$18 flags;
  // reserved2
  signed int reserved2;
  // dX
  double *dX;
  // contStateDisabled
  unsigned char *contStateDisabled;
  // statesInfo2
  struct _ssStatesInfo2 *statesInfo2;
  // nonsampledZCs
  double *nonsampledZCs;
  // nonsampledZCDirs
  enum anonymous$41 *nonsampledZCDirs;
  // jacobian
  struct SparseHeader_Tag *jacobian;
  // modelMethods2
  struct _ssSFcnModelMethods2 *modelMethods2;
  // reservedSize
  signed int reservedSize;
};

struct _ssWork
{
  // iWork
  signed int *iWork;
  // rWork
  double *rWork;
  // pWork
  void **pWork;
  // modeVector
  signed int *modeVector;
  // userData
  void *userData;
  // dWork
  union anonymous$31 dWork;
  // dWorkAux
  struct _ssDWorkAuxRecord *dWorkAux;
  // reservedForFuture
  void *reservedForFuture[1l];
};

struct _ssBlkInfo
{
  // inputConnected
  signed int inputConnected;
  // outputConnected
  signed int outputConnected;
  // placementGroup
  const char *placementGroup;
  // block
  void *block;
  // blkInfo2
  struct _ssBlkInfo2 *blkInfo2;
  // absTolOffset_Obsolete
  signed int absTolOffset_Obsolete;
  // reservedForFutureInt
  signed int reservedForFutureInt;
};

struct _ssCallSys
{
  // outputs
  signed int *outputs;
  // args1
  void **args1;
  // args2
  signed int *args2;
  // fcns
  signed int (**fcns)(void *, signed int, signed int);
};

struct _ssRegDataType
{
  // arg1
  void *arg1;
  // registerFcn
  signed int (*registerFcn)(void *, const char *);
  // setSizeFcn
  signed int (*setSizeFcn)(void *, signed int, signed int);
  // getSizeFcn
  signed int (*getSizeFcn)(void *, signed int);
  // setZeroFcn
  signed int (*setZeroFcn)(void *, signed int, void *);
  // getZeroFcn
  const void * (*getZeroFcn)(void *, signed int);
  // getNameFcn
  const char * (*getNameFcn)(void *, signed int);
  // getIdFcn
  signed int (*getIdFcn)(void *, const char *);
  // setNumDWorkFcn
  signed int (*setNumDWorkFcn)(struct SimStruct_tag *, signed int);
};

struct _ssStInfo
{
  // sampleTimes
  double *sampleTimes;
  // offsetTimes
  double *offsetTimes;
  // tNext
  double tNext;
  // tNextTid
  signed int tNextTid;
  // sampleTimeTaskIDs
  signed int *sampleTimeTaskIDs;
};

struct SimStruct_tag
{
  // modelName
  const char *modelName;
  // path
  const char *path;
  // parent
  struct SimStruct_tag *parent;
  // root
  struct SimStruct_tag *root;
  // errorStatus
  union anonymous$3 errorStatus;
  // sizes
  struct _ssSizes sizes;
  // portInfo
  struct _ssPortInfo portInfo;
  // sfcnParams
  struct _ssSFcnParams sfcnParams;
  // states
  struct _ssStates states;
  // work
  struct _ssWork work;
  // blkInfo
  struct _ssBlkInfo blkInfo;
  // mdlInfo
  struct _ssMdlInfo *mdlInfo;
  // callSys
  struct _ssCallSys callSys;
  // regDataType
  struct _ssRegDataType regDataType;
  // stInfo
  struct _ssStInfo stInfo;
  // modelMethods
  struct anonymous$4 modelMethods;
  // sFunctions
  struct SimStruct_tag **sFunctions;
};

struct SparseHeader_Tag
{
  // mRows
  signed int mRows;
  // nCols
  signed int nCols;
  // nzMax
  signed int nzMax;
  // Ir
  signed int *Ir;
  // Jc
  signed int *Jc;
  // Pr
  double *Pr;
};

struct StructLogVar_Tag
{
  // name
  char name[64l];
  // numActiveFields
  signed int numActiveFields;
  // logTime
  unsigned char logTime;
  // time
  void *time;
  // signals
  struct SignalsStruct_Tag signals;
  // blockName
  struct MatrixData_Tag *blockName;
  // next
  struct StructLogVar_Tag *next;
};

struct TimingData_Tag
{
  // period
  double period[10l];
  // offset
  double offset[10l];
  // clockTick
  double clockTick[10l];
  // taskTick
  signed int taskTick[10l];
  // nTaskTicks
  signed int nTaskTicks[10l];
  // firstDiscIdx
  signed int firstDiscIdx;
};

struct ValDimsData_Tag
{
  // name
  char name[64l];
  // nRows
  signed int nRows;
  // nCols
  signed int nCols;
  // currSigDims
  void **currSigDims;
  // currSigDimsSize
  signed int *currSigDimsSize;
  // dimsData
  double *dimsData;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _RTWExtModeInfo_tag
{
  // subSysActiveVectorAddr
  void *subSysActiveVectorAddr;
  // checksumsPtr
  unsigned int *checksumsPtr;
  // mdlMappingInfoPtr
  const void **mdlMappingInfoPtr;
  // tPtr
  void *tPtr;
  // tFinalTicks
  signed int tFinalTicks;
};

struct _RTWLogInfo_tag
{
  // logInfo
  void *logInfo;
  // logXSignalPtrs
  union anonymous$23 logXSignalPtrs;
  // logYSignalPtrs
  union anonymous$23 logYSignalPtrs;
  // sigLogSignalPtrs
  union anonymous$23 sigLogSignalPtrs;
  // logFormat
  signed int logFormat;
  // logMaxRows
  signed int logMaxRows;
  // logDecimation
  signed int logDecimation;
  // logVarNameModifier
  const char *logVarNameModifier;
  // logT
  const char *logT;
  // logX
  const char *logX;
  // logXFinal
  const char *logXFinal;
  // logY
  const char *logY;
  // logSL
  const char *logSL;
  // logXSignalInfo
  union anonymous$37 logXSignalInfo;
  // logYSignalInfo
  union anonymous$37 logYSignalInfo;
  // sigLogSignalInfo
  union anonymous$37 sigLogSignalInfo;
  // mdlLogData
  void (*mdlLogData)(void *, void *);
  // mmi
  const void *mmi;
};

struct _RTWRTModelMethodsInfo_tag
{
  // rtModelPtr
  void *rtModelPtr;
  // rtmInitSizesFcn
  void (*rtmInitSizesFcn)(void *);
  // rtmInitSampTimesFcn
  void (*rtmInitSampTimesFcn)(void *);
  // rtmStartFcn
  void (*rtmStartFcn)(void *);
  // rtmOutputsFcn
  void (*rtmOutputsFcn)(void *, signed int);
  // rtmUpdateFcn
  void (*rtmUpdateFcn)(void *, signed int);
  // rtmDervisFcn
  void (*rtmDervisFcn)(void *);
  // rtmProjectionFcn
  void (*rtmProjectionFcn)(void *);
  // rtmMassMatrixFcn
  void (*rtmMassMatrixFcn)(void *);
  // rtmForcingFunctionFcn
  void (*rtmForcingFunctionFcn)(void *);
  // rtmTerminateFcn
  void (*rtmTerminateFcn)(void *);
};

struct _rtTimingBridge_tag
{
  // nTasks
  unsigned int nTasks;
  // clockTick
  unsigned int **clockTick;
  // clockTickH
  unsigned int **clockTickH;
  // taskCounter
  unsigned int *taskCounter;
  // taskTime
  double **taskTime;
  // rateTransition
  unsigned char **rateTransition;
  // firstInitCond
  unsigned char *firstInitCond;
};

struct _ssBlkInfo2
{
  // rtwSfcnInfo
  void *rtwSfcnInfo;
  // unused
  void *unused;
  // portInfo2
  struct _ssPortInfo2 *portInfo2;
  // reservedPtrs
  void *reservedPtrs[14l];
  // reserved
  signed int reserved[16l];
};

struct _ssConstraintsInfo
{
  // numConstraints
  signed int numConstraints;
  // constraints
  double *constraints;
  // mdlConstraints
  void (*mdlConstraints)(struct SimStruct_tag *);
};

struct _ssDWorkAuxRecord
{
  // rtwIdentifier
  char *rtwIdentifier;
  // rtwStorageClass
  signed int rtwStorageClass;
  // rtwTypeQualifier
  char *rtwTypeQualifier;
  // flags
  struct anonymous$19 flags;
  // icPrmIdxPlus1
  signed int icPrmIdxPlus1;
  // bitFieldWidth
  signed int bitFieldWidth;
  // unusedInts
  signed int unusedInts[2l];
  // resolvedSignalObject
  void *resolvedSignalObject;
  // unusedPtrs
  void *unusedPtrs[3l];
};

struct _ssDWorkRecord
{
  // width
  signed int width;
  // dataTypeId
  signed int dataTypeId;
  // complexSignal
  signed int complexSignal;
  // array
  void *array;
  // name
  const char *name;
  // usedAs
  enum anonymous$45 usedAs;
};

struct _ssInPortVarDims
{
  // portVarDims
  const signed int *portVarDims;
  // reserved
  void *reserved[8l];
};

struct ssSparseMatrixInfo_tag
{
  // mRows
  signed int mRows;
  // nCols
  signed int nCols;
  // nzMax
  signed int nzMax;
  // Ir
  signed int *Ir;
  // Jc
  signed int *Jc;
  // Pr
  double *Pr;
};

struct _ssMassMatrixInfo
{
  // type
  enum anonymous$42 type;
  // info
  struct ssSparseMatrixInfo_tag info;
};

struct _ssMdlInfo
{
  // simMode
  enum anonymous$52 simMode;
  // t
  double *t;
  // sampleHits
  signed int *sampleHits;
  // tStart
  double tStart;
  // tFinal
  double tFinal;
  // timeOfLastOutput
  double timeOfLastOutput;
  // minStepSize
  double minStepSize;
  // timingData
  void *timingData;
  // simTimeStep
  enum anonymous$34 simTimeStep;
  // stopRequested
  signed int stopRequested;
  // logOutput
  signed int logOutput;
  // outputTimes
  double *outputTimes;
  // outputTimesIndex
  unsigned int outputTimesIndex;
  // numOutputTimes
  unsigned int numOutputTimes;
  // outputTimesOnly
  signed int outputTimesOnly;
  // obsoletedNeedOutputAtTPlusTol
  signed int obsoletedNeedOutputAtTPlusTol;
  // solverName
  const char *solverName;
  // variableStepSolver
  signed int variableStepSolver;
  // solverData
  void *solverData;
  // solverStopTime
  double solverStopTime;
  // stepSize
  double stepSize;
  // solverNeedsReset
  signed int solverNeedsReset;
  // mdlFlags
  struct anonymous$47 mdlFlags;
  // maxNumMinSteps
  signed int maxNumMinSteps;
  // solverRefineFactor
  signed int solverRefineFactor;
  // solverRelTol
  double solverRelTol;
  // solverAbsTol_Obsolete
  double *solverAbsTol_Obsolete;
  // maxStepSize
  double maxStepSize;
  // solverMaxOrder
  signed int solverMaxOrder;
  // fixedStepSize
  double fixedStepSize;
  // numNonContDerivSigInfos
  signed int numNonContDerivSigInfos;
  // nonContDerivSigInfos
  struct anonymous$48 *nonContDerivSigInfos;
  // solverAbsTolControl_Obsolete
  unsigned char *solverAbsTolControl_Obsolete;
  // timingBridge
  struct _rtTimingBridge_tag *timingBridge;
  // rtwLogInfo
  struct _RTWLogInfo_tag *rtwLogInfo;
  // solverInfo
  struct _ssSolverInfo_tag *solverInfo;
  // unused
  void *unused[2l];
  // mexApiVoidPtr1
  void *mexApiVoidPtr1;
  // solverExtrapolationOrder
  signed int solverExtrapolationOrder;
  // solverNumberNewtonIterations
  signed int solverNumberNewtonIterations;
  // extModeInfo
  struct _RTWExtModeInfo_tag *extModeInfo;
  // blockIO
  void *blockIO;
  // blockIOVarDims
  signed int *blockIOVarDims;
  // defaultParam
  double *defaultParam;
  // mappingInfo
  const void *mappingInfo;
  // mexApiInt2
  signed int mexApiInt2;
  // reservedString
  char reservedString[32l];
  // regInputPortDimsInfo
  signed int (*regInputPortDimsInfo)(struct SimStruct_tag *, signed int, const struct DimsInfo_tag *);
  // regOutputPortDimsInfo
  signed int (*regOutputPortDimsInfo)(struct SimStruct_tag *, signed int, const struct DimsInfo_tag *);
  // reservedForXPC
  void *reservedForXPC;
  // solverMode
  enum anonymous$43 solverMode;
  // rtwgenMode
  enum anonymous$40 rtwgenMode;
  // reservedForFutureInt
  signed int reservedForFutureInt[2l];
  // mexApiReal1
  double mexApiReal1;
  // mexApiReal2
  double mexApiReal2;
  // timeOfNextSampleHit
  double *timeOfNextSampleHit;
  // varNextHitTimesList
  double *varNextHitTimesList;
  // tNextWasAdjusted
  unsigned char *tNextWasAdjusted;
  // reservedDoubleVect
  double *reservedDoubleVect[1l];
};

struct _ssOutPortVarDims
{
  // portVarDims
  signed int *portVarDims;
  // reserved
  void *reserved[8l];
};

struct _ssPortInfo2
{
  // inputs
  struct _ssInPortVarDims *inputs;
  // outputs
  struct _ssOutPortVarDims *outputs;
  // reserved
  void *reserved[8l];
};

struct _ssPortInputs
{
  // width
  signed int width;
  // directFeedThrough
  signed int directFeedThrough;
  // dataTypeId
  signed int dataTypeId;
  // complexSignal
  signed int complexSignal;
  // signal
  union anonymous$21 signal;
  // connected
  signed int connected;
  // attributes
  struct anonymous$22 attributes;
  // sampleTime
  double sampleTime;
  // offsetTime
  double offsetTime;
  // dims
  signed int *dims;
  // bufferDstPort
  signed int bufferDstPort;
  // sampleTimeIndex
  signed int sampleTimeIndex;
  // numDims
  signed int numDims;
};

struct _ssPortOutputs
{
  // width
  signed int width;
  // dataTypeId
  signed int dataTypeId;
  // complexSignal
  signed int complexSignal;
  // signalVect
  void *signalVect;
  // connected
  signed int connected;
  // attributes
  struct anonymous$24 attributes;
  // sampleTime
  double sampleTime;
  // offsetTime
  double offsetTime;
  // dims
  signed int *dims;
  // sampleTimeIndex
  signed int sampleTimeIndex;
  // icPrmIdxPlus1
  signed int icPrmIdxPlus1;
  // numDims
  signed int numDims;
};

struct _ssResolveCBK
{
  // Resolver
  signed int (*Resolver)(const struct SimStruct_tag *, const char *, double **);
  // _slBlock
  void *_slBlock;
};

struct _ssSFcnModelMethods2
{
  // mdlProjection
  void (*mdlProjection)(struct SimStruct_tag *);
  // mdlJacobian
  void (*mdlJacobian)(struct SimStruct_tag *);
  // mdlSetInputPortFrameData
  void (*mdlSetInputPortFrameData)(struct SimStruct_tag *, signed int, enum anonymous$46);
  // strictBooleanCheckEnabledFcn
  unsigned char (*strictBooleanCheckEnabledFcn)(void *);
  // mdlSetDefaultPortDimensions
  void (*mdlSetDefaultPortDimensions)(struct SimStruct_tag *);
  // mdlSetDefaultPortDataTypes
  void (*mdlSetDefaultPortDataTypes)(struct SimStruct_tag *);
  // mdlSetDefaultPortComplexSignals
  void (*mdlSetDefaultPortComplexSignals)(struct SimStruct_tag *);
  // ConvertBuiltInDType
  unsigned char (*ConvertBuiltInDType)(signed int, unsigned char, unsigned char, const signed int, const void *, const signed int, void *);
  // resolveCBK
  struct _ssResolveCBK resolveCBK;
  // extModeLogFcn
  const char * (*extModeLogFcn)(struct SimStruct_tag *, const enum anonymous$51);
  // mdlExtModeExec
  void (*mdlExtModeExec)(struct SimStruct_tag *);
  // mdlRTWCG
  void (*mdlRTWCG)(struct SimStruct_tag *, void *);
  // mdlMassMatrix
  void (*mdlMassMatrix)(struct SimStruct_tag *);
  // unused
  void *unused;
  // mdlForcingFunction
  void (*mdlForcingFunction)(struct SimStruct_tag *);
  // mdlEnable
  void (*mdlEnable)(struct SimStruct_tag *);
  // mdlDisable
  void (*mdlDisable)(struct SimStruct_tag *);
  // mdlSimStatusChange
  void (*mdlSimStatusChange)(struct SimStruct_tag *, enum anonymous$50);
  // mdlInitializePropagationPass
  void (*mdlInitializePropagationPass)(struct SimStruct_tag *, enum anonymous$49);
  // constraintsInfo
  struct _ssConstraintsInfo *constraintsInfo;
  // modelMethods3
  struct _ssSFcnModelMethods3 *modelMethods3;
};

struct _ssSFcnModelMethods3
{
  // massMatrix
  struct _ssMassMatrixInfo massMatrix;
  // mdlInitSystemMatrices
  void (*mdlInitSystemMatrices)(struct SimStruct_tag *);
  // numSlvrJacobianNzmax
  signed int numSlvrJacobianNzmax;
  // slvrJacobianMatrix
  struct SparseHeader_Tag *slvrJacobianMatrix;
  // mdlJacobianIrJc
  void (*mdlJacobianIrJc)(struct SimStruct_tag *);
  // reservedForFuture
  void *reservedForFuture;
};

struct _ssSolverInfo_tag
{
  // rtModelPtr
  void *rtModelPtr;
  // simTimeStepPtr
  enum anonymous$34 *simTimeStepPtr;
  // solverData
  void *solverData;
  // solverName
  const char *solverName;
  // isVariableStepSolver
  unsigned char isVariableStepSolver;
  // solverNeedsReset
  unsigned char solverNeedsReset;
  // solverMode
  enum anonymous$43 solverMode;
  // solverStopTime
  double solverStopTime;
  // stepSizePtr
  double *stepSizePtr;
  // minStepSize
  double minStepSize;
  // maxStepSize
  double maxStepSize;
  // fixedStepSize
  double fixedStepSize;
  // solverShapePreserveControl
  signed int solverShapePreserveControl;
  // solverMaxConsecutiveMinStep
  signed int solverMaxConsecutiveMinStep;
  // maxNumMinSteps
  signed int maxNumMinSteps;
  // solverMaxOrder
  signed int solverMaxOrder;
  // solverConsecutiveZCsStepRelTol
  double solverConsecutiveZCsStepRelTol;
  // solverMaxConsecutiveZCs
  signed int solverMaxConsecutiveZCs;
  // solverExtrapolationOrder
  signed int solverExtrapolationOrder;
  // solverNumberNewtonIterations
  signed int solverNumberNewtonIterations;
  // solverRefineFactor
  signed int solverRefineFactor;
  // solverRelTol
  double solverRelTol;
  // unused_real_T_1
  double unused_real_T_1;
  // dXPtr
  double **dXPtr;
  // tPtr
  double **tPtr;
  // numContStatesPtr
  signed int *numContStatesPtr;
  // contStatesPtr
  double **contStatesPtr;
  // zcSignalVector
  double *zcSignalVector;
  // zcEventsVector
  unsigned char *zcEventsVector;
  // zcSignalAttrib
  unsigned char *zcSignalAttrib;
  // zcSignalVectorLength
  signed int zcSignalVectorLength;
  // reserved
  unsigned char *reserved;
  // foundContZcEvents
  unsigned char foundContZcEvents;
  // isAtLeftPostOfContZcEvent
  unsigned char isAtLeftPostOfContZcEvent;
  // isAtRightPostOfContZcEvent
  unsigned char isAtRightPostOfContZcEvent;
  // adaptiveZcDetection
  unsigned char adaptiveZcDetection;
  // numZcSignals
  signed int numZcSignals;
  // stateProjection
  unsigned char stateProjection;
  // robustResetMethod
  unsigned char robustResetMethod;
  // updateJacobianAtReset
  unsigned char updateJacobianAtReset;
  // consistencyChecking
  unsigned char consistencyChecking;
  // massMatrixType
  enum anonymous$42 massMatrixType;
  // massMatrixNzMax
  signed int massMatrixNzMax;
  // massMatrixIr
  signed int *massMatrixIr;
  // massMatrixJc
  signed int *massMatrixJc;
  // massMatrixPr
  double *massMatrixPr;
  // errStatusPtr
  const char **errStatusPtr;
  // modelMethodsPtr
  struct _RTWRTModelMethodsInfo_tag *modelMethodsPtr;
  // zcThreshold
  double zcThreshold;
  // zeroCrossAlgorithm
  signed int zeroCrossAlgorithm;
  // consecutiveZCsError
  signed int consecutiveZCsError;
  // blkStateChange
  unsigned char blkStateChange;
  // isComputingJacobian
  unsigned char isComputingJacobian;
  // solverJacobianMethodControl
  enum anonymous$44 solverJacobianMethodControl;
  // ignoredZcDiagnostic
  signed int ignoredZcDiagnostic;
  // maskedZcDiagnostic
  signed int maskedZcDiagnostic;
  // isOutputMethodComputed
  unsigned char isOutputMethodComputed;
};

struct _ssStatesInfo2
{
  // prevZCSigState
  unsigned char *prevZCSigState;
  // absTol
  double *absTol;
  // absTolControl
  unsigned char *absTolControl;
  // reservedForFutureUse
  void *reservedForFutureUse[6l];
};

struct ssParamRec_tag
{
  // name
  const char *name;
  // nDimensions
  signed int nDimensions;
  // dimensions
  signed int *dimensions;
  // dataTypeId
  signed int dataTypeId;
  // complexSignal
  unsigned char complexSignal;
  // data
  void *data;
  // dataAttributes
  const void *dataAttributes;
  // nDlgParamIndices
  signed int nDlgParamIndices;
  // dlgParamIndices
  signed int *dlgParamIndices;
  // transformed
  enum anonymous$57 transformed;
  // outputAsMatrix
  unsigned char outputAsMatrix;
};

struct tag_RTM_DockingApproachExampl_T
{
  // path
  const char *path;
  // modelName
  const char *modelName;
  // childSfunctions
  struct SimStruct_tag **childSfunctions;
  // errorStatus
  const char *errorStatus;
  // simMode
  enum anonymous$52 simMode;
  // rtwLogInfo
  struct _RTWLogInfo_tag *rtwLogInfo;
  // extModeInfo
  struct _RTWExtModeInfo_tag *extModeInfo;
  // solverInfo
  struct _ssSolverInfo_tag solverInfo;
  // solverInfoPtr
  struct _ssSolverInfo_tag *solverInfoPtr;
  // sfcnInfo
  void *sfcnInfo;
  // ModelData
  struct anonymous$53 ModelData;
  // Sizes
  struct anonymous$54 Sizes;
  // SpecialInfo
  struct anonymous$55 SpecialInfo;
  // Timing
  struct anonymous$56 Timing;
};


// DockingApproachExample_Ext_Y
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 85
struct anonymous$13 DockingApproachExample_Ext_Y;
// DockingApproachExample_Ext_DW
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 79
struct anonymous$10 DockingApproachExample_Ext_DW;
// DockingApproachExample_Ext_M
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 89
struct tag_RTM_DockingApproachExampl_T * const DockingApproachExample_Ext_M;
// DockingApproachExample_Ext_M_
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 88
struct tag_RTM_DockingApproachExampl_T DockingApproachExample_Ext_M_;
// DockingApproachExample_Ext_M
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 89
struct tag_RTM_DockingApproachExampl_T * const DockingApproachExample_Ext_M = &DockingApproachExample_Ext_M_;
// DockingApproachExample_Ext_U
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 82
struct anonymous$11 DockingApproachExample_Ext_U;
// FALSE
// file ../R2013a/rtw/c/grt/classic_main.c line 28
_Bool FALSE = 0 != 0;
// GBLbuf
// file ../R2013a/rtw/c/grt/classic_main.c line 161
static struct anonymous$20 GBLbuf;
// TRUE
// file ../R2013a/rtw/c/grt/classic_main.c line 27
_Bool TRUE = 0 == 0;
// rtGlobalLoggingSignalsStructFieldNames
// file ../R2013a/rtw/c/src/rt_logging.c line 136
static const char rtGlobalLoggingSignalsStructFieldNames[449l] = { 118, 97, 108, 117, 101, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118, 97, 108, 117, 101, 68, 105, 109, 101, 110, 115, 105, 111, 110, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 105, 109, 101, 110, 115, 105, 111, 110, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108, 97, 98, 101, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 98, 108, 111, 99, 107, 78, 97, 109, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 115, 116, 97, 116, 101, 78, 97, 109, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 105, 110, 82, 101, 102, 101, 114, 101, 110, 99, 101, 100, 77, 111, 100, 101, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// rtGlobalLoggingSignalsStructFieldNames_noValDims
// file ../R2013a/rtw/c/src/rt_logging.c line 165
static const char rtGlobalLoggingSignalsStructFieldNames_noValDims[385l] = { 118, 97, 108, 117, 101, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 105, 109, 101, 110, 115, 105, 111, 110, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108, 97, 98, 101, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 98, 108, 111, 99, 107, 78, 97, 109, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 115, 116, 97, 116, 101, 78, 97, 109, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 105, 110, 82, 101, 102, 101, 114, 101, 110, 99, 101, 100, 77, 111, 100, 101, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// rtInf
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.c line 26
double rtInf;
// rtInfF
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.c line 29
float rtInfF;
// rtLocalLoggingSignalsStructFieldNames
// file ../R2013a/rtw/c/src/rt_logging.c line 129
static const char rtLocalLoggingSignalsStructFieldNames[385l] = { 118, 97, 108, 117, 101, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118, 97, 108, 117, 101, 68, 105, 109, 101, 110, 115, 105, 111, 110, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 105, 109, 101, 110, 115, 105, 111, 110, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108, 97, 98, 101, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 105, 116, 108, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 108, 111, 116, 83, 116, 121, 108, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// rtLocalLoggingSignalsStructFieldNames_noValDims
// file ../R2013a/rtw/c/src/rt_logging.c line 159
static const char rtLocalLoggingSignalsStructFieldNames_noValDims[321l] = { 118, 97, 108, 117, 101, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 105, 109, 101, 110, 115, 105, 111, 110, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108, 97, 98, 101, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 105, 116, 108, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 108, 111, 116, 83, 116, 121, 108, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// rtMemAllocError
// file ../R2013a/rtw/c/src/rt_logging.c line 103
static const char rtMemAllocError[24l] = { 77, 101, 109, 111, 114, 121, 32, 97, 108, 108, 111, 99, 97, 116, 105, 111, 110, 32, 101, 114, 114, 111, 114, 0 };
// rtMinusInf
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.c line 27
double rtMinusInf;
// rtMinusInfF
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.c line 30
float rtMinusInfF;
// rtNaN
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.c line 28
double rtNaN;
// rtNaNF
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.c line 31
float rtNaNF;
// rtStructLogVarFieldNames
// file ../R2013a/rtw/c/src/rt_logging.c line 125
static const char rtStructLogVarFieldNames[193l] = { 116, 105, 109, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 115, 105, 103, 110, 97, 108, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 98, 108, 111, 99, 107, 78, 97, 109, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// td_struct
// file ../R2013a/rtw/c/src/rt_sim.c line 68
static struct TimingData_Tag td_struct;

// D_exit_internal_CaptureApproach
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 102
static void D_exit_internal_CaptureApproach(void)
{
  DockingApproachExample_Ext_DW.is_InertialNavigation = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_InertialNavigation = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_StarPlanetTracker = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_StarPlanetTracker = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_GPS = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_GPS = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_OrbitalState2 = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_OrbitalState2 = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_OrbitalState = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_OrbitalState = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_OrbitalState_Complex = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_OrbitalState_Active = (unsigned char)0U;
  if(DockingApproachExample_Ext_DW.is_CaptureApproach == 4)
  {
    DockingApproachExample_Ext_Y.CaptureApproachComplete = (unsigned char)1U;
    DockingApproachExample_Ext_DW.is_CaptureApproach = (unsigned char)0U;
  }

  else
    DockingApproachExample_Ext_DW.is_CaptureApproach = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_CaptureApproach = (unsigned char)0U;
}

// D_exit_internal_DockingApproach
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 996
static void D_exit_internal_DockingApproach(void)
{
  switch((signed int)DockingApproachExample_Ext_DW.is_dockingSensor)
  {
    case (signed int)(unsigned char)1U:
    {
      DockingApproachExample_Ext_DW.dockingSensor_timer = (signed char)0;
      DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)0U;
      break;
    }
    case (signed int)(unsigned char)2U:
    {
      DockingApproachExample_Ext_DW.dockingSensor_timer = (signed char)0;
      DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)0U;
      break;
    }
    default:
      DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)0U;
  }
  DockingApproachExample_Ext_DW.is_active_dockingSensor = (unsigned char)0U;
  if(DockingApproachExample_Ext_DW.is_DockingApproach == 4)
  {
    DockingApproachExample_Ext_Y.DockingApproachComplete = (unsigned char)1U;
    DockingApproachExample_Ext_DW.is_DockingApproach = (unsigned char)0U;
  }

  else
    DockingApproachExample_Ext_DW.is_DockingApproach = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_DockingApproach = (unsigned char)0U;
}

// DockingAppr_OrbitalState_Active
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 277
static void DockingAppr_OrbitalState_Active(void)
{
  signed int b_previousEvent;
  if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_OrbitalState_Complex == 0U))
  {
    if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_OrbitalState == 0U))
      switch((signed int)DockingApproachExample_Ext_DW.is_OrbitalState)
      {
        case (signed int)(unsigned char)1U:
        {
          if(DockingApproachExample_Ext_DW.GPS_AbsolutePosition == 0)
          {
            if(!(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit == 0))
              goto __CPROVER_DUMP_L2;

            if(!(DockingApproachExample_Ext_U.GroundTrack_OrbitalPosition == 0))
              goto __CPROVER_DUMP_L2;

          }

          else
          {

          __CPROVER_DUMP_L2:
            ;
            if(DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity == 0)
            {
              if(!(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc == 0))
                goto __CPROVER_DUMP_L3;

              if(!(DockingApproachExample_Ext_U.GroundTrack_OrbitalVelocity == 0))
                goto __CPROVER_DUMP_L3;

            }

            else
            {

            __CPROVER_DUMP_L3:
              ;
              DockingApproachExample_Ext_DW.is_OrbitalState = (unsigned char)3U;
              DockingApproachExample_Ext_DW.OrbitalState_Position = (signed char)1;
              DockingApproachExample_Ext_DW.OrbitalState_Velocity = (signed char)1;
              DockingApproachExample_Ext_DW.OrbitalState_Attitude = (signed char)0;
              goto __CPROVER_DUMP_L5;
            }
          }
          if(DockingApproachExample_Ext_DW.GPS_AbsolutePosition == 0)
          {
            if(DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity == 0)
            {
              if(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit == 0)
              {
                if(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc == 0)
                {
                  if(DockingApproachExample_Ext_U.GroundTrack_OrbitalPosition == 0)
                  {
                    if(DockingApproachExample_Ext_U.GroundTrack_OrbitalVelocity == 0)
                    {
                      DockingApproachExample_Ext_DW.is_OrbitalState = (unsigned char)1U;
                      DockingApproachExample_Ext_DW.OrbitalState_Position = (signed char)0;
                      DockingApproachExample_Ext_DW.OrbitalState_Velocity = (signed char)0;
                      DockingApproachExample_Ext_DW.OrbitalState_Attitude = (signed char)0;
                    }

                  }

                }

              }

            }

          }


        __CPROVER_DUMP_L5:
          ;
          break;
        }
        case (signed int)(unsigned char)2U:
        {
          if(DockingApproachExample_Ext_U.GroundTrack_OrbitalPosition == 2)
          {
            if(!(DockingApproachExample_Ext_DW.GPS_AbsolutePosition == 2))
              goto __CPROVER_DUMP_L7;

          }

          else
          {

          __CPROVER_DUMP_L7:
            ;
            if(DockingApproachExample_Ext_U.GroundTrack_OrbitalPosition == 2)
            {
              if(!(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit == 2))
                goto __CPROVER_DUMP_L8;

            }

            else
            {

            __CPROVER_DUMP_L8:
              ;
              if(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit == 2)
              {
                if(!(DockingApproachExample_Ext_DW.GPS_AbsolutePosition == 2))
                  goto __CPROVER_DUMP_L9;

              }

              else
              {

              __CPROVER_DUMP_L9:
                ;
                if(DockingApproachExample_Ext_DW.InertialNavigation_AbsolutePosi == 2)
                {
                  if(!(DockingApproachExample_Ext_U.GroundTrack_OrbitalPosition == 2))
                    goto __CPROVER_DUMP_L10;

                }

                else
                {

                __CPROVER_DUMP_L10:
                  ;
                  if(DockingApproachExample_Ext_DW.InertialNavigation_AbsolutePosi == 2)
                  {
                    if(!(DockingApproachExample_Ext_DW.GPS_AbsolutePosition == 2))
                      goto __CPROVER_DUMP_L11;

                  }

                  else
                  {

                  __CPROVER_DUMP_L11:
                    ;
                    if(DockingApproachExample_Ext_DW.InertialNavigation_AbsolutePosi == 2)
                    {
                      if(!(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit == 2))
                        goto __CPROVER_DUMP_L12;

                    }

                    else
                    {

                    __CPROVER_DUMP_L12:
                      ;
                      if(!(DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteAtti == 2))
                      {
                        if(!(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteAttit == 2))
                        {
                          if(DockingApproachExample_Ext_U.GroundTrack_OrbitalVelocity == 2)
                          {
                            if(!(DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity == 2))
                              goto __CPROVER_DUMP_L13;

                          }

                          else
                          {

                          __CPROVER_DUMP_L13:
                            ;
                            if(DockingApproachExample_Ext_U.GroundTrack_OrbitalVelocity == 2)
                            {
                              if(!(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc == 2))
                                goto __CPROVER_DUMP_L14;

                            }

                            else
                            {

                            __CPROVER_DUMP_L14:
                              ;
                              if(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc == 2)
                              {
                                if(!(DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity == 2))
                                  goto __CPROVER_DUMP_L15;

                              }

                              else
                              {

                              __CPROVER_DUMP_L15:
                                ;
                                if(DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteVelo == 2)
                                {
                                  if(!(DockingApproachExample_Ext_U.GroundTrack_OrbitalVelocity == 2))
                                    goto __CPROVER_DUMP_L16;

                                }

                                else
                                {

                                __CPROVER_DUMP_L16:
                                  ;
                                  if(DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteVelo == 2)
                                  {
                                    if(!(DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity == 2))
                                      goto __CPROVER_DUMP_L17;

                                  }

                                  else
                                  {

                                  __CPROVER_DUMP_L17:
                                    ;
                                    if(DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteVelo == 2)
                                    {
                                      if(!(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc == 2))
                                        goto __CPROVER_DUMP_L18;

                                    }

                                    else
                                    {

                                    __CPROVER_DUMP_L18:
                                      ;
                                      DockingApproachExample_Ext_DW.is_OrbitalState = (unsigned char)3U;
                                      DockingApproachExample_Ext_DW.OrbitalState_Position = (signed char)1;
                                      DockingApproachExample_Ext_DW.OrbitalState_Velocity = (signed char)1;
                                      DockingApproachExample_Ext_DW.OrbitalState_Attitude = (signed char)0;
                                      goto __CPROVER_DUMP_L23;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }

                      }

                    }
                  }
                }
              }
            }
          }
          if(!(DockingApproachExample_Ext_U.GroundTrack_OrbitalPosition == 2))
          {
            if(DockingApproachExample_Ext_DW.GPS_AbsolutePosition == 2)
              goto __CPROVER_DUMP_L20;

            if(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit == 2)
              goto __CPROVER_DUMP_L20;

          }

          else
          {

          __CPROVER_DUMP_L20:
            ;
            if(!(DockingApproachExample_Ext_U.GroundTrack_OrbitalVelocity == 2))
            {
              if(DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity == 2)
                goto __CPROVER_DUMP_L21;

              if(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc == 2)
                goto __CPROVER_DUMP_L21;

            }

            else
            {

            __CPROVER_DUMP_L21:
              ;
              if(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteAttit == 2)
              {
                DockingApproachExample_Ext_DW.is_OrbitalState = (unsigned char)0U;
                b_previousEvent = DockingApproachExample_Ext_DW.sfEvent;
                DockingApproachExample_Ext_DW.sfEvent = 0;
                if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_InertialNavigation == 0U))
                  DockingAppro_InertialNavigation();

                DockingApproachExample_Ext_DW.sfEvent = b_previousEvent;
                DockingApproachExample_Ext_DW.is_OrbitalState = (unsigned char)2U;
                DockingApproachExample_Ext_DW.OrbitalState_Position = (signed char)2;
                DockingApproachExample_Ext_DW.OrbitalState_Velocity = (signed char)2;
                DockingApproachExample_Ext_DW.OrbitalState_Attitude = (signed char)2;
              }

            }
          }

        __CPROVER_DUMP_L23:
          ;
          break;
        }
        case (signed int)(unsigned char)3U:
        {
          if(DockingApproachExample_Ext_U.GroundTrack_OrbitalPosition == 0)
          {
            if(!(DockingApproachExample_Ext_DW.GPS_AbsolutePosition == 0))
              goto __CPROVER_DUMP_L25;

            if(!(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit == 0))
              goto __CPROVER_DUMP_L25;

            if(!(DockingApproachExample_Ext_U.GroundTrack_OrbitalVelocity == 0))
              goto __CPROVER_DUMP_L25;

            if(!(DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity == 0))
              goto __CPROVER_DUMP_L25;

            if(!(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc == 0))
              goto __CPROVER_DUMP_L25;

            DockingApproachExample_Ext_DW.is_OrbitalState = (unsigned char)1U;
            DockingApproachExample_Ext_DW.OrbitalState_Position = (signed char)0;
            DockingApproachExample_Ext_DW.OrbitalState_Velocity = (signed char)0;
            DockingApproachExample_Ext_DW.OrbitalState_Attitude = (signed char)0;
          }

          else
          {

          __CPROVER_DUMP_L25:
            ;
            if(DockingApproachExample_Ext_U.GroundTrack_OrbitalPosition == 2)
            {
              if(!(DockingApproachExample_Ext_DW.GPS_AbsolutePosition == 2))
                goto __CPROVER_DUMP_L26;

            }

            else
            {

            __CPROVER_DUMP_L26:
              ;
              if(DockingApproachExample_Ext_U.GroundTrack_OrbitalPosition == 2)
              {
                if(!(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit == 2))
                  goto __CPROVER_DUMP_L27;

              }

              else
              {

              __CPROVER_DUMP_L27:
                ;
                if(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit == 2)
                {
                  if(!(DockingApproachExample_Ext_DW.GPS_AbsolutePosition == 2))
                    goto __CPROVER_DUMP_L28;

                }

                else
                {

                __CPROVER_DUMP_L28:
                  ;
                  if(DockingApproachExample_Ext_DW.InertialNavigation_AbsolutePosi == 2)
                  {
                    if(!(DockingApproachExample_Ext_U.GroundTrack_OrbitalPosition == 2))
                      goto __CPROVER_DUMP_L29;

                  }

                  else
                  {

                  __CPROVER_DUMP_L29:
                    ;
                    if(DockingApproachExample_Ext_DW.InertialNavigation_AbsolutePosi == 2)
                    {
                      if(!(DockingApproachExample_Ext_DW.GPS_AbsolutePosition == 2))
                        goto __CPROVER_DUMP_L30;

                    }

                    else
                    {

                    __CPROVER_DUMP_L30:
                      ;
                      if(DockingApproachExample_Ext_DW.InertialNavigation_AbsolutePosi == 2)
                      {
                        if(!(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit == 2))
                          goto __CPROVER_DUMP_L31;

                      }

                      else
                      {

                      __CPROVER_DUMP_L31:
                        ;
                        goto __CPROVER_DUMP_L41;
                      }
                    }
                  }
                }
              }
            }
            if(DockingApproachExample_Ext_U.GroundTrack_OrbitalVelocity == 2)
            {
              if(!(DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity == 2))
                goto __CPROVER_DUMP_L33;

            }

            else
            {

            __CPROVER_DUMP_L33:
              ;
              if(DockingApproachExample_Ext_U.GroundTrack_OrbitalVelocity == 2)
              {
                if(!(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc == 2))
                  goto __CPROVER_DUMP_L34;

              }

              else
              {

              __CPROVER_DUMP_L34:
                ;
                if(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc == 2)
                {
                  if(!(DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity == 2))
                    goto __CPROVER_DUMP_L35;

                }

                else
                {

                __CPROVER_DUMP_L35:
                  ;
                  if(DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteVelo == 2)
                  {
                    if(!(DockingApproachExample_Ext_U.GroundTrack_OrbitalVelocity == 2))
                      goto __CPROVER_DUMP_L36;

                  }

                  else
                  {

                  __CPROVER_DUMP_L36:
                    ;
                    if(DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteVelo == 2)
                    {
                      if(!(DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity == 2))
                        goto __CPROVER_DUMP_L37;

                    }

                    else
                    {

                    __CPROVER_DUMP_L37:
                      ;
                      if(DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteVelo == 2)
                      {
                        if(!(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc == 2))
                          goto __CPROVER_DUMP_L38;

                      }

                      else
                      {

                      __CPROVER_DUMP_L38:
                        ;
                        goto __CPROVER_DUMP_L41;
                      }
                    }
                  }
                }
              }
            }
            if(!(DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteAtti == 2))
            {
              if(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteAttit == 2)
                goto __CPROVER_DUMP_L40;

            }

            else
            {

            __CPROVER_DUMP_L40:
              ;
              DockingApproachExample_Ext_DW.is_OrbitalState = (unsigned char)4U;
              DockingApproachExample_Ext_DW.OrbitalState_Position = (signed char)2;
              DockingApproachExample_Ext_DW.OrbitalState_Velocity = (signed char)2;
              DockingApproachExample_Ext_DW.OrbitalState_Attitude = (signed char)1;
            }
          }

        __CPROVER_DUMP_L41:
          ;
          break;
        }
        case (signed int)(unsigned char)4U:
        {
          if(!(DockingApproachExample_Ext_U.GroundTrack_OrbitalPosition == 2))
          {
            if(DockingApproachExample_Ext_DW.GPS_AbsolutePosition == 2)
              goto __CPROVER_DUMP_L43;

            if(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit == 2)
              goto __CPROVER_DUMP_L43;

          }

          else
          {

          __CPROVER_DUMP_L43:
            ;
            if(!(DockingApproachExample_Ext_U.GroundTrack_OrbitalVelocity == 2))
            {
              if(DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity == 2)
                goto __CPROVER_DUMP_L44;

              if(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc == 2)
                goto __CPROVER_DUMP_L44;

            }

            else
            {

            __CPROVER_DUMP_L44:
              ;
              if(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteAttit == 2)
              {
                DockingApproachExample_Ext_DW.is_OrbitalState = (unsigned char)0U;
                b_previousEvent = DockingApproachExample_Ext_DW.sfEvent;
                DockingApproachExample_Ext_DW.sfEvent = 0;
                if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_InertialNavigation == 0U))
                  DockingAppro_InertialNavigation();

                DockingApproachExample_Ext_DW.sfEvent = b_previousEvent;
                DockingApproachExample_Ext_DW.is_OrbitalState = (unsigned char)2U;
                DockingApproachExample_Ext_DW.OrbitalState_Position = (signed char)2;
                DockingApproachExample_Ext_DW.OrbitalState_Velocity = (signed char)2;
                DockingApproachExample_Ext_DW.OrbitalState_Attitude = (signed char)2;
              }

            }
          }
          break;
        }
        default:
          DockingApproachExample_Ext_DW.is_OrbitalState = (unsigned char)0U;
      }

    if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_OrbitalState2 == 0U))
      switch((signed int)DockingApproachExample_Ext_DW.is_OrbitalState2)
      {
        case (signed int)(unsigned char)1U:
        {
          if(!(DockingApproachExample_Ext_U.RealTimeClock_time == 2))
          {
            DockingApproachExample_Ext_DW.is_OrbitalState2 = (unsigned char)2U;
            DockingApproachExample_Ext_DW.OrbitalState_Time = (signed char)1;
          }

          else
            if(!(DockingApproachExample_Ext_U.GroundTrack_Time == 2))
            {
              if(DockingApproachExample_Ext_DW.GPS_AbsoluteTime == 2)
                goto __CPROVER_DUMP_L51;

              if(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteTime == 2)
                goto __CPROVER_DUMP_L51;

            }

            else
            {

            __CPROVER_DUMP_L51:
              ;
              DockingApproachExample_Ext_DW.is_OrbitalState2 = (unsigned char)1U;
              DockingApproachExample_Ext_DW.OrbitalState_Time = (signed char)2;
            }
          break;
        }
        case (signed int)(unsigned char)2U:
        {
          if(!(DockingApproachExample_Ext_U.GroundTrack_Time == 2))
          {
            if(DockingApproachExample_Ext_DW.GPS_AbsoluteTime == 2)
              goto __CPROVER_DUMP_L54;

            if(DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteTime == 2)
              goto __CPROVER_DUMP_L54;

          }

          else
          {

          __CPROVER_DUMP_L54:
            ;
            DockingApproachExample_Ext_DW.is_OrbitalState2 = (unsigned char)1U;
            DockingApproachExample_Ext_DW.OrbitalState_Time = (signed char)2;
          }
          break;
        }
        default:
          DockingApproachExample_Ext_DW.is_OrbitalState2 = (unsigned char)0U;
      }

  }

  if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_GPS == 0U))
  {
    b_previousEvent = (signed int)DockingApproachExample_Ext_DW.GPS_timer + 1;
    if(b_previousEvent <= 6)
      DockingApproachExample_Ext_DW.GPS_timer = (signed char)b_previousEvent;

    else
      DockingApproachExample_Ext_DW.GPS_timer = (signed char)6;
    switch((signed int)DockingApproachExample_Ext_DW.is_GPS)
    {
      case (signed int)(unsigned char)1U:
      {
        if(!(DockingApproachExample_Ext_U.GPS_satelliteVisibility_status == 0))
        {
          if(DockingApproachExample_Ext_U.GPS_receiverAvailability_status == 0)
            goto __CPROVER_DUMP_L61;

          DockingApproachExample_Ext_DW.is_GPS = (unsigned char)3U;
          DockingApproachExample_Ext_DW.GPS_timer = (signed char)0;
          DockingApproachExample_Ext_DW.GPS_AbsolutePosition = (signed char)1;
          DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity = (signed char)1;
          DockingApproachExample_Ext_DW.GPS_AbsoluteTime = (signed char)1;
        }

        else
        {

        __CPROVER_DUMP_L61:
          ;
          if(!(DockingApproachExample_Ext_U.GPS_satelliteVisibility_status == 0))
          {
            if(DockingApproachExample_Ext_U.GPS_receiverAvailability_status == 0)
              goto __CPROVER_DUMP_L62;

          }

          else
          {

          __CPROVER_DUMP_L62:
            ;
            DockingApproachExample_Ext_DW.is_GPS = (unsigned char)1U;
            DockingApproachExample_Ext_DW.GPS_AbsolutePosition = (signed char)0;
            DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity = (signed char)0;
            DockingApproachExample_Ext_DW.GPS_AbsoluteTime = (signed char)0;
          }
        }
        break;
      }
      case (signed int)(unsigned char)2U:
      {
        if(DockingApproachExample_Ext_U.GPS_satelliteVisibility_status == 2)
        {
          if(DockingApproachExample_Ext_U.GPS_receiverAvailability_status == 0)
            goto __CPROVER_DUMP_L65;

          if(DockingApproachExample_Ext_U.sunlight_status != 0)
            goto __CPROVER_DUMP_L65;

        }

        else
        {

        __CPROVER_DUMP_L65:
          ;
          DockingApproachExample_Ext_DW.is_GPS = (unsigned char)3U;
          DockingApproachExample_Ext_DW.GPS_timer = (signed char)0;
          DockingApproachExample_Ext_DW.GPS_AbsolutePosition = (signed char)1;
          DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity = (signed char)1;
          DockingApproachExample_Ext_DW.GPS_AbsoluteTime = (signed char)1;
          goto __CPROVER_DUMP_L67;
        }
        if(DockingApproachExample_Ext_U.GPS_satelliteVisibility_status == 2)
        {
          if(!(DockingApproachExample_Ext_U.GPS_receiverAvailability_status == 0))
          {
            if(DockingApproachExample_Ext_U.sunlight_status == 0)
            {
              DockingApproachExample_Ext_DW.is_GPS = (unsigned char)2U;
              DockingApproachExample_Ext_DW.GPS_AbsolutePosition = (signed char)2;
              DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity = (signed char)2;
              DockingApproachExample_Ext_DW.GPS_AbsoluteTime = (signed char)2;
            }

          }

        }


      __CPROVER_DUMP_L67:
        ;
        break;
      }
      case (signed int)(unsigned char)3U:
      {
        if(DockingApproachExample_Ext_DW.GPS_timer == 6)
        {
          if(!(DockingApproachExample_Ext_U.GPS_satelliteVisibility_status == 0))
          {
            if(!(DockingApproachExample_Ext_U.GPS_receiverAvailability_status == 0))
              goto __CPROVER_DUMP_L70;

          }

          DockingApproachExample_Ext_DW.is_GPS = (unsigned char)1U;
          DockingApproachExample_Ext_DW.GPS_AbsolutePosition = (signed char)0;
          DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity = (signed char)0;
          DockingApproachExample_Ext_DW.GPS_AbsoluteTime = (signed char)0;
        }

        else
        {

        __CPROVER_DUMP_L70:
          ;
          if(DockingApproachExample_Ext_DW.GPS_timer == 6)
          {
            if(!(DockingApproachExample_Ext_U.GPS_satelliteVisibility_status == 2))
              goto __CPROVER_DUMP_L71;

            if(DockingApproachExample_Ext_U.GPS_receiverAvailability_status == 0)
              goto __CPROVER_DUMP_L71;

            if(DockingApproachExample_Ext_U.sunlight_status != 0)
              goto __CPROVER_DUMP_L71;

            DockingApproachExample_Ext_DW.is_GPS = (unsigned char)2U;
            DockingApproachExample_Ext_DW.GPS_AbsolutePosition = (signed char)2;
            DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity = (signed char)2;
            DockingApproachExample_Ext_DW.GPS_AbsoluteTime = (signed char)2;
          }

          else
          {

          __CPROVER_DUMP_L71:
            ;
            if((signed int)DockingApproachExample_Ext_DW.GPS_timer < 6)
            {
              if(!(DockingApproachExample_Ext_U.GPS_satelliteVisibility_status == 0))
              {
                if(!(DockingApproachExample_Ext_U.GPS_receiverAvailability_status == 0))
                  goto __CPROVER_DUMP_L73;

              }

            }

            else
            {

            __CPROVER_DUMP_L73:
              ;
              if(!(DockingApproachExample_Ext_U.GPS_receiverAvailability_status == 0))
              {
                if(!(DockingApproachExample_Ext_U.GPS_satelliteVisibility_status == 1))
                {
                  if(DockingApproachExample_Ext_U.sunlight_status == 0)
                    goto __CPROVER_DUMP_L75;

                }

              }

              else
              {

              __CPROVER_DUMP_L75:
                ;
                goto __CPROVER_DUMP_L77;
              }
            }
            DockingApproachExample_Ext_DW.is_GPS = (unsigned char)3U;
            DockingApproachExample_Ext_DW.GPS_timer = (signed char)0;
            DockingApproachExample_Ext_DW.GPS_AbsolutePosition = (signed char)1;
            DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity = (signed char)1;
            DockingApproachExample_Ext_DW.GPS_AbsoluteTime = (signed char)1;
          }
        }

      __CPROVER_DUMP_L77:
        ;
        break;
      }
      default:
        DockingApproachExample_Ext_DW.is_GPS = (unsigned char)0U;
    }
  }

  if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_StarPlanetTracker == 0U))
  {
    b_previousEvent = (signed int)DockingApproachExample_Ext_DW.StarPlanetTracker_timer + 1;
    if(b_previousEvent <= 6)
      DockingApproachExample_Ext_DW.StarPlanetTracker_timer = (signed char)b_previousEvent;

    else
      DockingApproachExample_Ext_DW.StarPlanetTracker_timer = (signed char)6;
    switch((signed int)DockingApproachExample_Ext_DW.is_StarPlanetTracker)
    {
      case (signed int)(unsigned char)1U:
      {
        if(!(DockingApproachExample_Ext_U.StarPlanetTracker_planetVisibil == 0))
        {
          if(DockingApproachExample_Ext_U.StarPlanetTracker_starVisibilit == 0)
            goto __CPROVER_DUMP_L83;

          if(DockingApproachExample_Ext_U.opticsAvailability_status == 0)
            goto __CPROVER_DUMP_L83;

          DockingApproachExample_Ext_DW.is_StarPlanetTracker = (unsigned char)3U;
          DockingApproachExample_Ext_DW.StarPlanetTracker_timer = (signed char)0;
          DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit = (signed char)1;
          DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc = (signed char)1;
          DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteAttit = (signed char)1;
          DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteTime = (signed char)1;
        }

        else
        {

        __CPROVER_DUMP_L83:
          ;
          if(!(DockingApproachExample_Ext_U.StarPlanetTracker_planetVisibil == 0))
          {
            if(DockingApproachExample_Ext_U.StarPlanetTracker_starVisibilit == 0)
              goto __CPROVER_DUMP_L84;

            if(DockingApproachExample_Ext_U.opticsAvailability_status == 0)
              goto __CPROVER_DUMP_L84;

          }

          else
          {

          __CPROVER_DUMP_L84:
            ;
            DockingApproachExample_Ext_DW.is_StarPlanetTracker = (unsigned char)1U;
            DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit = (signed char)0;
            DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc = (signed char)0;
            DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteAttit = (signed char)0;
            DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteTime = (signed char)0;
          }
        }
        break;
      }
      case (signed int)(unsigned char)2U:
      {
        if(!(DockingApproachExample_Ext_U.StarPlanetTracker_planetVisibil == 2))
        {
          if(DockingApproachExample_Ext_U.StarPlanetTracker_starVisibilit == 2)
            goto __CPROVER_DUMP_L87;

          if(DockingApproachExample_Ext_U.opticsAvailability_status != 0)
            goto __CPROVER_DUMP_L87;

        }

        else
        {

        __CPROVER_DUMP_L87:
          ;
          if(DockingApproachExample_Ext_U.sunlight_status == 0)
            goto __CPROVER_DUMP_L89;

        }
        DockingApproachExample_Ext_DW.is_StarPlanetTracker = (unsigned char)3U;
        DockingApproachExample_Ext_DW.StarPlanetTracker_timer = (signed char)0;
        DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit = (signed char)1;
        DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc = (signed char)1;
        DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteAttit = (signed char)1;
        DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteTime = (signed char)1;
        goto __CPROVER_DUMP_L90;

      __CPROVER_DUMP_L89:
        ;
        if(DockingApproachExample_Ext_U.StarPlanetTracker_planetVisibil == 2)
        {
          if(DockingApproachExample_Ext_U.StarPlanetTracker_starVisibilit == 2)
          {
            if(!(DockingApproachExample_Ext_U.opticsAvailability_status == 0))
            {
              if(DockingApproachExample_Ext_U.sunlight_status == 0)
              {
                DockingApproachExample_Ext_DW.is_StarPlanetTracker = (unsigned char)2U;
                DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit = (signed char)2;
                DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc = (signed char)2;
                DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteAttit = (signed char)2;
                DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteTime = (signed char)2;
              }

            }

          }

        }


      __CPROVER_DUMP_L90:
        ;
        break;
      }
      case (signed int)(unsigned char)3U:
      {
        if(DockingApproachExample_Ext_DW.StarPlanetTracker_timer == 6)
        {
          if(!(DockingApproachExample_Ext_U.StarPlanetTracker_planetVisibil == 0))
          {
            if(!(DockingApproachExample_Ext_U.StarPlanetTracker_starVisibilit == 0))
            {
              if(!(DockingApproachExample_Ext_U.opticsAvailability_status == 0))
                goto __CPROVER_DUMP_L93;

            }

          }

          DockingApproachExample_Ext_DW.is_StarPlanetTracker = (unsigned char)1U;
          DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit = (signed char)0;
          DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc = (signed char)0;
          DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteAttit = (signed char)0;
          DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteTime = (signed char)0;
        }

        else
        {

        __CPROVER_DUMP_L93:
          ;
          if(DockingApproachExample_Ext_DW.StarPlanetTracker_timer == 6)
          {
            if(!(DockingApproachExample_Ext_U.StarPlanetTracker_planetVisibil == 2))
              goto __CPROVER_DUMP_L94;

            if(!(DockingApproachExample_Ext_U.StarPlanetTracker_starVisibilit == 2))
              goto __CPROVER_DUMP_L94;

            if(DockingApproachExample_Ext_U.opticsAvailability_status == 0)
              goto __CPROVER_DUMP_L94;

            if(DockingApproachExample_Ext_U.sunlight_status != 0)
              goto __CPROVER_DUMP_L94;

            DockingApproachExample_Ext_DW.is_StarPlanetTracker = (unsigned char)2U;
            DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit = (signed char)2;
            DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc = (signed char)2;
            DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteAttit = (signed char)2;
            DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteTime = (signed char)2;
          }

          else
          {

          __CPROVER_DUMP_L94:
            ;
            if((signed int)DockingApproachExample_Ext_DW.StarPlanetTracker_timer < 6)
            {
              if(!(DockingApproachExample_Ext_U.StarPlanetTracker_planetVisibil == 0))
              {
                if(!(DockingApproachExample_Ext_U.StarPlanetTracker_starVisibilit == 0))
                {
                  if(!(DockingApproachExample_Ext_U.opticsAvailability_status == 0))
                    goto __CPROVER_DUMP_L96;

                }

              }

            }

            else
            {

            __CPROVER_DUMP_L96:
              ;
              if(!(DockingApproachExample_Ext_U.opticsAvailability_status == 0))
              {
                if(DockingApproachExample_Ext_U.sunlight_status == 0)
                {
                  if(!(DockingApproachExample_Ext_U.StarPlanetTracker_planetVisibil == 1))
                  {
                    if(!(DockingApproachExample_Ext_U.StarPlanetTracker_starVisibilit == 1))
                      goto __CPROVER_DUMP_L98;

                  }

                }

              }

              else
              {

              __CPROVER_DUMP_L98:
                ;
                goto __CPROVER_DUMP_L100;
              }
            }
            DockingApproachExample_Ext_DW.is_StarPlanetTracker = (unsigned char)3U;
            DockingApproachExample_Ext_DW.StarPlanetTracker_timer = (signed char)0;
            DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit = (signed char)1;
            DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc = (signed char)1;
            DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteAttit = (signed char)1;
            DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteTime = (signed char)1;
          }
        }

      __CPROVER_DUMP_L100:
        ;
        break;
      }
      default:
        DockingApproachExample_Ext_DW.is_StarPlanetTracker = (unsigned char)0U;
    }
  }

  if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_InertialNavigation == 0U))
    DockingAppro_InertialNavigation();

}

// DockingAppro_InertialNavigation
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 149
static void DockingAppro_InertialNavigation(void)
{
  signed int u = (signed int)DockingApproachExample_Ext_DW.InertialNavigation_timer + 1;
  if(u <= 6)
    DockingApproachExample_Ext_DW.InertialNavigation_timer = (signed char)u;

  else
    DockingApproachExample_Ext_DW.InertialNavigation_timer = (signed char)6;
  switch((signed int)DockingApproachExample_Ext_DW.is_InertialNavigation)
  {
    case (signed int)(unsigned char)1U:
    {
      if(DockingApproachExample_Ext_DW.sfEvent == 0)
      {
        DockingApproachExample_Ext_DW.is_InertialNavigation = (unsigned char)2U;
        DockingApproachExample_Ext_DW.InertialNavigation_timer = (signed char)0;
        DockingApproachExample_Ext_DW.InertialNavigation_AbsolutePosi = (signed char)2;
        DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteVelo = (signed char)2;
        DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteAtti = (signed char)2;
      }

      break;
    }
    case (signed int)(unsigned char)2U:
    {
      if(DockingApproachExample_Ext_DW.InertialNavigation_timer == 6)
      {
        DockingApproachExample_Ext_DW.is_InertialNavigation = (unsigned char)3U;
        DockingApproachExample_Ext_DW.InertialNavigation_AbsolutePosi = (signed char)1;
        DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteVelo = (signed char)1;
        DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteAtti = (signed char)1;
      }

      else
        if((signed int)DockingApproachExample_Ext_DW.InertialNavigation_timer < 6)
        {
          DockingApproachExample_Ext_DW.is_InertialNavigation = (unsigned char)2U;
          DockingApproachExample_Ext_DW.InertialNavigation_timer = (signed char)0;
          DockingApproachExample_Ext_DW.InertialNavigation_AbsolutePosi = (signed char)2;
          DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteVelo = (signed char)2;
          DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteAtti = (signed char)2;
        }

        else
          if(!(DockingApproachExample_Ext_U.InertialNavigation_time == DockingApproachExample_Ext_DW.VALID))
          {
            DockingApproachExample_Ext_DW.is_InertialNavigation = (unsigned char)1U;
            DockingApproachExample_Ext_DW.InertialNavigation_AbsolutePosi = (signed char)0;
            DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteVelo = (signed char)0;
            DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteAtti = (signed char)0;
          }

      break;
    }
    case (signed int)(unsigned char)3U:
    {
      if(DockingApproachExample_Ext_DW.sfEvent == 0)
      {
        DockingApproachExample_Ext_DW.is_InertialNavigation = (unsigned char)2U;
        DockingApproachExample_Ext_DW.InertialNavigation_timer = (signed char)0;
        DockingApproachExample_Ext_DW.InertialNavigation_AbsolutePosi = (signed char)2;
        DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteVelo = (signed char)2;
        DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteAtti = (signed char)2;
      }

      else
        if(!(DockingApproachExample_Ext_U.InertialNavigation_time == DockingApproachExample_Ext_DW.VALID))
        {
          DockingApproachExample_Ext_DW.is_InertialNavigation = (unsigned char)1U;
          DockingApproachExample_Ext_DW.InertialNavigation_AbsolutePosi = (signed char)0;
          DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteVelo = (signed char)0;
          DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteAtti = (signed char)0;
        }

      break;
    }
    default:
      DockingApproachExample_Ext_DW.is_InertialNavigation = (unsigned char)0U;
  }
}

// DockingAppro_MissionPhaseStates
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 1550
static void DockingAppro_MissionPhaseStates(void)
{
  signed int u;
  switch((signed int)DockingApproachExample_Ext_DW.is_MissionPhaseStates)
  {
    case (signed int)(unsigned char)1U:
    {
      if((signed int)DockingApproachExample_Ext_U.StageTransition == 2)
      {
        DockingApproachExample_Ext_Y.ApproachOrbitComplete = (unsigned char)1U;
        DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)11U;
      }

      break;
    }
    case (signed int)(unsigned char)2U:
    {
      if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_CaptureApproach == 0U))
      {
        u = (signed int)DockingApproachExample_Ext_DW.CaptureApproach_timer + 1;
        if(u <= 11)
          DockingApproachExample_Ext_DW.CaptureApproach_timer = (signed char)u;

        else
          DockingApproachExample_Ext_DW.CaptureApproach_timer = (signed char)11;
        switch((signed int)DockingApproachExample_Ext_DW.is_CaptureApproach)
        {
          case (signed int)(unsigned char)1U:
          {
            D_exit_internal_CaptureApproach();
            DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)3U;
            break;
          }
          case (signed int)(unsigned char)2U:
          {
            if(DockingApproachExample_Ext_DW.OrbitalState_Position == 2)
            {
              if(!(DockingApproachExample_Ext_DW.OrbitalState_Velocity == 2))
                goto __CPROVER_DUMP_L8;

              if(DockingApproachExample_Ext_DW.OrbitalState_Attitude == 0)
                goto __CPROVER_DUMP_L8;

              if(!(DockingApproachExample_Ext_DW.OrbitalState_Time == 2))
                goto __CPROVER_DUMP_L8;

              DockingApproachExample_Ext_DW.is_CaptureApproach = (unsigned char)4U;
            }

            else
            {

            __CPROVER_DUMP_L8:
              ;
              if(DockingApproachExample_Ext_DW.OrbitalState_Position == 1)
              {
                if(!(DockingApproachExample_Ext_DW.OrbitalState_Velocity == 1))
                  goto __CPROVER_DUMP_L9;

                if(!(DockingApproachExample_Ext_DW.OrbitalState_Attitude == 0))
                  goto __CPROVER_DUMP_L9;

                if(!(DockingApproachExample_Ext_DW.OrbitalState_Time == 1))
                  goto __CPROVER_DUMP_L9;

                DockingApproachExample_Ext_DW.is_CaptureApproach = (unsigned char)3U;
              }

              else
              {

              __CPROVER_DUMP_L9:
                ;
                if(!(DockingApproachExample_Ext_DW.OrbitalState_Position == 0))
                {
                  if(DockingApproachExample_Ext_DW.OrbitalState_Velocity == 0)
                    goto __CPROVER_DUMP_L10;

                  if(DockingApproachExample_Ext_DW.OrbitalState_Attitude == 0)
                    goto __CPROVER_DUMP_L10;

                  if(DockingApproachExample_Ext_DW.OrbitalState_Time == 0)
                    goto __CPROVER_DUMP_L10;

                  if(DockingApproachExample_Ext_DW.CaptureApproach_timer == 11)
                    goto __CPROVER_DUMP_L10;

                }

                else
                {

                __CPROVER_DUMP_L10:
                  ;
                  DockingApproachExample_Ext_DW.is_CaptureApproach = (unsigned char)1U;
                  DockingApproachExample_Ext_Y.CaptureApproachFailed = (unsigned char)1U;
                }
              }
            }
            break;
          }
          case (signed int)(unsigned char)3U:
          {
            if((unsigned int)DockingApproachExample_Ext_DW.thrust_status == 1U)
            {
              if(!(DockingApproachExample_Ext_DW.fuel_status == 2))
                goto __CPROVER_DUMP_L13;

              DockingApproachExample_Ext_DW.is_CaptureApproach = (unsigned char)2U;
            }

            else
            {

            __CPROVER_DUMP_L13:
              ;
              if((unsigned int)DockingApproachExample_Ext_DW.thrust_status == 1U)
              {
                if(!(DockingApproachExample_Ext_DW.fuel_status == 2))
                  goto __CPROVER_DUMP_L14;

                if(DockingApproachExample_Ext_DW.CaptureApproach_timer == 11)
                  goto __CPROVER_DUMP_L14;

              }

              else
              {

              __CPROVER_DUMP_L14:
                ;
                DockingApproachExample_Ext_DW.is_CaptureApproach = (unsigned char)1U;
                DockingApproachExample_Ext_Y.CaptureApproachFailed = (unsigned char)1U;
              }
            }
            break;
          }
          case (signed int)(unsigned char)4U:
          {
            D_exit_internal_CaptureApproach();
            DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)5U;
            DockingApproachExample_Ext_Y.DockingApproach = (unsigned char)1U;
            DockingApproachExample_Ext_Y.DockingApproachComplete = (unsigned char)0U;
            DockingApproachExample_Ext_DW.is_active_DockingApproach = (unsigned char)1U;
            if(!(DockingApproachExample_Ext_DW.is_DockingApproach == 5))
            {
              DockingApproachExample_Ext_DW.is_DockingApproach = (unsigned char)5U;
              DockingApproachExample_Ext_DW.DockingApproach_timer = (signed char)0;
            }

            DockingApproachExample_Ext_DW.is_active_dockingSensor = (unsigned char)1U;
            if(!(DockingApproachExample_Ext_DW.is_dockingSensor == 1))
            {
              DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)1U;
              DockingApproachExample_Ext_DW.dockingSensor_RelativePosition = (signed char)0;
              DockingApproachExample_Ext_DW.dockingSensor_RelativeVelocity = (signed char)0;
              DockingApproachExample_Ext_DW.dockingSensor_RelativeAttitude = (signed char)0;
              DockingApproachExample_Ext_DW.dockingSensor_targetState = (signed char)0;
            }

            break;
          }
          case (signed int)(unsigned char)5U:
          {
            if(!(DockingApproachExample_Ext_DW.OrbitalState_Position == 0))
            {
              if(DockingApproachExample_Ext_DW.OrbitalState_Velocity == 0)
                goto __CPROVER_DUMP_L20;

              if(DockingApproachExample_Ext_DW.OrbitalState_Attitude == 0)
                goto __CPROVER_DUMP_L20;

              if(DockingApproachExample_Ext_DW.OrbitalState_Time == 0)
                goto __CPROVER_DUMP_L20;

              if(!((signed int)DockingApproachExample_Ext_DW.CaptureApproach_timer < 11))
                goto __CPROVER_DUMP_L20;

              DockingApproachExample_Ext_DW.is_CaptureApproach = (unsigned char)2U;
            }

            else
            {

            __CPROVER_DUMP_L20:
              ;
              if(DockingApproachExample_Ext_DW.CaptureApproach_timer == 11)
              {
                DockingApproachExample_Ext_DW.is_CaptureApproach = (unsigned char)1U;
                DockingApproachExample_Ext_Y.CaptureApproachFailed = (unsigned char)1U;
              }

            }
            break;
          }
          default:
            DockingApproachExample_Ext_DW.is_CaptureApproach = (unsigned char)0U;
        }
      }

      if(DockingApproachExample_Ext_DW.is_MissionPhaseStates == 2)
      {
        if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_OrbitalState_Active == 0U))
          DockingAppr_OrbitalState_Active();

      }

      break;
    }
    case (signed int)(unsigned char)3U:
    {
      if((signed int)DockingApproachExample_Ext_U.StageTransition == 8)
      {
        if(DockingApproachExample_Ext_DW.is_MissionPhaseStates == 3)
        {
          DockingApproachExample_Ext_Y.ApproachOrbitComplete = (unsigned char)0U;
          DockingApproachExample_Ext_Y.ProximityOperationsComplete = (unsigned char)0U;
          DockingApproachExample_Ext_Y.FarApproachComplete = (unsigned char)0U;
          DockingApproachExample_Ext_Y.CaptureApproachComplete = (unsigned char)0U;
          DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)0U;
        }

        if(!(DockingApproachExample_Ext_DW.is_MissionPhaseStates == 6))
        {
          DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)6U;
          DockingApproachExample_Ext_Y.FailedApproach = (unsigned char)1U;
        }

      }

      else
        if((signed int)DockingApproachExample_Ext_U.StageTransition == 6)
        {
          if(DockingApproachExample_Ext_DW.is_MissionPhaseStates == 3)
          {
            DockingApproachExample_Ext_Y.ApproachOrbitComplete = (unsigned char)0U;
            DockingApproachExample_Ext_Y.ProximityOperationsComplete = (unsigned char)0U;
            DockingApproachExample_Ext_Y.FarApproachComplete = (unsigned char)0U;
            DockingApproachExample_Ext_Y.CaptureApproachComplete = (unsigned char)0U;
          }

          DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)1U;
        }

      break;
    }
    case (signed int)(unsigned char)4U:
    {
      if((signed int)DockingApproachExample_Ext_U.StageTransition == 7)
        DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)3U;

      break;
    }
    case (signed int)(unsigned char)5U:
    {
      DockingApproach_DockingApproach();
      break;
    }
    case (signed int)(unsigned char)6U:
      break;
    case (signed int)(unsigned char)7U:
    {
      if((signed int)DockingApproachExample_Ext_U.StageTransition == 5)
        DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)3U;

      else
        if((signed int)DockingApproachExample_Ext_U.StageTransition == 4)
        {
          DockingApproachExample_Ext_Y.FarApproachComplete = (unsigned char)1U;
          DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)2U;
          DockingApproachExample_Ext_DW.is_active_CaptureApproach = (unsigned char)1U;
          if(!(DockingApproachExample_Ext_DW.is_CaptureApproach == 5))
          {
            DockingApproachExample_Ext_DW.is_CaptureApproach = (unsigned char)5U;
            DockingApproachExample_Ext_DW.CaptureApproach_timer = (signed char)0;
            DockingApproachExample_Ext_Y.CaptureApproachFailed = (unsigned char)0U;
          }

          DockingApproachExample_Ext_DW.is_active_OrbitalState_Active = (unsigned char)1U;
          enter_internal_OrbitalState_Act();
        }

      break;
    }
    case (signed int)(unsigned char)8U:
      break;
    case (signed int)(unsigned char)9U:
    {
      if((signed int)DockingApproachExample_Ext_U.StageTransition == 9)
        DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)4U;

      else
        if((signed int)DockingApproachExample_Ext_U.StageTransition == 10)
        {
          DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)8U;
          DockingApproachExample_Ext_Y.JointMission = (unsigned char)1U;
        }

      break;
    }
    case (signed int)(unsigned char)10U:
    {
      if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_LatchCaptureCheck == 0U))
      {
        u = (signed int)DockingApproachExample_Ext_DW.LatchCapture_timer + 1;
        if(u <= 9)
          DockingApproachExample_Ext_DW.LatchCapture_timer = (signed char)u;

        else
          DockingApproachExample_Ext_DW.LatchCapture_timer = (signed char)9;
        switch((signed int)DockingApproachExample_Ext_DW.is_LatchCaptureCheck)
        {
          case (signed int)(unsigned char)1U:
          {
            if(DockingApproachExample_Ext_DW.latch_status == 3)
            {
              DockingApproachExample_Ext_DW.is_LatchCaptureCheck = (unsigned char)3U;
              DockingApproachExample_Ext_Y.LatchCaptureComplete = (unsigned char)1U;
            }

            else
              if(!(DockingApproachExample_Ext_DW.latch_status == 2))
              {
                if(DockingApproachExample_Ext_DW.LatchCapture_timer == 8)
                  goto __CPROVER_DUMP_L48;

              }

              else
              {

              __CPROVER_DUMP_L48:
                ;
                DockingApproachExample_Ext_DW.is_LatchCaptureCheck = (unsigned char)4U;
              }
            break;
          }
          case (signed int)(unsigned char)2U:
          {
            if(DockingApproachExample_Ext_DW.latch_status == 1)
              DockingApproachExample_Ext_DW.is_LatchCaptureCheck = (unsigned char)1U;

            else
              if(DockingApproachExample_Ext_DW.LatchCapture_timer == 8)
                DockingApproachExample_Ext_DW.is_LatchCaptureCheck = (unsigned char)4U;

            break;
          }
          case (signed int)(unsigned char)3U:
          {
            DockingApproachExample_Ext_DW.is_latch = (unsigned char)0U;
            DockingApproachExample_Ext_DW.is_active_latch = (unsigned char)0U;
            DockingApproachExample_Ext_DW.is_LatchCaptureCheck = (unsigned char)0U;
            if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_LatchCaptureCheck == 0U))
            {
              DockingApproachExample_Ext_Y.AttemptingToDock = (unsigned char)0U;
              DockingApproachExample_Ext_DW.is_active_LatchCaptureCheck = (unsigned char)0U;
            }

            DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)9U;
            break;
          }
          case (signed int)(unsigned char)4U:
          {
            DockingApproachExample_Ext_DW.is_latch = (unsigned char)0U;
            DockingApproachExample_Ext_DW.is_active_latch = (unsigned char)0U;
            DockingApproachExample_Ext_DW.is_LatchCaptureCheck = (unsigned char)0U;
            if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_LatchCaptureCheck == 0U))
            {
              DockingApproachExample_Ext_Y.AttemptingToDock = (unsigned char)0U;
              DockingApproachExample_Ext_DW.is_active_LatchCaptureCheck = (unsigned char)0U;
            }

            DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)5U;
            DockingApproachExample_Ext_Y.DockingApproach = (unsigned char)1U;
            DockingApproachExample_Ext_Y.DockingApproachComplete = (unsigned char)0U;
            DockingApproachExample_Ext_DW.is_active_DockingApproach = (unsigned char)1U;
            if(!(DockingApproachExample_Ext_DW.is_DockingApproach == 1))
              DockingApproachExample_Ext_DW.is_DockingApproach = (unsigned char)1U;

            DockingApproachExample_Ext_DW.is_active_dockingSensor = (unsigned char)1U;
            if(!(DockingApproachExample_Ext_DW.is_dockingSensor == 1))
            {
              DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)1U;
              DockingApproachExample_Ext_DW.dockingSensor_RelativePosition = (signed char)0;
              DockingApproachExample_Ext_DW.dockingSensor_RelativeVelocity = (signed char)0;
              DockingApproachExample_Ext_DW.dockingSensor_RelativeAttitude = (signed char)0;
              DockingApproachExample_Ext_DW.dockingSensor_targetState = (signed char)0;
            }

            break;
          }
          default:
            DockingApproachExample_Ext_DW.is_LatchCaptureCheck = (unsigned char)0U;
        }
      }

      if(DockingApproachExample_Ext_DW.is_MissionPhaseStates == 10)
      {
        if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_latch == 0U))
          switch((signed int)DockingApproachExample_Ext_DW.is_latch)
          {
            case (signed int)(unsigned char)1U:
            {
              DockingApproachExample_Ext_DW.is_latch = (unsigned char)5U;
              DockingApproachExample_Ext_DW.latch_status = (signed char)0;
              break;
            }
            case (signed int)(unsigned char)2U:
            {
              DockingApproachExample_Ext_DW.is_latch = (unsigned char)3U;
              DockingApproachExample_Ext_DW.latch_status = (signed char)3;
              break;
            }
            case (signed int)(unsigned char)3U:
            {
              DockingApproachExample_Ext_DW.is_latch = (unsigned char)5U;
              DockingApproachExample_Ext_DW.latch_status = (signed char)0;
              break;
            }
            case (signed int)(unsigned char)4U:
            {
              DockingApproachExample_Ext_DW.is_latch = (unsigned char)2U;
              DockingApproachExample_Ext_DW.latch_status = (signed char)0;
              break;
            }
            case (signed int)(unsigned char)5U:
            {
              DockingApproachExample_Ext_DW.is_latch = (unsigned char)4U;
              DockingApproachExample_Ext_DW.latch_status = (signed char)1;
              break;
            }
            default:
              DockingApproachExample_Ext_DW.is_latch = (unsigned char)0U;
          }

      }

      break;
    }
    case (signed int)(unsigned char)11U:
    {
      if((signed int)DockingApproachExample_Ext_U.StageTransition == 1)
      {
        DockingApproachExample_Ext_Y.ApproachOrbitComplete = (unsigned char)0U;
        DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)1U;
      }

      else
        if((signed int)DockingApproachExample_Ext_U.StageTransition == 3)
        {
          DockingApproachExample_Ext_Y.ProximityOperationsComplete = (unsigned char)1U;
          DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)7U;
        }

      break;
    }
    case (signed int)(unsigned char)12U:
    {
      if((signed int)DockingApproachExample_Ext_U.StageTransition == 0)
        DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)1U;

      break;
    }
    default:
      DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)0U;
  }
}

// DockingApproachExample_Ext
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2352
struct tag_RTM_DockingApproachExampl_T * DockingApproachExample_Ext(void)
{
  rt_InitInfAndNaN(sizeof(double)  );
  /*memset((void *)DockingApproachExample_Ext_M, 0, sizeof(struct tag_RTM_DockingApproachExampl_T)  );
  signed int *mdlTsMap = DockingApproachExample_Ext_M->Timing.sampleTimeTaskIDArray;
  mdlTsMap[(signed long int)0] = 0;
  DockingApproachExample_Ext_M->Timing.sampleTimeTaskIDPtr = &mdlTsMap[(signed long int)0];
  DockingApproachExample_Ext_M->Timing.sampleTimes = &DockingApproachExample_Ext_M->Timing.sampleTimesArray[(signed long int)0];
  DockingApproachExample_Ext_M->Timing.offsetTimes = &DockingApproachExample_Ext_M->Timing.offsetTimesArray[(signed long int)0];
  DockingApproachExample_Ext_M->Timing.sampleTimes[(signed long int)0] = 1.0;
  DockingApproachExample_Ext_M->Timing.offsetTimes[(signed long int)0] = 0.0;
  DockingApproachExample_Ext_M->Timing.t = &DockingApproachExample_Ext_M->Timing.tArray[(signed long int)0];
  signed int *mdlSampleHits = DockingApproachExample_Ext_M->Timing.sampleHitArray;
  mdlSampleHits[(signed long int)0] = 1;
  DockingApproachExample_Ext_M->Timing.sampleHits = &mdlSampleHits[(signed long int)0];
  DockingApproachExample_Ext_M->Timing.tFinal = 300.0;
  DockingApproachExample_Ext_M->Timing.stepSize0 = 1.0;
  static struct _RTWLogInfo_tag rt_DataLoggingInfo;
  DockingApproachExample_Ext_M->rtwLogInfo = &rt_DataLoggingInfo;
  DockingApproachExample_Ext_M->rtwLogInfo->logXSignalInfo.cptr = (const struct RTWLogSignalInfo_tag *)(void *)0;
  DockingApproachExample_Ext_M->rtwLogInfo->logXSignalPtrs.cptr = (const signed char * const *)(void *)0;
  DockingApproachExample_Ext_M->rtwLogInfo->logT = "tout";
  DockingApproachExample_Ext_M->rtwLogInfo->logX = "";
  DockingApproachExample_Ext_M->rtwLogInfo->logXFinal = "";
  DockingApproachExample_Ext_M->rtwLogInfo->logSL = "";
  DockingApproachExample_Ext_M->rtwLogInfo->logVarNameModifier = "rt_";
  DockingApproachExample_Ext_M->rtwLogInfo->logFormat = 0;
  DockingApproachExample_Ext_M->rtwLogInfo->logMaxRows = 1000;
  DockingApproachExample_Ext_M->rtwLogInfo->logDecimation = 1;
  static void *rt_LoggedOutputSignalPtrs[11l] = { (void *)&DockingApproachExample_Ext_Y.CaptureApproachComplete,
    (void *)&DockingApproachExample_Ext_Y.DockingApproachComplete,
    (void *)&DockingApproachExample_Ext_Y.AttemptingToDock,
    (void *)&DockingApproachExample_Ext_Y.LatchCaptureComplete,
    (void *)&DockingApproachExample_Ext_Y.DockingApproach,
    (void *)&DockingApproachExample_Ext_Y.ApproachOrbitComplete,
    (void *)&DockingApproachExample_Ext_Y.FarApproachComplete,
    (void *)&DockingApproachExample_Ext_Y.ProximityOperationsComplete,
    (void *)&DockingApproachExample_Ext_Y.FailedApproach,
    (void *)&DockingApproachExample_Ext_Y.JointMission,
    (void *)&DockingApproachExample_Ext_Y.CaptureApproachFailed };
  DockingApproachExample_Ext_M->rtwLogInfo->logYSignalPtrs.cptr = (const signed char * const *)rt_LoggedOutputSignalPtrs;
  static struct RTWLogDataTypeConvert_tag rt_RTWLogDataTypeConvert[11l] = { { .conversionNeeded=0, .dataTypeIdLoggingTo=(enum anonymous$35)SS_BOOLEAN, .dataTypeIdOriginal=SS_BOOLEAN,
    .bitsPerChunk=0, .numOfChunk=0,
    .isSigned=(unsigned int)0, .fracSlope=1.0,
    .fixedExp=0, .bias=0.0 },
    { .conversionNeeded=0, .dataTypeIdLoggingTo=(enum anonymous$35)SS_BOOLEAN, .dataTypeIdOriginal=SS_BOOLEAN,
    .bitsPerChunk=0, .numOfChunk=0,
    .isSigned=(unsigned int)0, .fracSlope=1.0,
    .fixedExp=0, .bias=0.0 },
    { .conversionNeeded=0, .dataTypeIdLoggingTo=(enum anonymous$35)SS_BOOLEAN, .dataTypeIdOriginal=SS_BOOLEAN,
    .bitsPerChunk=0, .numOfChunk=0,
    .isSigned=(unsigned int)0, .fracSlope=1.0,
    .fixedExp=0, .bias=0.0 },
    { .conversionNeeded=0, .dataTypeIdLoggingTo=(enum anonymous$35)SS_BOOLEAN, .dataTypeIdOriginal=SS_BOOLEAN,
    .bitsPerChunk=0, .numOfChunk=0,
    .isSigned=(unsigned int)0, .fracSlope=1.0,
    .fixedExp=0, .bias=0.0 },
    { .conversionNeeded=0, .dataTypeIdLoggingTo=(enum anonymous$35)SS_BOOLEAN, .dataTypeIdOriginal=SS_BOOLEAN,
    .bitsPerChunk=0, .numOfChunk=0,
    .isSigned=(unsigned int)0, .fracSlope=1.0,
    .fixedExp=0, .bias=0.0 },
    { .conversionNeeded=0, .dataTypeIdLoggingTo=(enum anonymous$35)SS_BOOLEAN, .dataTypeIdOriginal=SS_BOOLEAN,
    .bitsPerChunk=0, .numOfChunk=0,
    .isSigned=(unsigned int)0, .fracSlope=1.0,
    .fixedExp=0, .bias=0.0 },
    { .conversionNeeded=0, .dataTypeIdLoggingTo=(enum anonymous$35)SS_BOOLEAN, .dataTypeIdOriginal=SS_BOOLEAN,
    .bitsPerChunk=0, .numOfChunk=0,
    .isSigned=(unsigned int)0, .fracSlope=1.0,
    .fixedExp=0, .bias=0.0 },
    { .conversionNeeded=0, .dataTypeIdLoggingTo=(enum anonymous$35)SS_BOOLEAN, .dataTypeIdOriginal=SS_BOOLEAN,
    .bitsPerChunk=0, .numOfChunk=0,
    .isSigned=(unsigned int)0, .fracSlope=1.0,
    .fixedExp=0, .bias=0.0 },
    { .conversionNeeded=0, .dataTypeIdLoggingTo=(enum anonymous$35)SS_BOOLEAN, .dataTypeIdOriginal=SS_BOOLEAN,
    .bitsPerChunk=0, .numOfChunk=0,
    .isSigned=(unsigned int)0, .fracSlope=1.0,
    .fixedExp=0, .bias=0.0 },
    { .conversionNeeded=0, .dataTypeIdLoggingTo=(enum anonymous$35)SS_BOOLEAN, .dataTypeIdOriginal=SS_BOOLEAN,
    .bitsPerChunk=0, .numOfChunk=0,
    .isSigned=(unsigned int)0, .fracSlope=1.0,
    .fixedExp=0, .bias=0.0 },
    { .conversionNeeded=0, .dataTypeIdLoggingTo=(enum anonymous$35)SS_BOOLEAN, .dataTypeIdOriginal=SS_BOOLEAN,
    .bitsPerChunk=0, .numOfChunk=0,
    .isSigned=(unsigned int)0, .fracSlope=1.0,
    .fixedExp=0, .bias=0.0 } };
  static const char *rt_LoggedOutputBlockNames[11l] = { "DockingApproachExample_Ext/CaptureApproachComplete",
    "DockingApproachExample_Ext/DockingApproachComplete",
    "DockingApproachExample_Ext/AttemptingToDock",
    "DockingApproachExample_Ext/LatchCaptureComplete",
    "DockingApproachExample_Ext/DockingApproach",
    "DockingApproachExample_Ext/ApproachOrbitComplete",
    "DockingApproachExample_Ext/FarApproachComplete",
    "DockingApproachExample_Ext/ProximityOperationsComplete",
    "DockingApproachExample_Ext/FailedApproach",
    "DockingApproachExample_Ext/JointMission",
    "DockingApproachExample_Ext/CaptureApproachFailed" };
  static const char *rt_LoggedOutputLabels[11l] = { "", "", "", "", "", "", "", "", "", "", "" };
  static signed int rt_LoggedOutputComplexSignals[11l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  static enum anonymous$35 rt_LoggedOutputDataTypeIds[11l] = { (enum anonymous$35)SS_BOOLEAN, (enum anonymous$35)SS_BOOLEAN, (enum anonymous$35)SS_BOOLEAN, (enum anonymous$35)SS_BOOLEAN, (enum anonymous$35)SS_BOOLEAN, (enum anonymous$35)SS_BOOLEAN, (enum anonymous$35)SS_BOOLEAN, (enum anonymous$35)SS_BOOLEAN, (enum anonymous$35)SS_BOOLEAN, (enum anonymous$35)SS_BOOLEAN, (enum anonymous$35)SS_BOOLEAN };
  static signed int rt_LoggedCurrentSignalDimensionsSize[11l] = { 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
  static void *rt_LoggedCurrentSignalDimensions[11l] = { (void *)0, (void *)0, (void *)0, (void *)0, (void *)0, (void *)0, (void *)0, (void *)0, (void *)0, (void *)0, (void *)0 };
  static unsigned char rt_LoggedOutputIsVarDims[11l] = { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
  static signed int rt_LoggedOutputDimensions[11l] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
  static signed int rt_LoggedOutputNumDimensions[11l] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
  static signed int rt_LoggedOutputWidths[11l] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
  static struct RTWLogSignalInfo_tag rt_LoggedOutputSignalInfo[1l] = { { .numSignals=11, .numCols=rt_LoggedOutputWidths, .numDims=rt_LoggedOutputNumDimensions,
    .dims=rt_LoggedOutputDimensions,
    .isVarDims=rt_LoggedOutputIsVarDims, .currSigDims=rt_LoggedCurrentSignalDimensions,
    .currSigDimsSize=rt_LoggedCurrentSignalDimensionsSize,
    .dataTypes=rt_LoggedOutputDataTypeIds,
    .complexSignals=rt_LoggedOutputComplexSignals,
    .frameData=(signed int *)(void *)0,
    .labels={ .cptr=rt_LoggedOutputLabels }, .titles=(char *)(void *)0,
    .titleLengths=(signed int *)(void *)0, .plotStyles=(signed int *)(void *)0,
    .blockNames={ .cptr=rt_LoggedOutputBlockNames },
    .stateNames={ .cptr=(const char **)(void *)0 },
    .crossMdlRef=(unsigned char *)(void *)0,
    .dataTypeConvert=rt_RTWLogDataTypeConvert } };
  DockingApproachExample_Ext_M->rtwLogInfo->logYSignalInfo.cptr = rt_LoggedOutputSignalInfo;
  rt_LoggedCurrentSignalDimensions[(signed long int)0] = (void *)&rt_LoggedOutputWidths[(signed long int)0];
  rt_LoggedCurrentSignalDimensions[(signed long int)1] = (void *)&rt_LoggedOutputWidths[(signed long int)1];
  rt_LoggedCurrentSignalDimensions[(signed long int)2] = (void *)&rt_LoggedOutputWidths[(signed long int)2];
  rt_LoggedCurrentSignalDimensions[(signed long int)3] = (void *)&rt_LoggedOutputWidths[(signed long int)3];
  rt_LoggedCurrentSignalDimensions[(signed long int)4] = (void *)&rt_LoggedOutputWidths[(signed long int)4];
  rt_LoggedCurrentSignalDimensions[(signed long int)5] = (void *)&rt_LoggedOutputWidths[(signed long int)5];
  rt_LoggedCurrentSignalDimensions[(signed long int)6] = (void *)&rt_LoggedOutputWidths[(signed long int)6];
  rt_LoggedCurrentSignalDimensions[(signed long int)7] = (void *)&rt_LoggedOutputWidths[(signed long int)7];
  rt_LoggedCurrentSignalDimensions[(signed long int)8] = (void *)&rt_LoggedOutputWidths[(signed long int)8];
  rt_LoggedCurrentSignalDimensions[(signed long int)9] = (void *)&rt_LoggedOutputWidths[(signed long int)9];
  rt_LoggedCurrentSignalDimensions[(signed long int)10] = (void *)&rt_LoggedOutputWidths[(signed long int)10];
  DockingApproachExample_Ext_M->rtwLogInfo->logY = "yout";
  DockingApproachExample_Ext_M->solverInfoPtr = &DockingApproachExample_Ext_M->solverInfo;
  DockingApproachExample_Ext_M->Timing.stepSize = 1.0;
  (&DockingApproachExample_Ext_M->solverInfo)->fixedStepSize = 1.0;
  (&DockingApproachExample_Ext_M->solverInfo)->solverMode = (enum anonymous$43)SOLVER_MODE_SINGLETASKING;
  DockingApproachExample_Ext_M->ModelData.dwork = (void *)&DockingApproachExample_Ext_DW;
  memset((void *)&DockingApproachExample_Ext_DW, 0, sizeof(struct anonymous$10)  );
  DockingApproachExample_Ext_M->ModelData.inputs = (void *)&DockingApproachExample_Ext_U;
  memset((void *)&DockingApproachExample_Ext_U, 0, sizeof(struct anonymous$11) );
  DockingApproachExample_Ext_M->ModelData.outputs = (void *)&DockingApproachExample_Ext_Y;
  memset((void *)&DockingApproachExample_Ext_Y, 0, sizeof(struct anonymous$13)  );
  DockingApproachExample_Ext_M->Sizes.numContStates = 0;
  DockingApproachExample_Ext_M->Sizes.numY = 11;
  DockingApproachExample_Ext_M->Sizes.numU = 13;
  DockingApproachExample_Ext_M->Sizes.sysDirFeedThru = 1;
  DockingApproachExample_Ext_M->Sizes.numSampTimes = 1;
  DockingApproachExample_Ext_M->Sizes.numBlocks = 13;
  DockingApproachExample_Ext_M->Sizes.numBlockIO = 11;*/
  return DockingApproachExample_Ext_M;
}

// DockingApproachExample_Ext_initialize
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2176
void DockingApproachExample_Ext_initialize(void)
{
  DockingApproachExample_Ext_DW.sfEvent = -1;
  DockingApproachExample_Ext_DW.is_active_MissionPhaseStates = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_CaptureApproach = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_CaptureApproach = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_OrbitalState_Active = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_GPS = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_GPS = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_InertialNavigation = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_InertialNavigation = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_OrbitalState_Complex = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_OrbitalState = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_OrbitalState = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_OrbitalState2 = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_OrbitalState2 = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_StarPlanetTracker = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_StarPlanetTracker = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_DockingApproach = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_DockingApproach = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_dockingSensor = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_LatchCaptureCheck = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_LatchCaptureCheck = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_latch = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_latch = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_fuel = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_thrust = (unsigned char)0U;
  DockingApproachExample_Ext_DW.is_active_c1_DockingApproachExa = (unsigned char)0U;
  DockingApproachExample_Ext_DW.OrbitalState_Position = (signed char)0;
  DockingApproachExample_Ext_DW.OrbitalState_Velocity = (signed char)0;
  DockingApproachExample_Ext_DW.OrbitalState_Attitude = (signed char)0;
  DockingApproachExample_Ext_DW.OrbitalState_Time = (signed char)0;
  DockingApproachExample_Ext_DW.InertialNavigation_AbsolutePosi = (signed char)0;
  DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteAtti = (signed char)0;
  DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteVelo = (signed char)0;
  DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity = (signed char)0;
  DockingApproachExample_Ext_DW.GPS_AbsoluteTime = (signed char)0;
  DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteAttit = (signed char)0;
  DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit = (signed char)0;
  DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteTime = (signed char)0;
  DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc = (signed char)0;
  DockingApproachExample_Ext_DW.GPS_AbsolutePosition = (signed char)0;
  DockingApproachExample_Ext_DW.dockingSensor_RelativePosition = (signed char)0;
  DockingApproachExample_Ext_DW.dockingSensor_RelativeVelocity = (signed char)0;
  DockingApproachExample_Ext_DW.dockingSensor_RelativeAttitude = (signed char)0;
  DockingApproachExample_Ext_DW.dockingSensor_targetState = (signed char)0;
  DockingApproachExample_Ext_DW.thrust_status = (signed char)0;
  DockingApproachExample_Ext_DW.fuel_status = (signed char)0;
  DockingApproachExample_Ext_DW.DockingApproach_timer = (signed char)0;
  DockingApproachExample_Ext_DW.CaptureApproach_timer = (signed char)0;
  DockingApproachExample_Ext_DW.latch_status = (signed char)0;
  DockingApproachExample_Ext_DW.LatchCapture_timer = (signed char)0;
  DockingApproachExample_Ext_DW.dockingSensor_timer = (signed char)0;
  DockingApproachExample_Ext_DW.InertialNavigation_timer = (signed char)0;
  DockingApproachExample_Ext_DW.StarPlanetTracker_timer = (signed char)0;
  DockingApproachExample_Ext_DW.GPS_timer = (signed char)0;
  DockingApproachExample_Ext_DW.VALID = (unsigned char)0U;
  DockingApproachExample_Ext_Y.CaptureApproachComplete = (unsigned char)0U;
  DockingApproachExample_Ext_Y.DockingApproachComplete = (unsigned char)0U;
  DockingApproachExample_Ext_Y.AttemptingToDock = (unsigned char)0U;
  DockingApproachExample_Ext_Y.LatchCaptureComplete = (unsigned char)0U;
  DockingApproachExample_Ext_Y.DockingApproach = (unsigned char)0U;
  DockingApproachExample_Ext_Y.ApproachOrbitComplete = (unsigned char)0U;
  DockingApproachExample_Ext_Y.FarApproachComplete = (unsigned char)0U;
  DockingApproachExample_Ext_Y.ProximityOperationsComplete = (unsigned char)0U;
  DockingApproachExample_Ext_Y.FailedApproach = (unsigned char)0U;
  DockingApproachExample_Ext_Y.JointMission = (unsigned char)0U;
  DockingApproachExample_Ext_Y.CaptureApproachFailed = (unsigned char)0U;
}

// DockingApproachExample_Ext_output
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2123
static void DockingApproachExample_Ext_output(void)
{
  DockingApproachExample_Ext_DW.sfEvent = -1;
  if((unsigned int)DockingApproachExample_Ext_DW.is_active_c1_DockingApproachExa == 0U)
  {
    DockingApproachExample_Ext_DW.is_active_c1_DockingApproachExa = (unsigned char)1U;
    DockingApproachExample_Ext_DW.is_active_MissionPhaseStates = (unsigned char)1U;
    DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)12U;
    DockingApproachExample_Ext_DW.is_active_thrust = (unsigned char)1U;
    DockingApproachExample_Ext_DW.is_active_fuel = (unsigned char)1U;
  }

  else
    if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_MissionPhaseStates == 0U))
      DockingAppro_MissionPhaseStates();

}

// DockingApproachExample_Ext_terminate
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2303
void DockingApproachExample_Ext_terminate(void)
{
  ;
}

// DockingApproachExample_Ext_update
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2153
static void DockingApproachExample_Ext_update(void)
{
  DockingApproachExample_Ext_M->Timing.clockTick0 = DockingApproachExample_Ext_M->Timing.clockTick0 + 1u;
  if(DockingApproachExample_Ext_M->Timing.clockTick0 == 0u)
    DockingApproachExample_Ext_M->Timing.clockTickH0 = DockingApproachExample_Ext_M->Timing.clockTickH0 + 1u;

  DockingApproachExample_Ext_M->Timing.t[(signed long int)0] = (double)DockingApproachExample_Ext_M->Timing.clockTick0 * DockingApproachExample_Ext_M->Timing.stepSize0 + (double)DockingApproachExample_Ext_M->Timing.clockTickH0 * DockingApproachExample_Ext_M->Timing.stepSize0 * 4294967296.0;
}

// DockingApproach_DockingApproach
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 1136
static void DockingApproach_DockingApproach(void)
{
  signed int u;
  if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_DockingApproach == 0U))
  {
    u = (signed int)DockingApproachExample_Ext_DW.DockingApproach_timer + 1;
    if(u <= 9)
      DockingApproachExample_Ext_DW.DockingApproach_timer = (signed char)u;

    else
      DockingApproachExample_Ext_DW.DockingApproach_timer = (signed char)9;
    switch((signed int)DockingApproachExample_Ext_DW.is_DockingApproach)
    {
      case (signed int)(unsigned char)1U:
      {
        if(DockingApproachExample_Ext_DW.dockingSensor_RelativePosition == 2)
        {
          if(!(DockingApproachExample_Ext_DW.dockingSensor_RelativeVelocity == 2))
            goto __CPROVER_DUMP_L4;

          if(!(DockingApproachExample_Ext_DW.dockingSensor_RelativeAttitude == 2))
            goto __CPROVER_DUMP_L4;

          if(!(DockingApproachExample_Ext_DW.dockingSensor_targetState == 2))
            goto __CPROVER_DUMP_L4;

          DockingApproachExample_Ext_DW.is_DockingApproach = (unsigned char)4U;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          if(DockingApproachExample_Ext_DW.dockingSensor_RelativePosition == 1)
          {
            if(!(DockingApproachExample_Ext_DW.dockingSensor_RelativeVelocity == 1))
              goto __CPROVER_DUMP_L5;

            if(!(DockingApproachExample_Ext_DW.dockingSensor_RelativeAttitude == 1))
              goto __CPROVER_DUMP_L5;

            if(!(DockingApproachExample_Ext_DW.dockingSensor_targetState == 1))
              goto __CPROVER_DUMP_L5;

            DockingApproachExample_Ext_DW.is_DockingApproach = (unsigned char)2U;
          }

          else
          {

          __CPROVER_DUMP_L5:
            ;
            if(DockingApproachExample_Ext_DW.DockingApproach_timer == 9)
              DockingApproachExample_Ext_DW.is_DockingApproach = (unsigned char)3U;

            else
            {
              if(!(DockingApproachExample_Ext_DW.dockingSensor_RelativePosition == 0))
              {
                if(DockingApproachExample_Ext_DW.dockingSensor_RelativeVelocity == 0)
                  goto __CPROVER_DUMP_L7;

                if(DockingApproachExample_Ext_DW.dockingSensor_RelativeAttitude == 0)
                  goto __CPROVER_DUMP_L7;

              }

              else
              {

              __CPROVER_DUMP_L7:
                ;
                DockingApproachExample_Ext_DW.is_DockingApproach = (unsigned char)3U;
                goto __CPROVER_DUMP_L9;
              }
              if(!(DockingApproachExample_Ext_DW.dockingSensor_targetState == 2))
                DockingApproachExample_Ext_DW.is_DockingApproach = (unsigned char)3U;

            }
          }
        }

      __CPROVER_DUMP_L9:
        ;
        break;
      }
      case (signed int)(unsigned char)2U:
      {
        if((unsigned int)DockingApproachExample_Ext_DW.thrust_status == 1U)
        {
          if(!(DockingApproachExample_Ext_DW.fuel_status == 2))
            goto __CPROVER_DUMP_L11;

          DockingApproachExample_Ext_DW.is_DockingApproach = (unsigned char)1U;
        }

        else
        {

        __CPROVER_DUMP_L11:
          ;
          if((unsigned int)DockingApproachExample_Ext_DW.thrust_status == 1U)
          {
            if(!(DockingApproachExample_Ext_DW.fuel_status == 2))
              goto __CPROVER_DUMP_L12;

            if(DockingApproachExample_Ext_DW.DockingApproach_timer == 9)
              goto __CPROVER_DUMP_L12;

          }

          else
          {

          __CPROVER_DUMP_L12:
            ;
            DockingApproachExample_Ext_DW.is_DockingApproach = (unsigned char)3U;
          }
        }
        break;
      }
      case (signed int)(unsigned char)3U:
      {
        D_exit_internal_DockingApproach();
        if(DockingApproachExample_Ext_DW.is_MissionPhaseStates == 5)
          DockingApproachExample_Ext_Y.DockingApproach = (unsigned char)0U;

        DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)2U;
        DockingApproachExample_Ext_DW.is_active_CaptureApproach = (unsigned char)1U;
        DockingApproachExample_Ext_DW.is_CaptureApproach = (unsigned char)2U;
        DockingApproachExample_Ext_DW.is_active_OrbitalState_Active = (unsigned char)1U;
        enter_internal_OrbitalState_Act();
        break;
      }
      case (signed int)(unsigned char)4U:
      {
        D_exit_internal_DockingApproach();
        if(DockingApproachExample_Ext_DW.is_MissionPhaseStates == 5)
          DockingApproachExample_Ext_Y.DockingApproach = (unsigned char)0U;

        DockingApproachExample_Ext_DW.is_MissionPhaseStates = (unsigned char)10U;
        if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_LatchCaptureCheck == 1U))
        {
          DockingApproachExample_Ext_DW.is_active_LatchCaptureCheck = (unsigned char)1U;
          DockingApproachExample_Ext_Y.AttemptingToDock = (unsigned char)1U;
        }

        if(!(DockingApproachExample_Ext_DW.is_LatchCaptureCheck == 2))
        {
          DockingApproachExample_Ext_DW.is_LatchCaptureCheck = (unsigned char)2U;
          DockingApproachExample_Ext_DW.LatchCapture_timer = (signed char)0;
        }

        DockingApproachExample_Ext_DW.is_active_latch = (unsigned char)1U;
        if(!(DockingApproachExample_Ext_DW.is_latch == 5))
        {
          DockingApproachExample_Ext_DW.is_latch = (unsigned char)5U;
          DockingApproachExample_Ext_DW.latch_status = (signed char)0;
        }

        break;
      }
      case (signed int)(unsigned char)5U:
      {
        if(!(DockingApproachExample_Ext_DW.dockingSensor_RelativePosition == 0))
        {
          if(DockingApproachExample_Ext_DW.dockingSensor_RelativeVelocity == 0)
            goto __CPROVER_DUMP_L22;

          if(DockingApproachExample_Ext_DW.dockingSensor_RelativeAttitude == 0)
            goto __CPROVER_DUMP_L22;

          if(!((signed int)DockingApproachExample_Ext_DW.DockingApproach_timer < 9))
            goto __CPROVER_DUMP_L22;

          DockingApproachExample_Ext_DW.is_DockingApproach = (unsigned char)1U;
        }

        else
        {

        __CPROVER_DUMP_L22:
          ;
          if(DockingApproachExample_Ext_DW.DockingApproach_timer == 9)
            DockingApproachExample_Ext_DW.is_DockingApproach = (unsigned char)3U;

        }
        break;
      }
      default:
        DockingApproachExample_Ext_DW.is_DockingApproach = (unsigned char)0U;
    }
  }

  if(DockingApproachExample_Ext_DW.is_MissionPhaseStates == 5)
  {
    if(!((unsigned int)DockingApproachExample_Ext_DW.is_active_dockingSensor == 0U))
    {
      u = (signed int)DockingApproachExample_Ext_DW.dockingSensor_timer + 1;
      if(u <= 6)
        DockingApproachExample_Ext_DW.dockingSensor_timer = (signed char)u;

      else
        DockingApproachExample_Ext_DW.dockingSensor_timer = (signed char)6;
      switch((signed int)DockingApproachExample_Ext_DW.is_dockingSensor)
      {
        case (signed int)(unsigned char)1U:
        {
          if(!(DockingApproachExample_Ext_U.dockVisibility_status == 0))
          {
            if(DockingApproachExample_Ext_U.opticsAvailability_status == 0)
              goto __CPROVER_DUMP_L31;

            if(DockingApproachExample_Ext_DW.is_dockingSensor == 1)
            {
              DockingApproachExample_Ext_DW.dockingSensor_timer = (signed char)0;
              DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)0U;
            }

            if(!(DockingApproachExample_Ext_DW.is_dockingSensor == 3))
            {
              DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)3U;
              DockingApproachExample_Ext_DW.dockingSensor_RelativePosition = (signed char)1;
              DockingApproachExample_Ext_DW.dockingSensor_RelativeVelocity = (signed char)1;
              DockingApproachExample_Ext_DW.dockingSensor_RelativeAttitude = (signed char)1;
              DockingApproachExample_Ext_DW.dockingSensor_targetState = (signed char)1;
            }

          }

          else
          {

          __CPROVER_DUMP_L31:
            ;
            if(!(DockingApproachExample_Ext_U.dockVisibility_status == 0))
            {
              if(DockingApproachExample_Ext_U.opticsAvailability_status == 0)
                goto __CPROVER_DUMP_L32;

            }

            else
            {

            __CPROVER_DUMP_L32:
              ;
              if(DockingApproachExample_Ext_DW.is_dockingSensor == 1)
              {
                DockingApproachExample_Ext_DW.dockingSensor_timer = (signed char)0;
                DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)0U;
              }

              if(!(DockingApproachExample_Ext_DW.is_dockingSensor == 1))
              {
                DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)1U;
                DockingApproachExample_Ext_DW.dockingSensor_RelativePosition = (signed char)0;
                DockingApproachExample_Ext_DW.dockingSensor_RelativeVelocity = (signed char)0;
                DockingApproachExample_Ext_DW.dockingSensor_RelativeAttitude = (signed char)0;
                DockingApproachExample_Ext_DW.dockingSensor_targetState = (signed char)0;
              }

            }
          }
          break;
        }
        case (signed int)(unsigned char)2U:
        {
          if(!(DockingApproachExample_Ext_U.dockVisibility_status == 2))
          {
            if(DockingApproachExample_Ext_U.opticsAvailability_status != 0)
              goto __CPROVER_DUMP_L36;

          }

          else
          {

          __CPROVER_DUMP_L36:
            ;
            if(DockingApproachExample_Ext_U.sunlight_status == 0)
              goto __CPROVER_DUMP_L40;

          }
          if(DockingApproachExample_Ext_DW.is_dockingSensor == 2)
          {
            DockingApproachExample_Ext_DW.dockingSensor_timer = (signed char)0;
            DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)0U;
          }

          if(!(DockingApproachExample_Ext_DW.is_dockingSensor == 3))
          {
            DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)3U;
            DockingApproachExample_Ext_DW.dockingSensor_RelativePosition = (signed char)1;
            DockingApproachExample_Ext_DW.dockingSensor_RelativeVelocity = (signed char)1;
            DockingApproachExample_Ext_DW.dockingSensor_RelativeAttitude = (signed char)1;
            DockingApproachExample_Ext_DW.dockingSensor_targetState = (signed char)1;
          }

          goto __CPROVER_DUMP_L42;

        __CPROVER_DUMP_L40:
          ;
          if(DockingApproachExample_Ext_U.dockVisibility_status == 2)
          {
            if(!(DockingApproachExample_Ext_U.opticsAvailability_status == 0))
            {
              if(DockingApproachExample_Ext_U.sunlight_status == 0)
              {
                if(DockingApproachExample_Ext_DW.is_dockingSensor == 2)
                {
                  DockingApproachExample_Ext_DW.dockingSensor_timer = (signed char)0;
                  DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)0U;
                }

                if(!(DockingApproachExample_Ext_DW.is_dockingSensor == 2))
                {
                  DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)2U;
                  DockingApproachExample_Ext_DW.dockingSensor_RelativePosition = (signed char)2;
                  DockingApproachExample_Ext_DW.dockingSensor_RelativeVelocity = (signed char)2;
                  DockingApproachExample_Ext_DW.dockingSensor_RelativeAttitude = (signed char)2;
                  DockingApproachExample_Ext_DW.dockingSensor_targetState = (signed char)2;
                }

              }

            }

          }


        __CPROVER_DUMP_L42:
          ;
          break;
        }
        case (signed int)(unsigned char)3U:
        {
          if(DockingApproachExample_Ext_DW.dockingSensor_timer == 6)
          {
            if(!(DockingApproachExample_Ext_U.dockVisibility_status == 0))
            {
              if(!(DockingApproachExample_Ext_U.opticsAvailability_status == 0))
                goto __CPROVER_DUMP_L45;

            }

            DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)1U;
            DockingApproachExample_Ext_DW.dockingSensor_RelativePosition = (signed char)0;
            DockingApproachExample_Ext_DW.dockingSensor_RelativeVelocity = (signed char)0;
            DockingApproachExample_Ext_DW.dockingSensor_RelativeAttitude = (signed char)0;
            DockingApproachExample_Ext_DW.dockingSensor_targetState = (signed char)0;
          }

          else
          {

          __CPROVER_DUMP_L45:
            ;
            if((signed int)DockingApproachExample_Ext_DW.dockingSensor_timer < 6)
            {
              if(!(DockingApproachExample_Ext_U.dockVisibility_status == 2))
                goto __CPROVER_DUMP_L46;

              if(DockingApproachExample_Ext_U.opticsAvailability_status == 0)
                goto __CPROVER_DUMP_L46;

              if(DockingApproachExample_Ext_U.sunlight_status != 0)
                goto __CPROVER_DUMP_L46;

              DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)2U;
              DockingApproachExample_Ext_DW.dockingSensor_RelativePosition = (signed char)2;
              DockingApproachExample_Ext_DW.dockingSensor_RelativeVelocity = (signed char)2;
              DockingApproachExample_Ext_DW.dockingSensor_RelativeAttitude = (signed char)2;
              DockingApproachExample_Ext_DW.dockingSensor_targetState = (signed char)2;
            }

            else
            {

            __CPROVER_DUMP_L46:
              ;
              if((signed int)DockingApproachExample_Ext_DW.dockingSensor_timer < 6)
              {
                if(!(DockingApproachExample_Ext_U.dockVisibility_status == 0))
                {
                  if(!(DockingApproachExample_Ext_U.opticsAvailability_status == 0))
                    goto __CPROVER_DUMP_L48;

                }

              }

              else
              {

              __CPROVER_DUMP_L48:
                ;
                if(!(DockingApproachExample_Ext_U.opticsAvailability_status == 0))
                {
                  if(!(DockingApproachExample_Ext_U.dockVisibility_status == 1))
                  {
                    if(DockingApproachExample_Ext_U.sunlight_status == 0)
                      goto __CPROVER_DUMP_L50;

                  }

                }

                else
                {

                __CPROVER_DUMP_L50:
                  ;
                  goto __CPROVER_DUMP_L52;
                }
              }
              DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)3U;
              DockingApproachExample_Ext_DW.dockingSensor_RelativePosition = (signed char)1;
              DockingApproachExample_Ext_DW.dockingSensor_RelativeVelocity = (signed char)1;
              DockingApproachExample_Ext_DW.dockingSensor_RelativeAttitude = (signed char)1;
              DockingApproachExample_Ext_DW.dockingSensor_targetState = (signed char)1;
            }
          }

        __CPROVER_DUMP_L52:
          ;
          break;
        }
        default:
          DockingApproachExample_Ext_DW.is_dockingSensor = (unsigned char)0U;
      }
    }

  }

}

// MdlInitialize
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2337
void MdlInitialize(void)
{
  ;
}

// MdlInitializeSampleTimes
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2333
void MdlInitializeSampleTimes(void)
{
  ;
}

// MdlInitializeSizes
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2329
void MdlInitializeSizes(void)
{
  ;
}

// MdlOutputs
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2311
void MdlOutputs(signed int tid)
{
  DockingApproachExample_Ext_output();
  (void)tid;
}

// MdlStart
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2341
void MdlStart(void)
{
  DockingApproachExample_Ext_initialize();
}

// MdlTerminate
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2346
void MdlTerminate(void)
{
  DockingApproachExample_Ext_terminate();
}

// MdlUpdate
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 2320
void MdlUpdate(signed int tid)
{
  DockingApproachExample_Ext_update();
  (void)tid;
}

// displayUsage
// file ../R2013a/rtw/c/grt/classic_main.c line 382
static void displayUsage(void)
{
  //printf("usage: %s -tf <finaltime> -w -port <TCPport>\n", (const void *)"DockingApproachExample_Ext");
  //printf("arguments:\n");
  //printf("  -tf <finaltime> - overrides final time specified in Simulink (inf for no limit).\n");
  //printf("  -w              - waits for Simulink to start model in External Mode.\n");
  //printf("  -port <TCPport> - overrides 17725 default port in External Mode, valid range 256 to 65535.\n");
}

// enter_internal_OrbitalState_Act
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/DockingApproachExample_Ext.c line 1039
static void enter_internal_OrbitalState_Act(void)
{
  DockingApproachExample_Ext_DW.is_active_OrbitalState_Complex = (unsigned char)1U;
  DockingApproachExample_Ext_DW.is_active_OrbitalState = (unsigned char)1U;
  if(!(DockingApproachExample_Ext_DW.is_OrbitalState == 1))
  {
    DockingApproachExample_Ext_DW.is_OrbitalState = (unsigned char)1U;
    DockingApproachExample_Ext_DW.OrbitalState_Position = (signed char)0;
    DockingApproachExample_Ext_DW.OrbitalState_Velocity = (signed char)0;
    DockingApproachExample_Ext_DW.OrbitalState_Attitude = (signed char)0;
  }

  DockingApproachExample_Ext_DW.is_active_OrbitalState2 = (unsigned char)1U;
  if(!(DockingApproachExample_Ext_DW.is_OrbitalState2 == 2))
  {
    DockingApproachExample_Ext_DW.is_OrbitalState2 = (unsigned char)2U;
    DockingApproachExample_Ext_DW.OrbitalState_Time = (signed char)1;
  }

  DockingApproachExample_Ext_DW.is_active_GPS = (unsigned char)1U;
  if(!(DockingApproachExample_Ext_DW.is_GPS == 1))
  {
    DockingApproachExample_Ext_DW.is_GPS = (unsigned char)1U;
    DockingApproachExample_Ext_DW.GPS_AbsolutePosition = (signed char)0;
    DockingApproachExample_Ext_DW.GPS_AbsoluteVelocity = (signed char)0;
    DockingApproachExample_Ext_DW.GPS_AbsoluteTime = (signed char)0;
  }

  DockingApproachExample_Ext_DW.is_active_StarPlanetTracker = (unsigned char)1U;
  if(!(DockingApproachExample_Ext_DW.is_StarPlanetTracker == 1))
  {
    DockingApproachExample_Ext_DW.is_StarPlanetTracker = (unsigned char)1U;
    DockingApproachExample_Ext_DW.StarPlanetTracker_AbsolutePosit = (signed char)0;
    DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteVeloc = (signed char)0;
    DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteAttit = (signed char)0;
    DockingApproachExample_Ext_DW.StarPlanetTracker_AbsoluteTime = (signed char)0;
  }

  DockingApproachExample_Ext_DW.is_active_InertialNavigation = (unsigned char)1U;
  DockingApproachExample_Ext_DW.VALID = (unsigned char)0U;
  if(!(DockingApproachExample_Ext_DW.is_InertialNavigation == 1))
  {
    DockingApproachExample_Ext_DW.is_InertialNavigation = (unsigned char)1U;
    DockingApproachExample_Ext_DW.InertialNavigation_AbsolutePosi = (signed char)0;
    DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteVelo = (signed char)0;
    DockingApproachExample_Ext_DW.InertialNavigation_AbsoluteAtti = (signed char)0;
  }

}

// local_CreateStructLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 2012
static struct StructLogVar_Tag * local_CreateStructLogVar(struct _RTWLogInfo_tag *li, const double startTime, const double finalTime, const double inStepSize, const char **errStatus, const char *varName, unsigned char logTime, signed int maxRows, signed int decimation, double sampleTime, const struct RTWLogSignalInfo_tag *sigInfo, const char *blockName)
{
  struct StructLogVar_Tag *var;
  struct LogInfo_Tag *logInfo = (struct LogInfo_Tag *)li->logInfo;
  *errStatus = (const char *)(void *)0;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct StructLogVar_Tag) /*200ul*/ );
  var = (struct StructLogVar_Tag *)return_value_calloc$1;
  if(!(var == (struct StructLogVar_Tag *)0))
  {
    var->numActiveFields = 2;
    rt_LoadModifiedLogVarName(li, varName, var->name);
    if(!(logTime == 0))
    {
      signed int dims = 1;
      struct LogVar_Tag *return_value_rt_CreateLogVarWithConvert$2;
      return_value_rt_CreateLogVarWithConvert$2=rt_CreateLogVarWithConvert(li, startTime, finalTime, inStepSize, errStatus, &rtStructLogVarFieldNames[(signed long int)(0 * 64)], (enum anonymous$35)SS_DOUBLE, (const struct RTWLogDataTypeConvert_tag *)(void *)0, 0, 0, 0, 1, 1, &dims, (enum anonymous$36)NO_LOGVALDIMS, (void **)(void *)0, (signed int *)(void *)0, maxRows, decimation, sampleTime, 0);
      var->time = (void *)return_value_rt_CreateLogVarWithConvert$2;
      if(var->time == (void *)0)
        goto ERROR_EXIT;

    }

    else
    {
      enum anonymous$35 dt;
      dt=rt_GetActualDTypeID((enum anonymous$35)SS_DOUBLE);
      unsigned long int nbytes = sizeof(struct MatrixData_Tag) /*200ul*/ ;
      struct MatrixData_Tag *time;
      var->time=calloc(nbytes, (unsigned long int)1);
      if(var->time == (void *)0)
        goto ERROR_EXIT;

      time = (struct MatrixData_Tag *)var->time;
      memcpy((void *)time->name, (const void *)&rtStructLogVarFieldNames[(signed long int)(0 * 64)], (unsigned long int)64);
      time->nRows = 0;
      time->nCols = 0;
      time->nDims = 0;
      time->re = (void *)0;
      time->im = (void *)0;
      time->dTypeID = (signed int)dt;
      time->mxID=rt_GetMxIdFromDTypeId(dt);
      time->elSize=rt_GetSizeofDataType(dt);
      time->logical = 0U;
      time->complex = 0U;
    }
    var->logTime = logTime;
    if(!(sigInfo == ((const struct RTWLogSignalInfo_tag *)NULL)))
    {
      const char *return_value_rt_InitSignalsStruct$3;
      return_value_rt_InitSignalsStruct$3=rt_InitSignalsStruct(li, startTime, finalTime, inStepSize, errStatus, var, maxRows, decimation, sampleTime, sigInfo);
      if(!(return_value_rt_InitSignalsStruct$3 == ((const char *)NULL)))
        goto ERROR_EXIT;

    }

    if(!(blockName == (const char *)0))
    {
      signed int dataLen;
      unsigned long int return_value_strlen$4;
      //return_value_strlen$4=strlen(blockName);
      dataLen = (signed int)return_value_strlen$4;
      unsigned long int local_CreateStructLogVar$$1$$4$$nbytes;
      unsigned long int dataOffset = sizeof(struct MatrixData_Tag) /*200ul*/ ;
      unsigned int overhang = (unsigned int)(dataOffset % sizeof(signed short int) /*2ul*/ );
      if(!(overhang == 0u))
        dataOffset = dataOffset + (sizeof(signed short int) /*2ul*/  - (unsigned long int)overhang);

      local_CreateStructLogVar$$1$$4$$nbytes = dataOffset + (unsigned long int)dataLen * sizeof(signed short int) /*2ul*/ ;
      void *return_value_calloc$5;
      return_value_calloc$5=calloc(local_CreateStructLogVar$$1$$4$$nbytes, (unsigned long int)1);
      var->blockName = (struct MatrixData_Tag *)return_value_calloc$5;
      if(var->blockName == (struct MatrixData_Tag *)0)
        goto ERROR_EXIT;

      memcpy((void *)var->blockName->name, (const void *)&rtStructLogVarFieldNames[(signed long int)(2 * 64)], (unsigned long int)64);
      var->blockName->nRows = dataLen != 0 ? 1 : 0;
      var->blockName->nCols = dataLen;
      var->blockName->nDims = 1;
      var->blockName->dims = var->blockName->_dims;
      var->blockName->dims[(signed long int)0] = dataLen;
      signed short int *data = (signed short int *)((char *)var->blockName + (signed long int)dataOffset);
      signed int i = 0;
      for( ; !(i >= dataLen); i = i + 1)
        data[(signed long int)i] = (signed short int)blockName[(signed long int)i];
      var->blockName->re = (void *)data;
      var->blockName->im = (void *)0;
      var->blockName->dTypeID = SS_INT16;
      var->blockName->mxID = (enum anonymous$32)mxCHAR_CLASS;
      var->blockName->elSize = sizeof(signed short int) /*2ul*/ ;
      var->blockName->logical = 0U;
      var->blockName->complex = 0U;
      var->numActiveFields = var->numActiveFields + 1;
    }

    struct StructLogVar_Tag *list = logInfo->structLogVarsList;
    if(!(list == (struct StructLogVar_Tag *)0))
    {
      for( ; !(list->next == (struct StructLogVar_Tag *)0); list = list->next)
        ;
      list->next = var;
    }

    else
      logInfo->structLogVarsList = var;
    return var;
  }


ERROR_EXIT:
  ;
  //fprintf(stderr, "*** Error creating log variable %s\n", varName);
  if(*errStatus == (const char *)0)
    *errStatus = rtMemAllocError;

  rt_DestroyStructLogVar(var);
  return (struct StructLogVar_Tag *)(void *)0;
}

// main
// file ../R2013a/rtw/c/grt/classic_main.c line 404
signed int main(signed int argc, const char **argv)
{
  struct tag_RTM_DockingApproachExampl_T *S;
  const char *status;
  double finaltime = -2.0;
  signed int oldStyle_argc;
  const char *oldStyle_argv[5l];
  if(argc > 1)
  {
    if(!((signed int)*(*(1l + argv)) == 45))
    {
      if(argc > 3)
      {
        displayUsage();
        //exit(1);
      }

      oldStyle_argc = 1;
      oldStyle_argv[(signed long int)0] = argv[(signed long int)0];
      if(argc >= 2)
      {
        oldStyle_argc = 3;
        oldStyle_argv[(signed long int)1] = "-tf";
        oldStyle_argv[(signed long int)2] = argv[(signed long int)1];
      }

      if(argc == 3)
      {
        oldStyle_argc = 5;
        oldStyle_argv[(signed long int)3] = "-port";
        oldStyle_argv[(signed long int)4] = argv[(signed long int)2];
      }

      argc = oldStyle_argc;
      argv = oldStyle_argv;
    }

  }

  //__CPROVER_assume(argc <= 3);
  double tmpDouble;
  char tmpStr2[200l];
  signed int count = 1;
  signed int parseError = (signed int)0U;
  signed int tmp_post$1;
  signed int tmp_post$2;
  while(!(count >= argc))
  {
    const char *option;
    tmp_post$1 = count;
    count = count + 1;
    option = argv[(signed long int)tmp_post$1];
    signed int return_value_strcmp$5;
    //return_value_strcmp$5=strcmp(option, "-tf");
    if(return_value_strcmp$5 == 0)
    {
      if(!(count == argc))
      {
        const char *tfStr;
        tmp_post$2 = count;
        count = count + 1;
        tfStr = argv[(signed long int)tmp_post$2];
        //sscanf(tfStr, "%200s", (const void *)tmpStr2);
        signed int return_value_strcmp$4;
        //return_value_strcmp$4=strcmp(tmpStr2, "inf");
        if(return_value_strcmp$4 == 0)
          tmpDouble = -1.0;

        else
        {
          char tmpstr[2l];
          signed int return_value_sscanf$3;
          //return_value_sscanf$3=sscanf(tmpStr2, "%lf%1s", &tmpDouble, (const void *)tmpstr);
          if(tmpDouble < 0.0 || !(return_value_sscanf$3 == 1))
          {
            //printf("finaltime must be a positive, real value or inf\n");
            parseError = (signed int)1U;
            break;
          }

        }
        finaltime = (double)tmpDouble;
        argv[(signed long int)(count - 2)] = (const char *)(void *)0;
        argv[(signed long int)(count - 1)] = (const char *)(void *)0;
      }

    }

  }
  if(!(parseError == 0))
  {
    printf("\nUsage: %s -option1 val1 -option2 val2 -option3 ...\n\n", (const void *)"DockingApproachExample_Ext");
    printf("\t-tf 20 - sets final time to 20 seconds\n");
    //exit(1);
  }

  signed int i = 1;
  for( ; !(i >= argc); i = i + 1)
    if(!(argv[(signed long int)i] == (const char *)0))
    {
      printf("Unexpected command line argument: %s\n", argv[(signed long int)i]);
      //exit(1);
    }

  
  S=DockingApproachExample_Ext();
  if(!(S->errorStatus == (const char *)0))
  {
    //fprintf(stderr, "Error during model registration: %s\n", S->errorStatus);
    //exit(1);
  }

  if(!(finaltime >= 0.0))
  {
    if(IEEE_FLOAT_EQUAL(finaltime, -1.000000))
      goto __CPROVER_DUMP_L16;

  }

  else
  {

  __CPROVER_DUMP_L16:
    ;
    S->Timing.tFinal = finaltime;
  }
  MdlInitializeSizes();
  MdlInitializeSampleTimes();
    
  status=rt_SimInitTimingEngine(S->Sizes.numSampTimes, S->Timing.stepSize, S->Timing.sampleTimes, S->Timing.offsetTimes, S->Timing.sampleHits, S->Timing.sampleTimeTaskIDPtr, S->Timing.tStart, &S->Timing.simTimeStep, &S->Timing.timingData);
  if(!(status == (const char *)0))
  {
    //fprintf(stderr, "Failed to initialize sample time engine: %s\n", status);
    //exit(1);
  }

  /*rt_ODECreateIntegrationData(&S->solverInfo);
  GBLbuf.errmsg=rt_StartDataLogging(S->rtwLogInfo, S->Timing.tFinal, S->Timing.stepSize, &S->errorStatus);
  if(!(GBLbuf.errmsg == (const char *)0))
  {
    //fprintf(stderr, "Error starting data logging: %s\n", GBLbuf.errmsg);
    return 1;
  }

  printf("\n** starting the model **\n");
  MdlStart();
  if(!(S->errorStatus == (const char *)0))
    GBLbuf.stopExecutionFlag = 1;

  if(IEEE_FLOAT_EQUAL(S->Timing.tFinal, -1.000000))
    printf("\n**May run forever. Model stop time set to infinity.**\n");

  while(GBLbuf.stopExecutionFlag == 0)
  {
    if(!IEEE_FLOAT_EQUAL(S->Timing.tFinal, -1.000000))
    {
      if(!(S->Timing.tFinal + -(*S->Timing.t) > *S->Timing.t * 2.220446e-16))
        break;

    }

    if(S->Timing.stopRequestedFlag != 0)
      break;

    rt_OneStep(S);
  }
  if(GBLbuf.stopExecutionFlag == 0)
  {
    if(S->Timing.stopRequestedFlag == 0)
      rt_OneStep(S);

  }

  rt_StopDataLogging("DockingApproachExample_Ext.mat", S->rtwLogInfo);
  if(!(GBLbuf.errmsg == ((const char *)NULL)))
  {
    //fprintf(stderr, "%s\n", GBLbuf.errmsg);
    //exit(1);
  }

  if(!(S->errorStatus == (const char *)0))
  {
    //fprintf(stderr, "ErrorStatus set: \"%s\"\n", S->errorStatus);
    //exit(1);
  }

  if(!(GBLbuf.isrOverrun == 0))
  {
    //fprintf(stderr, "%s: ISR overrun - base sampling rate is too fast\n", (const void *)"DockingApproachExample_Ext");
    //exit(1);
  }

  MdlTerminate();
  space_dummy_bool();*/
  _Learn_assert(0 != 0);
  return 0;
}

// rtGetInf
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rtGetInf.h line 23
extern double rtGetInf(void)
{
  unsigned long int bitsPerReal = sizeof(double) /*8ul*/  * (unsigned long int)8U;
  double inf = 0.0;
  /* tag-#anon#UN[SYM#tag-#anon#ST[SYM#tag-#anon#ST[U32'wordL'||U32'wordH'|]#'words'|]#'bitVal'||F64'fltVal'|] */
union anonymous$26
{
  // bitVal
  struct anonymous$61 bitVal;
  // fltVal
  double fltVal;
};

/* */
  ;
  union anonymous$26 tmpVal;
  /* tag-#anon#UN[SYM#tag-#anon#ST[SYM#tag-#anon#ST[U32'wordH'||U32'wordL'|]#'words'|]#'bitVal'||F64'fltVal'|] */
union anonymous$27
{
  // bitVal
  struct anonymous$59 bitVal;
  // fltVal
  double fltVal;
};

/* */
  ;
  union anonymous$27 rtGetInf$$1$$2$$1$$2$$tmpVal;
  if(bitsPerReal == 32ul)
  {
    float return_value_rtGetInfF$1;
    return_value_rtGetInfF$1=rtGetInfF();
    inf = (double)return_value_rtGetInfF$1;
  }

  else
  {
    unsigned short int one = (unsigned short int)1U;
    /* #anon_enum$LittleEndian=0$BigEndian=1 */
enum anonymous$25 { LittleEndian=0, BigEndian=1 };

/* */
    ;
    enum anonymous$25 machByteOrder = (enum anonymous$25)((unsigned int)*((unsigned char *)&one) == 1U ? LittleEndian : BigEndian);
    switch((signed int)machByteOrder)
    {
      case LittleEndian:
      {
        tmpVal.bitVal.words.wordH = 0x7FF00000U;
        tmpVal.bitVal.words.wordL = 0x00000000U;
        inf = tmpVal.fltVal;
        break;
      }
      case BigEndian:
      {
        rtGetInf$$1$$2$$1$$2$$tmpVal.bitVal.words.wordH = 0x7FF00000U;
        rtGetInf$$1$$2$$1$$2$$tmpVal.bitVal.words.wordL = 0x00000000U;
        inf = rtGetInf$$1$$2$$1$$2$$tmpVal.fltVal;
      }
    }
  }
  return inf;
}

// rtGetInfF
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rtGetInf.h line 24
extern float rtGetInfF(void)
{
  struct anonymous$28 infF;
  infF.wordL.wordLuint = 0x7F800000U;
  return infF.wordL.wordLreal;
}

// rtGetMinusInf
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rtGetInf.h line 25
extern double rtGetMinusInf(void)
{
  unsigned long int bitsPerReal = sizeof(double) /*8ul*/  * (unsigned long int)8U;
  double minf = 0.0;
  /* tag-#anon#UN[SYM#tag-#anon#ST[SYM#tag-#anon#ST[U32'wordL'||U32'wordH'|]#'words'|]#'bitVal'||F64'fltVal'|] */
union anonymous$26
{
  // bitVal
  struct anonymous$61 bitVal;
  // fltVal
  double fltVal;
};

/* */
  ;
  union anonymous$26 rtGetMinusInf$$1$$2$$1$$1$$tmpVal;
  /* tag-#anon#UN[SYM#tag-#anon#ST[SYM#tag-#anon#ST[U32'wordH'||U32'wordL'|]#'words'|]#'bitVal'||F64'fltVal'|] */
union anonymous$27
{
  // bitVal
  struct anonymous$59 bitVal;
  // fltVal
  double fltVal;
};

/* */
  ;
  union anonymous$27 tmpVal;
  if(bitsPerReal == 32ul)
  {
    float return_value_rtGetMinusInfF$1;
    return_value_rtGetMinusInfF$1=rtGetMinusInfF();
    minf = (double)return_value_rtGetMinusInfF$1;
  }

  else
  {
    unsigned short int one = (unsigned short int)1U;
    /* rtGetMinusInf::1::2::tag-machByteOrdert */
enum machByteOrdert$0 { LittleEndian=0, BigEndian=1 };

/* */
    ;
    enum machByteOrdert$0 machByteOrder = (enum machByteOrdert$0)((unsigned int)*((unsigned char *)&one) == 1U ? LittleEndian : BigEndian);
    switch((signed int)machByteOrder)
    {
      case LittleEndian:
      {
        rtGetMinusInf$$1$$2$$1$$1$$tmpVal.bitVal.words.wordH = 0xFFF00000U;
        rtGetMinusInf$$1$$2$$1$$1$$tmpVal.bitVal.words.wordL = 0x00000000U;
        minf = rtGetMinusInf$$1$$2$$1$$1$$tmpVal.fltVal;
        break;
      }
      case BigEndian:
      {
        tmpVal.bitVal.words.wordH = 0xFFF00000U;
        tmpVal.bitVal.words.wordL = 0x00000000U;
        minf = tmpVal.fltVal;
      }
    }
  }
  return minf;
}

// rtGetMinusInfF
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rtGetInf.h line 26
extern float rtGetMinusInfF(void)
{
  struct anonymous$28 minfF;
  minfF.wordL.wordLuint = 0xFF800000U;
  return minfF.wordL.wordLreal;
}

// rtGetNaN
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rtGetNaN.c line 28
extern double rtGetNaN(void)
{
  unsigned long int bitsPerReal = sizeof(double) /*8ul*/  * (unsigned long int)8U;
  double nan = 0.0;
  /* tag-#anon#UN[SYM#tag-#anon#ST[SYM#tag-#anon#ST[U32'wordL'||U32'wordH'|]#'words'|]#'bitVal'||F64'fltVal'|] */
union anonymous$26
{
  // bitVal
  struct anonymous$61 bitVal;
  // fltVal
  double fltVal;
};

/* */
  ;
  union anonymous$26 rtGetNaN$$1$$2$$1$$1$$tmpVal;
  /* tag-#anon#UN[SYM#tag-#anon#ST[SYM#tag-#anon#ST[U32'wordH'||U32'wordL'|]#'words'|]#'bitVal'||F64'fltVal'|] */
union anonymous$27
{
  // bitVal
  struct anonymous$59 bitVal;
  // fltVal
  double fltVal;
};

/* */
  ;
  union anonymous$27 tmpVal;
  if(bitsPerReal == 32ul)
  {
    float return_value_rtGetNaNF$1;
    return_value_rtGetNaNF$1=rtGetNaNF();
    nan = (double)return_value_rtGetNaNF$1;
  }

  else
  {
    unsigned short int one = (unsigned short int)1U;
    /* #anon_enum$LittleEndian=0$BigEndian=1 */
enum anonymous$25 { LittleEndian=0, BigEndian=1 };

/* */
    ;
    enum anonymous$25 machByteOrder = (enum anonymous$25)((unsigned int)*((unsigned char *)&one) == 1U ? LittleEndian : BigEndian);
    switch((signed int)machByteOrder)
    {
      case LittleEndian:
      {
        rtGetNaN$$1$$2$$1$$1$$tmpVal.bitVal.words.wordH = 0xFFF80000U;
        rtGetNaN$$1$$2$$1$$1$$tmpVal.bitVal.words.wordL = 0x00000000U;
        nan = rtGetNaN$$1$$2$$1$$1$$tmpVal.fltVal;
        break;
      }
      case BigEndian:
      {
        tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;
        tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;
        nan = tmpVal.fltVal;
      }
    }
  }
  return nan;
}

// rtGetNaNF
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rtGetNaN.c line 76
extern float rtGetNaNF(void)
{
  struct anonymous$28 nanF = { .wordL={ .wordLreal=(float)0 } };
  unsigned short int one = (unsigned short int)1U;
  /* rtGetNaNF::1::tag-machByteOrdert */
enum machByteOrdert { LittleEndian=0, BigEndian=1 };

/* */
  ;
  enum machByteOrdert machByteOrder = (enum machByteOrdert)((unsigned int)*((unsigned char *)&one) == 1U ? LittleEndian : BigEndian);
  switch((signed int)machByteOrder)
  {
    case LittleEndian:
    {
      nanF.wordL.wordLuint = 0xFFC00000U;
      break;
    }
    case BigEndian:
      nanF.wordL.wordLuint = 0x7FFFFFFFU;
  }
  return nanF.wordL.wordLreal;
}

// rtIsInf
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.c line 49
extern unsigned char rtIsInf(double value)
{
  return (unsigned char)(IEEE_FLOAT_EQUAL(value, rtInf) || IEEE_FLOAT_EQUAL(value, rtMinusInf) ? 1U : 0U);
}

// rtIsInfF
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.c line 55
extern unsigned char rtIsInfF(float value)
{
  return (unsigned char)(IEEE_FLOAT_EQUAL(value, rtInfF) || IEEE_FLOAT_EQUAL(value, rtMinusInfF) ? 1U : 0U);
}

// rtIsNaN
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.c line 61
extern unsigned char rtIsNaN(double value)
{
  return (unsigned char)(IEEE_FLOAT_NOTEQUAL(value, value) ? 1U : 0U);
}

// rtIsNaNF
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.c line 67
extern unsigned char rtIsNaNF(float value)
{
  return (unsigned char)(IEEE_FLOAT_NOTEQUAL(value, value) ? 1U : 0U);
}

// rt_CreateLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 2898
extern struct LogVar_Tag * rt_CreateLogVar(struct _RTWLogInfo_tag *li, const double startTime, const double finalTime, const double inStepSize, const char **errStatus, const char *varName, enum anonymous$35 inpDataTypeID, signed int logical, signed int complex, signed int frameData, signed int nCols, signed int nDims, const signed int *dims, enum anonymous$36 logValDimsStat, void **currSigDims, signed int *currSigDimsSize, signed int maxRows, signed int decimation, double sampleTime, signed int appendToLogVarsList)
{
  const struct RTWLogDataTypeConvert_tag *pDataTypeConvertInfo = (const struct RTWLogDataTypeConvert_tag *)(void *)0;
  struct LogVar_Tag *return_value_rt_CreateLogVarWithConvert$1;
  return_value_rt_CreateLogVarWithConvert$1=rt_CreateLogVarWithConvert(li, startTime, finalTime, inStepSize, errStatus, varName, inpDataTypeID, pDataTypeConvertInfo, logical, complex, frameData, nCols, nDims, dims, logValDimsStat, currSigDims, currSigDimsSize, maxRows, decimation, sampleTime, appendToLogVarsList);
  return return_value_rt_CreateLogVarWithConvert$1;
}

// rt_CreateLogVarWithConvert
// file ../R2013a/rtw/c/src/rt_logging.c line 2521
extern struct LogVar_Tag * rt_CreateLogVarWithConvert(struct _RTWLogInfo_tag *li, const double startTime, const double finalTime, const double inStepSize, const char **errStatus, const char *varName, enum anonymous$35 inpDataTypeID, const struct RTWLogDataTypeConvert_tag *pDataTypeConvertInfo, signed int logical, signed int complex, signed int frameData, signed int nCols, signed int nDims, const signed int *dims, enum anonymous$36 logValDimsStat, void **currSigDims, signed int *currSigDimsSize, signed int maxRows, signed int decimation, double sampleTime, signed int appendToLogVarsList)
{
  signed int usingDefaultBufSize = 0;
  signed int okayToRealloc = 1;
  struct LogVar_Tag *var = (struct LogVar_Tag *)(void *)0;
  enum anonymous$35 dTypeID = (enum anonymous$35)inpDataTypeID;
  unsigned long int elementSize;
  elementSize=rt_GetSizeofDataType(dTypeID);
  signed int frameSize;
  signed int nRows;
  signed int nColumns;
  signed int tmp_if_expr$1;
  if(!(frameData == 0))
    tmp_if_expr$1 = dims[(signed long int)0];

  else
    tmp_if_expr$1 = 1;
  frameSize = tmp_if_expr$1;
  if(finalTime > startTime)
  {
    if(!IEEE_FLOAT_NOTEQUAL(finalTime, rtInf))
      goto __CPROVER_DUMP_L12;

    double nPoints;
    double stepSize;
    if(IEEE_FLOAT_EQUAL(sampleTime, -2.000000))
      stepSize = finalTime;

    else
    {
      if(!IEEE_FLOAT_EQUAL(sampleTime, -1.000000))
      {
        if(IEEE_FLOAT_EQUAL(sampleTime, 0.0))
          goto __CPROVER_DUMP_L4;

      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        stepSize = inStepSize;
        goto __CPROVER_DUMP_L6;
      }
      stepSize = sampleTime;
    }

  __CPROVER_DUMP_L6:
    ;
    if(IEEE_FLOAT_EQUAL(stepSize, 0.0))
    {
      nRows = maxRows + 1;
      okayToRealloc = 1;
    }

    else
    {
      double return_value_floor$2;
      //return_value_floor$2=floor((finalTime - startTime) / stepSize);
      nPoints = 1.0 + return_value_floor$2;
      if(stepSize * (nPoints + -1.000000) < finalTime + -startTime)
        nPoints = nPoints + 1.0;

      nPoints = frameData != 0 ? nPoints * (double)frameSize : nPoints;
      nPoints = nPoints / (double)decimation;
      double return_value_floor$3;
      //return_value_floor$3=floor(nPoints);
      if(IEEE_FLOAT_NOTEQUAL(nPoints, return_value_floor$3))
        nPoints = nPoints + 1.0;

      nRows = nPoints <= (double)2147483647 ? (signed int)nPoints : 2147483647;
    }
    if(maxRows > 0)
    {
      if(!(maxRows >= nRows))
      {
        nRows = maxRows;
        okayToRealloc = 0;
      }

    }

  }

  else
  {

  __CPROVER_DUMP_L12:
    ;
    if(IEEE_FLOAT_EQUAL(finalTime, startTime))
    {
      nRows = frameData != 0 ? frameSize : 1;
      if(maxRows > 0)
      {
        if(!(maxRows >= nRows))
        {
          nRows = maxRows;
          okayToRealloc = 0;
        }

      }

    }

    else
      if(maxRows > 0)
      {
        nRows = maxRows;
        okayToRealloc = 0;
      }

      else
        if(IEEE_FLOAT_EQUAL(inStepSize, 0.000000))
        {
          nRows = maxRows + 1;
          okayToRealloc = 1;
        }

        else
        {
          usingDefaultBufSize = 1;
          nRows = 1024;
          okayToRealloc = 0;
          //fprintf(stdout, "*** Using a default buffer of size %d for logging variable %s\n", nRows, varName);
        }
  }
  signed int tmp_if_expr$4;
  if(!(frameData == 0))
    tmp_if_expr$4 = dims[(signed long int)1];

  else
    tmp_if_expr$4 = nCols;
  nColumns = tmp_if_expr$4;
  double tmpDbl = (double)elementSize * (double)nRows * (double)nColumns;
  void *return_value_calloc$5;
  _Bool tmp_if_expr$11;
  void *return_value_calloc$10;
  _Bool tmp_if_expr$13;
  void *return_value_calloc$12;
  if(tmpDbl >= 4.294967e+9)
  {
    //fprintf(stderr, "\n*** Memory required to log variable '%s' is too\n    big. Use the 'Limit rows to last:' and (or)\n    'Decimation:' options to reduce the required\n    memory size.\n", varName);
    //fprintf(stderr, "*** Details:\n       varName         = %s\n       nRows           = %d\n       nCols           = %d\n       elementSize     = %lu\n       Bytes Required  = %.16g\n\n", varName, nRows, nColumns, (unsigned long int)elementSize, tmpDbl);
  }

  else
  {
    return_value_calloc$5=calloc((unsigned long int)1, sizeof(struct LogVar_Tag) /*272ul*/ );
    var = (struct LogVar_Tag *)return_value_calloc$5;
    if(var == (struct LogVar_Tag *)0) {
      //fprintf(stderr, "*** Error allocating memory for logging %s\n", varName);
    }
    else
    {
      var->data.re=malloc((unsigned long int)(nRows * nColumns) * elementSize);
      if(var->data.re == (void *)0)
      {
        //fprintf(stderr, "*** Error allocating memory for the circular buffer\n");
        //fprintf(stderr, "*** Details:\n       varName         = %s\n       nRows           = %d\n       nCols           = %d\n       elementSize     = %lu\n       Bytes Requested = %.16g\n\n", varName, nRows, nColumns, (unsigned long int)elementSize, (double)elementSize * (double)nRows * (double)nColumns);
      }

      else
        if(!(complex == 0))
        {
          var->data.im=malloc((unsigned long int)(nRows * nColumns) * elementSize);
          if(!(var->data.im == (void *)0))
            goto __CPROVER_DUMP_L23;

          //fprintf(stderr, "*** Error allocating memory for the circular buffer for logging the imaginary part of %s\n", varName);
          //fprintf(stderr, "*** Details:\n       varName         = %s\n       nRows           = %d\n       nCols           = %d\n       elementSize     = %lu\n       Bytes Requested = %.16g\n\n", varName, nRows, nColumns, (unsigned long int)elementSize, (double)elementSize * (double)nRows * (double)nColumns);
        }

        else
        {

        __CPROVER_DUMP_L23:
          ;
          if(!(appendToLogVarsList == 0))
            rt_LoadModifiedLogVarName(li, varName, var->data.name);

          else
          {
            var->data.name[(signed long int)(64 - 1)] = (char)0;
            //strncpy(var->data.name, varName, (unsigned long int)(64 - 1));
          }
          var->data.nCols = nColumns;
          var->data.nRows = nRows;
          var->data.nDims = frameData != 0 ? 1 : nDims;
          if(var->data.nDims > 2)
          {
            void *return_value_malloc$6;
            return_value_malloc$6=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)var->data.nDims);
            var->data.dims = (signed int *)return_value_malloc$6;
          }

          else
            var->data.dims = var->data._dims;
          if(!(frameData == 0))
            var->data.dims[(signed long int)0] = nColumns;

          else
            memcpy((void *)var->data.dims, (const void *)dims, (unsigned long int)((unsigned long int)nDims * sizeof(signed int) /*4ul*/ ));
          var->data.dTypeID = (signed int)dTypeID;
          var->data.elSize = elementSize;
          var->data.dataTypeConvertInfo=rt_GetDataTypeConvertInfo(pDataTypeConvertInfo, dTypeID);
          var->data.mxID=rt_GetMxIdFromDTypeId(dTypeID);
          logical = (signed int)dTypeID == SS_BOOLEAN ? 1 : 0;
          var->data.logical = (unsigned int)(logical != 0 ? 0x200 : 0x0);
          var->data.complex = (unsigned int)(complex != 0 ? 0x800 : 0x0);
          var->data.frameData = (unsigned int)frameData;
          var->data.frameSize = (unsigned int)(frameData != 0 ? frameSize : 1);
          if((signed int)logValDimsStat == NO_LOGVALDIMS)
          {
            var->valDims = (struct ValDimsData_Tag *)(void *)0;
            var->coords = (signed int *)(void *)0;
            var->strides = (signed int *)(void *)0;
            var->currStrides = (signed int *)(void *)0;
          }

          else
          {
            void *return_value_calloc$7;
            return_value_calloc$7=calloc((unsigned long int)1, sizeof(struct ValDimsData_Tag) /*96ul*/ );
            var->valDims = (struct ValDimsData_Tag *)return_value_calloc$7;
            if(var->valDims == (struct ValDimsData_Tag *)0)
              goto ERROR_EXIT;

            memcpy((void *)var->valDims->name, (const void *)&rtLocalLoggingSignalsStructFieldNames[(signed long int)(1 * 64)], (unsigned long int)64);
            if((signed int)logValDimsStat == LOGVALDIMS_EMPTYMX)
            {
              var->valDims->nRows = 0;
              var->valDims->nCols = 0;
              var->valDims->currSigDims = (void **)(void *)0;
              var->valDims->currSigDimsSize = (signed int *)(void *)0;
              var->valDims->dimsData = (double *)(void *)0;
              var->coords = (signed int *)(void *)0;
              var->strides = (signed int *)(void *)0;
              var->currStrides = (signed int *)(void *)0;
            }

            else
            {
              elementSize = sizeof(double) /*8ul*/ ;
              if(!(frameData == 0))
              {
                nColumns = 1;
                var->valDims->currSigDims = (void **)(currSigDims + (signed long int)1);
                var->valDims->currSigDimsSize = (signed int *)(currSigDimsSize + (signed long int)1);
              }

              else
              {
                nColumns = nDims;
                var->valDims->currSigDims = (void **)currSigDims;
                var->valDims->currSigDimsSize = (signed int *)currSigDimsSize;
              }
              void *return_value_malloc$8;
              return_value_malloc$8=malloc((unsigned long int)(nRows * nColumns) * elementSize);
              var->valDims->dimsData = (double *)return_value_malloc$8;
              if(var->valDims->dimsData == (double *)0)
              {
                //fprintf(stderr, "*** Error allocating memory for the circular buffer\n");
                //fprintf(stderr, "*** Details:\n       varName         = %s\n       nRows           = %d\n       nCols           = %d\n       elementSize     = %lu\n       Bytes Requested = %.16g\n\n", (const void *)var->valDims->name, nRows, nColumns, (unsigned long int)elementSize, (double)elementSize * (double)nRows * (double)nColumns);
                goto ERROR_EXIT;
              }

              var->valDims->nRows = nRows;
              var->valDims->nCols = nColumns;
              unsigned long int nbytes = (unsigned long int)var->data.nDims * sizeof(signed int) /*4ul*/ ;
              void *return_value_calloc$9;
              return_value_calloc$9=calloc(nbytes, (unsigned long int)1);
              var->coords = (signed int *)return_value_calloc$9;
              if(var->coords == (signed int *)0)
                tmp_if_expr$11 = (_Bool)1;

              else
              {
                return_value_calloc$10=calloc(nbytes, (unsigned long int)1);
                var->strides = (signed int *)return_value_calloc$10;
                tmp_if_expr$11 = var->strides == (signed int *)(void *)0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$11)
                tmp_if_expr$13 = (_Bool)1;

              else
              {
                return_value_calloc$12=calloc(nbytes, (unsigned long int)1);
                var->currStrides = (signed int *)return_value_calloc$12;
                tmp_if_expr$13 = var->currStrides == (signed int *)(void *)0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$13)
                goto ERROR_EXIT;

            }
          }
          var->rowIdx = 0;
          var->wrapped = 0;
          var->nDataPoints = 0;
          var->usingDefaultBufSize = usingDefaultBufSize;
          var->okayToRealloc = okayToRealloc;
          var->decimation = decimation;
          var->numHits = -1;
          if(!(appendToLogVarsList == 0))
          {
            struct LogInfo_Tag *logInfo = (struct LogInfo_Tag *)li->logInfo;
            struct LogVar_Tag *varList = logInfo->logVarsList;
            if(!(varList == (struct LogVar_Tag *)0))
            {
              for( ; !(varList->next == (struct LogVar_Tag *)0); varList = varList->next)
                ;
              varList->next = var;
            }

            else
              logInfo->logVarsList = var;
          }

          return var;
        }
    }
  }

ERROR_EXIT:
  ;
  *errStatus = rtMemAllocError;
  rt_DestroyLogVar(var);
  return (struct LogVar_Tag *)(void *)0;
}

// rt_CreateStructLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 2966
extern struct StructLogVar_Tag * rt_CreateStructLogVar(struct _RTWLogInfo_tag *li, const double startTime, const double finalTime, const double inStepSize, const char **errStatus, const char *varName, unsigned char logTime, signed int maxRows, signed int decimation, double sampleTime, const struct RTWLogSignalInfo_tag *sigInfo, const char *blockName)
{
  struct StructLogVar_Tag *return_value_local_CreateStructLogVar$1;
  return_value_local_CreateStructLogVar$1=local_CreateStructLogVar(li, startTime, finalTime, inStepSize, errStatus, varName, logTime, maxRows, decimation, sampleTime, sigInfo, blockName);
  return return_value_local_CreateStructLogVar$1;
}

// rt_DestroyLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 1399
static void rt_DestroyLogVar(struct LogVar_Tag *head)
{
  while(!(head == ((struct LogVar_Tag *)NULL)))
  {
    struct LogVar_Tag *var = head;
    head = var->next;
    //if(!(var->data.re == (void *)0))
      //free(var->data.re);

    //if(!(var->data.im == (void *)0))
      //free(var->data.im);

    if(!(var->data.dims == var->data._dims))
    {
      //if(!(var->data.dims == (signed int *)0))
        //free((void *)var->data.dims);

    }

    if(!(var->valDims == (struct ValDimsData_Tag *)0))
    {
      //if(!(var->valDims->dimsData == (double *)0))
        //free((void *)var->valDims->dimsData);

      //if(!(var->valDims == (struct ValDimsData_Tag *)0))
        //free((void *)var->valDims);

    }

    //if(!(var->coords == (signed int *)0))
      //free((void *)var->coords);

    //if(!(var->strides == (signed int *)0))
      //free((void *)var->strides);

    //if(!(var->currStrides == (signed int *)0))
      //free((void *)var->currStrides);

    //if(!(var == (struct LogVar_Tag *)0))
      //free((void *)var);

  }
}

// rt_DestroyStructLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 1429
static void rt_DestroyStructLogVar(struct StructLogVar_Tag *head)
{
  while(!(head == ((struct StructLogVar_Tag *)NULL)))
  {
    struct StructLogVar_Tag *var = head;
    head = var->next;
    if(!(var->logTime == 0))
      rt_DestroyLogVar((struct LogVar_Tag *)var->time);

    else
      if(!(var->time == (void *)0))
        //free(var->time);

    rt_DestroyLogVar(var->signals.values);
    //if(!(var->signals.labels == (struct MatrixData_Tag *)0))
      //free((void *)var->signals.labels);

    //if(!(var->signals.plotStyles == (struct MatrixData_Tag *)0))
      //free((void *)var->signals.plotStyles);

    //if(!(var->signals.dimensions == (struct MatrixData_Tag *)0))
      //free((void *)var->signals.dimensions);

    //if(!(var->signals.titles == (struct MatrixData_Tag *)0))
      //free((void *)var->signals.titles);

    //if(!(var->signals.blockNames == (struct MatrixData_Tag *)0))
      //free((void *)var->signals.blockNames);

    //if(!(var->signals.stateNames == (struct MatrixData_Tag *)0))
      //free((void *)var->signals.stateNames);

    //if(!(var->signals.crossMdlRef == (struct MatrixData_Tag *)0))
      //free((void *)var->signals.crossMdlRef);

    //if(!(var->blockName == (struct MatrixData_Tag *)0))
      //free((void *)var->blockName);

    //if(!(var == (struct StructLogVar_Tag *)0))
      //free((void *)var);

  }
}

// rt_FixupLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 1127
static const char * rt_FixupLogVar(struct LogVar_Tag *var, signed int verbose)
{
  signed int nCols = var->data.nCols;
  signed int maxRows = var->data.nRows;
  signed int nDims = var->data.nDims;
  unsigned long int elSize = var->data.elSize;
  signed int nRows;
  signed int tmp_if_expr$1;
  if(!(var->wrapped == 0))
    tmp_if_expr$1 = maxRows;

  else
    tmp_if_expr$1 = var->rowIdx;
  nRows = tmp_if_expr$1;
  var->nDataPoints = var->rowIdx + var->wrapped * maxRows;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(var->wrapped > 1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    if(var->wrapped == 1)
      tmp_if_expr$2 = var->rowIdx != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
  {
    if(!(verbose == 0))
      //fprintf(stdout, "*** Log variable %s has wrapped %d times\n    using a circular buffer of size %d\n", (const void *)var->data.name, var->wrapped, var->data.nRows);

    if(!(var->usingDefaultBufSize == 0))
    {
      //if(!(verbose == 0))
        //fprintf(stdout, "*** To avoid wrapping, explicitly specify a\n    buffer size of %d in your Simulink model\n    by adding OPTS=\"-DDEFAULT_BUFFER_SIZE=%d\"\n    as an argument to the ConfigSet MakeCommand\n    parameter\n", var->nDataPoints, var->nDataPoints);

    }

  }

  if(nDims < 2)
  {
    if(nCols > 1)
    {
      signed int nEl = nRows * nCols;
      char *src = (char *)var->data.re;
      char *pmT;
      signed int k;
      void *return_value_malloc$4;
      return_value_malloc$4=malloc((unsigned long int)nEl * elSize);
      pmT = (char *)return_value_malloc$4;
      if(pmT == (char *)0)
      {
        struct _IO_FILE *fptr;
        char fName[64l];
        //sprintf(fName, "%s%s", (const void *)var->data.name, (const void *)"_rtw_tmw.tmw");
        //fptr=fopen(fName, "w+b");
        if(fptr == (struct _IO_FILE *)0)
        {
          //fprintf(stderr, "*** Error opening %s", (const void *)fName);
          return "unable to open data file\n";
        }

        k = 0;
        for( ; !(k >= nEl); k = k + 1)
        {
          signed int rt_FixupLogVar$$1$$2$$1$$2$$kT = nCols * (k % nRows) + k / nRows;
          char *rt_FixupLogVar$$1$$2$$1$$2$$dst = src + (signed long int)((unsigned long int)rt_FixupLogVar$$1$$2$$1$$2$$kT * elSize);
          //fwrite((const void *)rt_FixupLogVar$$1$$2$$1$$2$$dst, elSize, (unsigned long int)1, fptr);
        }
        if(!(var->data.complex == 0u))
        {
          char *rt_FixupLogVar$$1$$2$$1$$3$$pmiT = (char *)var->data.re;
          src = (char *)var->data.im;
          k = 0;
          for( ; !(k >= nEl); k = k + 1)
          {
            signed int rt_FixupLogVar$$1$$2$$1$$3$$1$$kT = nRows * (k % nCols) + k / nCols;
            char *rt_FixupLogVar$$1$$2$$1$$3$$1$$dst = rt_FixupLogVar$$1$$2$$1$$3$$pmiT + (signed long int)((unsigned long int)rt_FixupLogVar$$1$$2$$1$$3$$1$$kT * elSize);
            memcpy((void *)rt_FixupLogVar$$1$$2$$1$$3$$1$$dst, (const void *)src, elSize);
            src = src + (signed long int)elSize;
          }
          var->data.re = var->data.im;
          var->data.im = (void *)rt_FixupLogVar$$1$$2$$1$$3$$pmiT;
        }

        //rewind(fptr);
        //fread(var->data.re, elSize, (unsigned long int)nEl, fptr);
        //fclose(fptr);
        //remove(fName);
      }

      else
      {
        k = 0;
        for( ; !(k >= nEl); k = k + 1)
        {
          signed int rt_FixupLogVar$$1$$2$$2$$1$$kT = nRows * (k % nCols) + k / nCols;
          char *rt_FixupLogVar$$1$$2$$2$$1$$dst = pmT + (signed long int)((unsigned long int)rt_FixupLogVar$$1$$2$$2$$1$$kT * elSize);
          memcpy((void *)rt_FixupLogVar$$1$$2$$2$$1$$dst, (const void *)src, elSize);
          src = src + (signed long int)elSize;
        }
        if(!(var->data.complex == 0u))
        {
          char *pmiT = (char *)var->data.re;
          src = (char *)var->data.im;
          k = 0;
          for( ; !(k >= nEl); k = k + 1)
          {
            signed int kT = nRows * (k % nCols) + k / nCols;
            char *dst = pmiT + (signed long int)((unsigned long int)kT * elSize);
            memcpy((void *)dst, (const void *)src, elSize);
            src = src + (signed long int)elSize;
          }
          var->data.re = var->data.im;
          var->data.im = (void *)pmiT;
        }

        //if(!(var->data.re == (void *)0))
          //free(var->data.re);

        var->data.re = (void *)pmT;
      }
    }

  }

  _Bool tmp_if_expr$5;
  if(var->wrapped > 0)
  {
    if(!(var->rowIdx == 0))
    {
      char *buffer = (char *)var->data.re;
      signed int done = 0;
      do
      {
        char *col = buffer;
        signed int rowOffset = (signed int)(nDims == 1 ? elSize : elSize * (unsigned long int)nCols);
        signed int colOffset = (signed int)(nDims == 1 ? (unsigned long int)nRows * elSize : elSize);
        signed int zeroIdx = var->rowIdx;
        signed int j = 0;
        for( ; !(j >= nCols); col = col + (signed long int)colOffset)
        {
          signed int swapCount;
          signed int srcIdx;
          signed int dstIdx;
          signed int tmpIdx;
          double tmp;
          tmpIdx = 0;
          swapCount = 0;
          for( ; !(swapCount >= nRows); tmpIdx = tmpIdx + 1)
          {
            memcpy((void *)&tmp, (const void *)(col + (signed long int)(tmpIdx * rowOffset)), elSize);
            dstIdx = tmpIdx;
            srcIdx = (dstIdx + zeroIdx) % nRows;
            for( ; !(srcIdx == tmpIdx); srcIdx = (dstIdx + zeroIdx) % nRows)
            {
              memcpy((void *)(col + (signed long int)(dstIdx * rowOffset)), (const void *)(col + (signed long int)(srcIdx * rowOffset)), elSize);
              swapCount = swapCount + 1;
              dstIdx = srcIdx;
            }
            memcpy((void *)(col + (signed long int)(dstIdx * rowOffset)), (const void *)&tmp, elSize);
            swapCount = swapCount + 1;
          }
          j = j + 1;
        }
        done = done + 1;
        if(done == 1)
        {
          buffer = (char *)var->data.im;
          tmp_if_expr$5 = buffer != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$5 = (_Bool)0;
      }
      while(tmp_if_expr$5);
      var->rowIdx = 0;
    }

  }

  if(!(var->nDataPoints >= var->data.nRows))
  {
    var->data.nRows = var->nDataPoints;
    if(!(var->valDims == (struct ValDimsData_Tag *)0))
    {
      unsigned long int elSizeValDims = sizeof(double) /*8ul*/ ;
      signed int rt_FixupLogVar$$1$$4$$1$$k;
      double *dimsData = var->valDims->dimsData + (signed long int)nRows;
      var->valDims->nRows = var->data.nRows;
      rt_FixupLogVar$$1$$4$$1$$k = 1;
      for( ; !(rt_FixupLogVar$$1$$4$$1$$k >= nDims); rt_FixupLogVar$$1$$4$$1$$k = rt_FixupLogVar$$1$$4$$1$$k + 1)
      {
        memcpy((void *)dimsData, (const void *)(var->valDims->dimsData + (signed long int)(rt_FixupLogVar$$1$$4$$1$$k * maxRows)), elSizeValDims * (unsigned long int)nRows);
        dimsData = dimsData + (signed long int)nRows;
      }
    }

  }

  return (const char *)(void *)0;
}

// rt_GetActualDTypeID
// file ../R2013a/rtw/c/src/rt_logging.c line 1383
static enum anonymous$35 rt_GetActualDTypeID(enum anonymous$35 dTypeID)
{
  if((signed int)dTypeID == SS_DOUBLE)
  {
    goto __CPROVER_DUMP_L1;
    return (enum anonymous$35)SS_SINGLE;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return dTypeID;
  }
}

// rt_GetDataTypeConvertInfo
// file ../R2013a/rtw/c/src/rt_logging.c line 287
static struct RTWLogDataTypeConvert_tag rt_GetDataTypeConvertInfo(const struct RTWLogDataTypeConvert_tag *pDataTypeConvertInfo, enum anonymous$35 dTypeID)
{
  struct RTWLogDataTypeConvert_tag dataTypeConvertInfoCopy;
  if(pDataTypeConvertInfo == (const struct RTWLogDataTypeConvert_tag *)0)
  {
    dataTypeConvertInfoCopy.conversionNeeded = 0;
    dataTypeConvertInfoCopy.dataTypeIdLoggingTo = dTypeID;
    dataTypeConvertInfoCopy.dataTypeIdOriginal = (signed int)dTypeID;
    dataTypeConvertInfoCopy.bitsPerChunk = 0;
    dataTypeConvertInfoCopy.numOfChunk = 0;
    dataTypeConvertInfoCopy.isSigned = (unsigned int)0;
    dataTypeConvertInfoCopy.fracSlope = 1.0;
    dataTypeConvertInfoCopy.fixedExp = 0;
    dataTypeConvertInfoCopy.bias = 0.0;
  }

  else
    dataTypeConvertInfoCopy = *pDataTypeConvertInfo;
  return dataTypeConvertInfoCopy;
}

// rt_GetDblValueFromOverSizedData
// file ../R2013a/rtw/c/src/rt_logging.c line 316
static double rt_GetDblValueFromOverSizedData(const void *pVoid, signed int bitsPerChunk, signed int numOfChunk, unsigned int isSigned, double fracSlope, signed int fixedExp, double bias)
{
  double retValue = (double)0;
  double *dblValue;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)numOfChunk, sizeof(double) /*8ul*/ );
  dblValue = (double *)return_value_calloc$1;
  signed int i;
  double isSignedNeg;
  if(!(isSigned == 0u))
  {
    const signed int *pData = (const signed int *)pVoid;
    i = 0;
    for( ; !(i >= numOfChunk); i = i + 1)
      dblValue[(signed long int)i] = (double)pData[(signed long int)i];
  }

  else
  {
    const unsigned int *rt_GetDblValueFromOverSizedData$$1$$2$$pData = (const unsigned int *)pVoid;
    i = 0;
    for( ; !(i >= numOfChunk); i = i + 1)
      dblValue[(signed long int)i] = (double)rt_GetDblValueFromOverSizedData$$1$$2$$pData[(signed long int)i];
  }
  retValue = dblValue[(signed long int)(numOfChunk - 1)];
  i = numOfChunk - 1;
  for( ; i > 0; i = i - 1)
  {
    isSignedNeg = dblValue[(signed long int)(i - 1)] < (double)0 ? (double)isSigned : (double)0;
    retValue = retValue + isSignedNeg;
    double return_value_ldexp$2;
    //return_value_ldexp$2=ldexp(retValue, bitsPerChunk);
    retValue = return_value_ldexp$2 + dblValue[(signed long int)(i - 1)];
  }
  double return_value_ldexp$3;
  //return_value_ldexp$3=ldexp(fracSlope * retValue, fixedExp);
  retValue = return_value_ldexp$3 + bias;
  //if(!(dblValue == (double *)0))
    //free((void *)dblValue);

  return retValue;
}

// rt_GetMatIdFromMxId
// file ../R2013a/rtw/c/src/rt_logging.c line 485
static signed int rt_GetMatIdFromMxId(enum anonymous$32 mxID)
{
  signed int matID;
  switch((signed int)mxID)
  {
    case mxCELL_CLASS:

    case mxSTRUCT_CLASS:

    case mxOBJECT_CLASS:
    {
      matID = -1;
      break;
    }
    case mxCHAR_CLASS:
    {
      matID = 4;
      break;
    }
    case mxDOUBLE_CLASS:
    {
      matID = 9;
      break;
    }
    case mxSINGLE_CLASS:
    {
      matID = 7;
      break;
    }
    case mxINT8_CLASS:
    {
      matID = 1;
      break;
    }
    case mxUINT8_CLASS:
    {
      matID = 2;
      break;
    }
    case mxINT16_CLASS:
    {
      matID = 3;
      break;
    }
    case mxUINT16_CLASS:
    {
      matID = 4;
      break;
    }
    case mxINT32_CLASS:
    {
      matID = 5;
      break;
    }
    case mxUINT32_CLASS:
    {
      matID = 6;
      break;
    }
    case mxINT64_CLASS:
    {
      matID = 12;
      break;
    }
    case mxUINT64_CLASS:
    {
      matID = 13;
      break;
    }
    default:
      matID = 0;
  }
  return matID;
}

// rt_GetMxIdFromDTypeId
// file ../R2013a/rtw/c/src/rt_logging.c line 461
extern enum anonymous$32 rt_GetMxIdFromDTypeId(enum anonymous$35 dTypeID)
{
  enum anonymous$32 mxID;
  if((signed int)dTypeID == SS_BOOLEAN)
    mxID = (enum anonymous$32)(sizeof(unsigned char) /*1ul*/  == (unsigned long int)4 ? mxUINT32_CLASS : mxUINT8_CLASS);

  else
    mxID=rt_GetNonBoolMxIdFromDTypeId(dTypeID);
  return mxID;
}

// rt_GetMxIdFromDTypeIdForRSim
// file ../R2013a/rtw/c/src/rt_logging.c line 430
extern enum anonymous$32 rt_GetMxIdFromDTypeIdForRSim(enum anonymous$35 dTypeID)
{
  enum anonymous$32 mxID;
  if((signed int)dTypeID == SS_BOOLEAN)
    mxID = (enum anonymous$32)(sizeof(unsigned char) /*1ul*/  == (unsigned long int)4 ? mxUINT32_CLASS : mxLOGICAL_CLASS);

  else
    mxID=rt_GetNonBoolMxIdFromDTypeId(dTypeID);
  return mxID;
}

// rt_GetNextSampleHit
// file ../R2013a/rtw/c/src/rt_sim.c line 570
extern double rt_GetNextSampleHit(void)
{
  double return_value_rt_SimGetNextSampleHit$1;
  return_value_rt_SimGetNextSampleHit$1=rt_SimGetNextSampleHit();
  return return_value_rt_SimGetNextSampleHit$1;
}

// rt_GetNonBoolMxIdFromDTypeId
// file ../R2013a/rtw/c/src/rt_logging.c line 378
enum anonymous$32 rt_GetNonBoolMxIdFromDTypeId(enum anonymous$35 dTypeID)
{
  enum anonymous$32 mxID;
  switch((signed int)dTypeID)
  {
    case SS_DOUBLE:
    {
      mxID = (enum anonymous$32)(sizeof(double) /*8ul*/  == (unsigned long int)4 ? mxSINGLE_CLASS : mxDOUBLE_CLASS);
      break;
    }
    case SS_SINGLE:
    {
      mxID = (enum anonymous$32)mxSINGLE_CLASS;
      break;
    }
    case SS_INT8:
    {
      mxID = (enum anonymous$32)(sizeof(signed char) /*1ul*/  == (unsigned long int)4 ? mxINT32_CLASS : mxINT8_CLASS);
      break;
    }
    case SS_UINT8:
    {
      mxID = (enum anonymous$32)(sizeof(unsigned char) /*1ul*/  == (unsigned long int)4 ? mxUINT32_CLASS : mxUINT8_CLASS);
      break;
    }
    case SS_INT16:
    {
      mxID = (enum anonymous$32)(sizeof(signed short int) /*2ul*/  == (unsigned long int)4 ? mxINT32_CLASS : mxINT16_CLASS);
      break;
    }
    case SS_UINT16:
    {
      mxID = (enum anonymous$32)(sizeof(unsigned short int) /*2ul*/  == (unsigned long int)4 ? mxUINT32_CLASS : mxUINT16_CLASS);
      break;
    }
    case SS_INT32:
    {
      mxID = (enum anonymous$32)mxINT32_CLASS;
      break;
    }
    case SS_UINT32:
    {
      mxID = (enum anonymous$32)mxUINT32_CLASS;
      break;
    }
    default:
      mxID = (enum anonymous$32)mxUNKNOWN_CLASS;
  }
  return mxID;
}

// rt_GetSizeofComplexType
// file ../R2013a/rtw/c/src/rt_logging.c line 227
static unsigned long int rt_GetSizeofComplexType(enum anonymous$35 dTypeID)
{
  unsigned long int elSz;
  unsigned long int return_value_rt_GetSizeofDataType$1;
  return_value_rt_GetSizeofDataType$1=rt_GetSizeofDataType(dTypeID);
  elSz = (unsigned long int)2 * return_value_rt_GetSizeofDataType$1;
  switch((signed int)dTypeID)
  {
    case SS_DOUBLE:
    {
      elSz = sizeof(struct anonymous$39) /*16ul*/ ;
      break;
    }
    case SS_SINGLE:
    {
      elSz = sizeof(struct anonymous$38) /*8ul*/ ;
      break;
    }
    case SS_INT8:
      break;
    case SS_UINT8:
      break;
    case SS_INT16:
      break;
    case SS_UINT16:
      break;
    case SS_INT32:
      break;
    case SS_UINT32:
      break;
    case SS_BOOLEAN:
      elSz = sizeof(unsigned char) /*1ul*/ ;
  }
  return elSz;
}

// rt_GetSizeofDataType
// file ../R2013a/rtw/c/src/rt_logging.c line 185
static unsigned long int rt_GetSizeofDataType(enum anonymous$35 dTypeID)
{
  unsigned long int elSz = (unsigned long int)0;
  switch((signed int)dTypeID)
  {
    case SS_DOUBLE:
    {
      elSz = sizeof(double) /*8ul*/ ;
      break;
    }
    case SS_SINGLE:
    {
      elSz = sizeof(float) /*4ul*/ ;
      break;
    }
    case SS_INT8:
    {
      elSz = sizeof(signed char) /*1ul*/ ;
      break;
    }
    case SS_UINT8:
    {
      elSz = sizeof(unsigned char) /*1ul*/ ;
      break;
    }
    case SS_INT16:
    {
      elSz = sizeof(signed short int) /*2ul*/ ;
      break;
    }
    case SS_UINT16:
    {
      elSz = sizeof(unsigned short int) /*2ul*/ ;
      break;
    }
    case SS_INT32:
    {
      elSz = sizeof(signed int) /*4ul*/ ;
      break;
    }
    case SS_UINT32:
    {
      elSz = sizeof(unsigned int) /*4ul*/ ;
      break;
    }
    case SS_BOOLEAN:
      elSz = sizeof(unsigned char) /*1ul*/ ;
  }
  return elSz;
}

// rt_InitInfAndNaN
// file ../Stateflow/DockingApproachExample_Ext_grt_rtw/rt_nonfinite.c line 37
extern void rt_InitInfAndNaN(unsigned long int realSize)
{
  (void)realSize;
  rtNaN=rtGetNaN();
  rtNaNF=rtGetNaNF();
  rtInf=rtGetInf();
  rtInfF=rtGetInfF();
  rtMinusInf=rtGetMinusInf();
  rtMinusInfF=rtGetMinusInfF();
}

// rt_InitSignalsStruct
// file ../R2013a/rtw/c/src/rt_logging.c line 1465
static const char * rt_InitSignalsStruct(struct _RTWLogInfo_tag *li, const double startTime, const double finalTime, const double inStepSize, const char **errStatus, struct StructLogVar_Tag *var, signed int maxRows, signed int decimation, double sampleTime, const struct RTWLogSignalInfo_tag *sigInfo)
{
  signed int i;
  signed int sigIdx;
  struct SignalsStruct_Tag *sig = &var->signals;
  signed int nSignals = sigInfo->numSignals;
  const signed int *numCols = sigInfo->numCols;
  const signed int *numDims = sigInfo->numDims;
  const signed int *dims = sigInfo->dims;
  const enum anonymous$35 *dTypes = sigInfo->dataTypes;
  const signed int *cSgnls = sigInfo->complexSignals;
  const signed int *fData = sigInfo->frameData;
  const char **labels = sigInfo->labels.cptr;
  const signed int *plotStyles = sigInfo->plotStyles;
  const char *titles = sigInfo->titles;
  const signed int *titleLen = sigInfo->titleLengths;
  const char **blockNames = sigInfo->blockNames.cptr;
  const char **stateNames = sigInfo->stateNames.cptr;
  const unsigned char *crossMdlRef = sigInfo->crossMdlRef;
  void **currSigDims = sigInfo->currSigDims;
  signed int *currSigDimsSize = sigInfo->currSigDimsSize;
  struct LogVar_Tag *prevValues = (struct LogVar_Tag *)(void *)0;
  signed int dimsOffset = 0;
  unsigned char *isVarDims = sigInfo->isVarDims;
  unsigned char logValueDimensions = (unsigned char)0;
  const struct RTWLogDataTypeConvert_tag *pDTConvInfo = sigInfo->dataTypeConvert;
  *errStatus = (const char *)(void *)0;
  sig->numActiveFields = 1;
  sig->numSignals = nSignals;
  sig->isVarDims = isVarDims;
  i = 0;
  for( ; !(i >= nSignals); i = i + 1)
    if(!(isVarDims[(signed long int)i] == 0))
    {
      logValueDimensions = (unsigned char)1;
      break;
    }

  dimsOffset = 0;
  i = 0;
  signed int tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$3;
  signed int tmp_if_expr$4;
  for( ; !(i >= nSignals); i = i + 1)
  {
    enum anonymous$35 dt;
    if(!(dTypes == ((const enum anonymous$35 *)NULL)))
      tmp_if_expr$1 = (signed int)dTypes[(signed long int)i];

    else
      tmp_if_expr$1 = SS_DOUBLE;
    dt = (enum anonymous$35)tmp_if_expr$1;
    signed int cs;
    if(!(cSgnls == ((const signed int *)NULL)))
      tmp_if_expr$2 = cSgnls[(signed long int)i];

    else
      tmp_if_expr$2 = 0;
    cs = tmp_if_expr$2;
    signed int fd;
    if(!(fData == ((const signed int *)NULL)))
      tmp_if_expr$3 = fData[(signed long int)i];

    else
      tmp_if_expr$3 = 0;
    fd = tmp_if_expr$3;
    signed int rt_InitSignalsStruct$$1$$2$$nd;
    if(!(numDims == ((const signed int *)NULL)))
      tmp_if_expr$4 = numDims[(signed long int)i];

    else
      tmp_if_expr$4 = 1;
    rt_InitSignalsStruct$$1$$2$$nd = tmp_if_expr$4;
    const struct RTWLogDataTypeConvert_tag *pDTConvInfoCur = pDTConvInfo != ((const struct RTWLogDataTypeConvert_tag *)NULL) ? pDTConvInfo + (signed long int)i : ((const struct RTWLogDataTypeConvert_tag *)NULL);
    struct LogVar_Tag *values = (struct LogVar_Tag *)(void *)0;
    enum anonymous$36 logValDimsStat;
    if(logValueDimensions == 0)
      logValDimsStat = (enum anonymous$36)NO_LOGVALDIMS;

    else
      logValDimsStat = (enum anonymous$36)(isVarDims[(signed long int)i] != 0 ? LOGVALDIMS_VARDIMS : LOGVALDIMS_EMPTYMX);
    values=rt_CreateLogVarWithConvert(li, startTime, finalTime, inStepSize, errStatus, &rtLocalLoggingSignalsStructFieldNames[(signed long int)(0 * 64)], dt, pDTConvInfoCur, 0, cs, fd, numCols[(signed long int)i], rt_InitSignalsStruct$$1$$2$$nd, dims + (signed long int)dimsOffset, logValDimsStat, currSigDims + (signed long int)dimsOffset, currSigDimsSize + (signed long int)dimsOffset, maxRows, decimation, sampleTime, 0);
    if(values == (struct LogVar_Tag *)0)
      goto ERROR_EXIT;

    if(sig->values == (struct LogVar_Tag *)0)
      sig->values = values;

    else
      prevValues->next = values;
    prevValues = values;
    dimsOffset = dimsOffset + rt_InitSignalsStruct$$1$$2$$nd;
  }
  if(!(logValueDimensions == 0))
  {
    sig->numActiveFields = sig->numActiveFields + 1;
    sig->logValueDimensions = (unsigned char)1;
  }

  else
    sig->logValueDimensions = (unsigned char)0;
  double *data;
  unsigned long int nbytes;
  signed int dataLen = 0;
  enum anonymous$35 dTypeId;
  dTypeId=rt_GetActualDTypeID((enum anonymous$35)SS_DOUBLE);
  unsigned long int rt_InitSignalsStruct$$1$$5$$dataOffset = (unsigned long int)nSignals * sizeof(struct MatrixData_Tag) /*200ul*/ ;
  unsigned int rt_InitSignalsStruct$$1$$5$$overhang = (unsigned int)(rt_InitSignalsStruct$$1$$5$$dataOffset % sizeof(double) /*8ul*/ );
  if(!(rt_InitSignalsStruct$$1$$5$$overhang == 0u))
    rt_InitSignalsStruct$$1$$5$$dataOffset = rt_InitSignalsStruct$$1$$5$$dataOffset + (sizeof(double) /*8ul*/  - (unsigned long int)rt_InitSignalsStruct$$1$$5$$overhang);

  i = 0;
  signed int tmp_if_expr$5;
  for( ; !(i >= nSignals); i = i + 1)
  {
    signed int nd;
    if(!(numDims == ((const signed int *)NULL)))
      tmp_if_expr$5 = numDims[(signed long int)i];

    else
      tmp_if_expr$5 = 1;
    nd = tmp_if_expr$5;
    dataLen = dataLen + nd;
  }
  nbytes = rt_InitSignalsStruct$$1$$5$$dataOffset + (unsigned long int)dataLen * sizeof(double) /*8ul*/ ;
  void *return_value_calloc$6;
  return_value_calloc$6=calloc(nbytes, (unsigned long int)1);
  sig->dimensions = (struct MatrixData_Tag *)return_value_calloc$6;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$11;
  unsigned long int return_value_strlen$10;
  signed int tmp_post$12;
  signed int tmp_if_expr$18;
  signed int tmp_if_expr$22;
  unsigned long int return_value_strlen$21;
  signed int tmp_post$23;
  signed int tmp_if_expr$28;
  unsigned long int return_value_strlen$27;
  signed int tmp_post$29;
  if(!(sig->dimensions == (struct MatrixData_Tag *)0))
  {
    data = (double *)((char *)sig->dimensions + (signed long int)rt_InitSignalsStruct$$1$$5$$dataOffset);
    i = 0;
    for( ; !(i >= dataLen); i = i + 1)
      data[(signed long int)i] = (double)dims[(signed long int)i];
    i = 0;
    for( ; !(i >= nSignals); i = i + 1)
    {
      struct MatrixData_Tag *rt_InitSignalsStruct$$1$$5$$4$$mtxData = &sig->dimensions[(signed long int)i];
      signed int rt_InitSignalsStruct$$1$$5$$4$$nd;
      if(!(numDims == ((const signed int *)NULL)))
        tmp_if_expr$7 = numDims[(signed long int)i];

      else
        tmp_if_expr$7 = 1;
      rt_InitSignalsStruct$$1$$5$$4$$nd = tmp_if_expr$7;
      memcpy((void *)rt_InitSignalsStruct$$1$$5$$4$$mtxData->name, (const void *)&rtLocalLoggingSignalsStructFieldNames[(signed long int)(2 * 64)], (unsigned long int)64);
      rt_InitSignalsStruct$$1$$5$$4$$mtxData->nRows = 1;
      rt_InitSignalsStruct$$1$$5$$4$$mtxData->nCols = rt_InitSignalsStruct$$1$$5$$4$$nd;
      rt_InitSignalsStruct$$1$$5$$4$$mtxData->nDims = 1;
      rt_InitSignalsStruct$$1$$5$$4$$mtxData->dims = rt_InitSignalsStruct$$1$$5$$4$$mtxData->_dims;
      rt_InitSignalsStruct$$1$$5$$4$$mtxData->dims[(signed long int)0] = rt_InitSignalsStruct$$1$$5$$4$$mtxData->nCols;
      rt_InitSignalsStruct$$1$$5$$4$$mtxData->re = (void *)data;
      rt_InitSignalsStruct$$1$$5$$4$$mtxData->im = (void *)0;
      rt_InitSignalsStruct$$1$$5$$4$$mtxData->dTypeID = (signed int)dTypeId;
      rt_InitSignalsStruct$$1$$5$$4$$mtxData->mxID=rt_GetMxIdFromDTypeId(dTypeId);
      rt_InitSignalsStruct$$1$$5$$4$$mtxData->elSize=rt_GetSizeofDataType(dTypeId);
      rt_InitSignalsStruct$$1$$5$$4$$mtxData->logical = 0U;
      rt_InitSignalsStruct$$1$$5$$4$$mtxData->complex = 0U;
      data = data + (signed long int)rt_InitSignalsStruct$$1$$5$$4$$nd;
    }
    sig->numActiveFields = sig->numActiveFields + 1;
    if(!(labels == (const char **)0))
    {
      signed short int *rt_InitSignalsStruct$$1$$6$$data;
      unsigned long int rt_InitSignalsStruct$$1$$6$$nbytes;
      signed int rt_InitSignalsStruct$$1$$6$$dataLen = 0;
      unsigned long int rt_InitSignalsStruct$$1$$6$$dataOffset = (unsigned long int)nSignals * sizeof(struct MatrixData_Tag) /*200ul*/ ;
      unsigned int rt_InitSignalsStruct$$1$$6$$overhang = (unsigned int)(rt_InitSignalsStruct$$1$$6$$dataOffset % sizeof(signed short int) /*2ul*/ );
      signed int rt_InitSignalsStruct$$1$$6$$dataIdx = 0;
      i = 0;
      for( ; !(i >= nSignals); i = i + 1)
        if(!(labels[(signed long int)i] == (const char *)0))
        {
          unsigned long int return_value_strlen$8;
          //return_value_strlen$8=strlen(labels[(signed long int)i]);
          rt_InitSignalsStruct$$1$$6$$dataLen = rt_InitSignalsStruct$$1$$6$$dataLen + (signed int)return_value_strlen$8;
        }

      if(!(rt_InitSignalsStruct$$1$$6$$overhang == 0u))
        rt_InitSignalsStruct$$1$$6$$dataOffset = rt_InitSignalsStruct$$1$$6$$dataOffset + (sizeof(signed short int) /*2ul*/  - (unsigned long int)rt_InitSignalsStruct$$1$$6$$overhang);

      rt_InitSignalsStruct$$1$$6$$nbytes = rt_InitSignalsStruct$$1$$6$$dataOffset + (unsigned long int)rt_InitSignalsStruct$$1$$6$$dataLen * sizeof(signed short int) /*2ul*/ ;
      void *return_value_calloc$9;
      return_value_calloc$9=calloc(rt_InitSignalsStruct$$1$$6$$nbytes, (unsigned long int)1);
      sig->labels = (struct MatrixData_Tag *)return_value_calloc$9;
      if(sig->labels == (struct MatrixData_Tag *)0)
        goto ERROR_EXIT;

      rt_InitSignalsStruct$$1$$6$$data = (signed short int *)((char *)sig->labels + (signed long int)rt_InitSignalsStruct$$1$$6$$dataOffset);
      sigIdx = 0;
      for( ; !(sigIdx >= nSignals); sigIdx = sigIdx + 1)
      {
        signed int labelLen;
        if(labels[(signed long int)sigIdx] == (const char *)0)
          tmp_if_expr$11 = 0;

        else
        {
          //return_value_strlen$10=strlen(labels[(signed long int)sigIdx]);
          tmp_if_expr$11 = (signed int)return_value_strlen$10;
        }
        labelLen = tmp_if_expr$11;
        i = 0;
        for( ; !(i >= labelLen); i = i + 1)
        {
          tmp_post$12 = rt_InitSignalsStruct$$1$$6$$dataIdx;
          rt_InitSignalsStruct$$1$$6$$dataIdx = rt_InitSignalsStruct$$1$$6$$dataIdx + 1;
          rt_InitSignalsStruct$$1$$6$$data[(signed long int)tmp_post$12] = (signed short int)labels[(signed long int)sigIdx][(signed long int)i];
        }
      }
      i = 0;
      for( ; !(i >= nSignals); i = i + 1)
      {
        struct MatrixData_Tag *rt_InitSignalsStruct$$1$$6$$4$$mtxData = &sig->labels[(signed long int)i];
        signed int rt_InitSignalsStruct$$1$$6$$4$$labelLen;
        unsigned long int return_value_strlen$13;
        //return_value_strlen$13=strlen(labels[(signed long int)i]);
        rt_InitSignalsStruct$$1$$6$$4$$labelLen = (signed int)return_value_strlen$13;
        memcpy((void *)rt_InitSignalsStruct$$1$$6$$4$$mtxData->name, (const void *)&rtLocalLoggingSignalsStructFieldNames[(signed long int)(3 * 64)], (unsigned long int)64);
        rt_InitSignalsStruct$$1$$6$$4$$mtxData->nRows = rt_InitSignalsStruct$$1$$6$$4$$labelLen != 0 ? 1 : 0;
        rt_InitSignalsStruct$$1$$6$$4$$mtxData->nCols = rt_InitSignalsStruct$$1$$6$$4$$labelLen;
        rt_InitSignalsStruct$$1$$6$$4$$mtxData->re = (void *)rt_InitSignalsStruct$$1$$6$$data;
        rt_InitSignalsStruct$$1$$6$$4$$mtxData->im = (void *)0;
        rt_InitSignalsStruct$$1$$6$$4$$mtxData->nDims = 1;
        rt_InitSignalsStruct$$1$$6$$4$$mtxData->dims = rt_InitSignalsStruct$$1$$6$$4$$mtxData->_dims;
        rt_InitSignalsStruct$$1$$6$$4$$mtxData->dims[(signed long int)0] = rt_InitSignalsStruct$$1$$6$$4$$mtxData->nCols;
        rt_InitSignalsStruct$$1$$6$$4$$mtxData->dTypeID = SS_INT16;
        rt_InitSignalsStruct$$1$$6$$4$$mtxData->mxID = (enum anonymous$32)mxCHAR_CLASS;
        rt_InitSignalsStruct$$1$$6$$4$$mtxData->elSize = sizeof(signed short int) /*2ul*/ ;
        rt_InitSignalsStruct$$1$$6$$4$$mtxData->logical = 0U;
        rt_InitSignalsStruct$$1$$6$$4$$mtxData->complex = 0U;
        rt_InitSignalsStruct$$1$$6$$data = rt_InitSignalsStruct$$1$$6$$data + (signed long int)rt_InitSignalsStruct$$1$$6$$4$$labelLen;
      }
      sig->numActiveFields = sig->numActiveFields + 1;
    }

    if(!(plotStyles == (const signed int *)0))
    {
      double *rt_InitSignalsStruct$$1$$7$$data;
      unsigned long int rt_InitSignalsStruct$$1$$7$$nbytes;
      signed int rt_InitSignalsStruct$$1$$7$$dataLen = 0;
      enum anonymous$35 rt_InitSignalsStruct$$1$$7$$dTypeId;
      rt_InitSignalsStruct$$1$$7$$dTypeId=rt_GetActualDTypeID((enum anonymous$35)SS_DOUBLE);
      unsigned long int rt_InitSignalsStruct$$1$$7$$dataOffset = (unsigned long int)nSignals * sizeof(struct MatrixData_Tag) /*200ul*/ ;
      unsigned int rt_InitSignalsStruct$$1$$7$$overhang = (unsigned int)(rt_InitSignalsStruct$$1$$7$$dataOffset % sizeof(double) /*8ul*/ );
      if(!(rt_InitSignalsStruct$$1$$7$$overhang == 0u))
        rt_InitSignalsStruct$$1$$7$$dataOffset = rt_InitSignalsStruct$$1$$7$$dataOffset + (sizeof(double) /*8ul*/  - (unsigned long int)rt_InitSignalsStruct$$1$$7$$overhang);

      i = 0;
      for( ; !(i >= nSignals); i = i + 1)
        rt_InitSignalsStruct$$1$$7$$dataLen = rt_InitSignalsStruct$$1$$7$$dataLen + numCols[(signed long int)i];
      rt_InitSignalsStruct$$1$$7$$nbytes = rt_InitSignalsStruct$$1$$7$$dataOffset + (unsigned long int)rt_InitSignalsStruct$$1$$7$$dataLen * sizeof(double) /*8ul*/ ;
      void *return_value_calloc$14;
      return_value_calloc$14=calloc(rt_InitSignalsStruct$$1$$7$$nbytes, (unsigned long int)1);
      sig->plotStyles = (struct MatrixData_Tag *)return_value_calloc$14;
      if(sig->plotStyles == (struct MatrixData_Tag *)0)
        goto ERROR_EXIT;

      rt_InitSignalsStruct$$1$$7$$data = (double *)((char *)sig->plotStyles + (signed long int)rt_InitSignalsStruct$$1$$7$$dataOffset);
      i = 0;
      for( ; !(i >= rt_InitSignalsStruct$$1$$7$$dataLen); i = i + 1)
        rt_InitSignalsStruct$$1$$7$$data[(signed long int)i] = (double)plotStyles[(signed long int)i];
      dimsOffset = 0;
      i = 0;
      for( ; !(i >= nSignals); i = i + 1)
      {
        struct MatrixData_Tag *rt_InitSignalsStruct$$1$$7$$4$$mtxData = &sig->plotStyles[(signed long int)i];
        memcpy((void *)rt_InitSignalsStruct$$1$$7$$4$$mtxData->name, (const void *)&rtLocalLoggingSignalsStructFieldNames[(signed long int)(5 * 64)], (unsigned long int)64);
        rt_InitSignalsStruct$$1$$7$$4$$mtxData->nRows = numCols[(signed long int)i] != 0 ? 1 : 0;
        rt_InitSignalsStruct$$1$$7$$4$$mtxData->nCols = numCols[(signed long int)i];
        rt_InitSignalsStruct$$1$$7$$4$$mtxData->nDims = numDims[(signed long int)i];
        if(rt_InitSignalsStruct$$1$$7$$4$$mtxData->nDims > 2)
        {
          void *return_value_calloc$15;
          return_value_calloc$15=calloc((unsigned long int)rt_InitSignalsStruct$$1$$7$$4$$mtxData->nDims, sizeof(signed int) /*4ul*/ );
          rt_InitSignalsStruct$$1$$7$$4$$mtxData->dims = (signed int *)return_value_calloc$15;
          if(rt_InitSignalsStruct$$1$$7$$4$$mtxData->dims == (signed int *)0)
            goto ERROR_EXIT;

        }

        else
          rt_InitSignalsStruct$$1$$7$$4$$mtxData->dims = rt_InitSignalsStruct$$1$$7$$4$$mtxData->_dims;
        rt_InitSignalsStruct$$1$$7$$4$$mtxData->dims[(signed long int)0] = dims[(signed long int)dimsOffset];
        if(rt_InitSignalsStruct$$1$$7$$4$$mtxData->nDims >= 2)
        {
          signed int j = 1;
          for( ; !(j >= rt_InitSignalsStruct$$1$$7$$4$$mtxData->nDims); j = j + 1)
            rt_InitSignalsStruct$$1$$7$$4$$mtxData->dims[(signed long int)j] = (dims + (signed long int)dimsOffset)[(signed long int)j];
        }

        rt_InitSignalsStruct$$1$$7$$4$$mtxData->re = (void *)rt_InitSignalsStruct$$1$$7$$data;
        rt_InitSignalsStruct$$1$$7$$4$$mtxData->im = (void *)0;
        rt_InitSignalsStruct$$1$$7$$4$$mtxData->dTypeID = (signed int)rt_InitSignalsStruct$$1$$7$$dTypeId;
        rt_InitSignalsStruct$$1$$7$$4$$mtxData->mxID=rt_GetMxIdFromDTypeId(rt_InitSignalsStruct$$1$$7$$dTypeId);
        rt_InitSignalsStruct$$1$$7$$4$$mtxData->elSize=rt_GetSizeofDataType(rt_InitSignalsStruct$$1$$7$$dTypeId);
        rt_InitSignalsStruct$$1$$7$$4$$mtxData->logical = 0U;
        rt_InitSignalsStruct$$1$$7$$4$$mtxData->complex = 0U;
        rt_InitSignalsStruct$$1$$7$$data = rt_InitSignalsStruct$$1$$7$$data + (signed long int)numCols[(signed long int)i];
        dimsOffset = dimsOffset + numDims[(signed long int)i];
      }
      sig->numActiveFields = sig->numActiveFields + 1;
    }

    if(!(titles == (const char *)0))
    {
      signed short int *rt_InitSignalsStruct$$1$$8$$data;
      unsigned long int rt_InitSignalsStruct$$1$$8$$nbytes;
      signed int rt_InitSignalsStruct$$1$$8$$dataLen;
      unsigned long int return_value_strlen$16;
      //return_value_strlen$16=strlen(titles);
      rt_InitSignalsStruct$$1$$8$$dataLen = (signed int)return_value_strlen$16;
      unsigned long int dataOffset = (unsigned long int)nSignals * sizeof(struct MatrixData_Tag) /*200ul*/ ;
      unsigned int overhang = (unsigned int)(dataOffset % sizeof(signed short int) /*2ul*/ );
      if(!(overhang == 0u))
        dataOffset = dataOffset + (sizeof(signed short int) /*2ul*/  - (unsigned long int)overhang);

      rt_InitSignalsStruct$$1$$8$$nbytes = dataOffset + (unsigned long int)rt_InitSignalsStruct$$1$$8$$dataLen * sizeof(signed short int) /*2ul*/ ;
      void *return_value_calloc$17;
      return_value_calloc$17=calloc(rt_InitSignalsStruct$$1$$8$$nbytes, (unsigned long int)1);
      sig->titles = (struct MatrixData_Tag *)return_value_calloc$17;
      if(sig->titles == (struct MatrixData_Tag *)0)
        goto ERROR_EXIT;

      rt_InitSignalsStruct$$1$$8$$data = (signed short int *)((char *)sig->titles + (signed long int)dataOffset);
      i = 0;
      for( ; !(i >= rt_InitSignalsStruct$$1$$8$$dataLen); i = i + 1)
        rt_InitSignalsStruct$$1$$8$$data[(signed long int)i] = (signed short int)titles[(signed long int)i];
      i = 0;
      for( ; !(i >= nSignals); i = i + 1)
      {
        struct MatrixData_Tag *mtxData = &sig->titles[(signed long int)i];
        memcpy((void *)mtxData->name, (const void *)&rtLocalLoggingSignalsStructFieldNames[(signed long int)(4 * 64)], (unsigned long int)64);
        if(!(titleLen == ((const signed int *)NULL)))
        {
          mtxData->nRows = titleLen[(signed long int)i] != 0 ? 1 : 0;
          mtxData->nCols = titleLen[(signed long int)i];
        }

        else
        {
          mtxData->nRows = rt_InitSignalsStruct$$1$$8$$dataLen != 0 ? 1 : 0;
          mtxData->nCols = rt_InitSignalsStruct$$1$$8$$dataLen;
        }
        mtxData->nDims = 1;
        mtxData->dims = mtxData->_dims;
        mtxData->dims[(signed long int)0] = mtxData->nCols;
        mtxData->re = (void *)rt_InitSignalsStruct$$1$$8$$data;
        mtxData->im = (void *)0;
        mtxData->dTypeID = SS_INT16;
        mtxData->mxID = (enum anonymous$32)mxCHAR_CLASS;
        mtxData->elSize = sizeof(signed short int) /*2ul*/ ;
        mtxData->logical = 0U;
        mtxData->complex = 0U;
        if(!(titleLen == ((const signed int *)NULL)))
          tmp_if_expr$18 = titleLen[(signed long int)i];

        else
          tmp_if_expr$18 = rt_InitSignalsStruct$$1$$8$$dataLen;
        rt_InitSignalsStruct$$1$$8$$data = rt_InitSignalsStruct$$1$$8$$data + (signed long int)tmp_if_expr$18;
      }
      sig->numActiveFields = sig->numActiveFields + 1;
    }

    if(!(blockNames == (const char **)0))
    {
      signed short int *rt_InitSignalsStruct$$1$$9$$data;
      unsigned long int rt_InitSignalsStruct$$1$$9$$nbytes;
      signed int rt_InitSignalsStruct$$1$$9$$dataLen = 0;
      unsigned long int rt_InitSignalsStruct$$1$$9$$dataOffset = (unsigned long int)nSignals * sizeof(struct MatrixData_Tag) /*200ul*/ ;
      unsigned int rt_InitSignalsStruct$$1$$9$$overhang = (unsigned int)(rt_InitSignalsStruct$$1$$9$$dataOffset % sizeof(signed short int) /*2ul*/ );
      signed int dataIdx = 0;
      i = 0;
      for( ; !(i >= nSignals); i = i + 1)
        if(!(blockNames[(signed long int)i] == (const char *)0))
        {
          unsigned long int return_value_strlen$19;
          //return_value_strlen$19=strlen(blockNames[(signed long int)i]);
          rt_InitSignalsStruct$$1$$9$$dataLen = rt_InitSignalsStruct$$1$$9$$dataLen + (signed int)return_value_strlen$19;
        }

      if(!(rt_InitSignalsStruct$$1$$9$$overhang == 0u))
        rt_InitSignalsStruct$$1$$9$$dataOffset = rt_InitSignalsStruct$$1$$9$$dataOffset + (sizeof(signed short int) /*2ul*/  - (unsigned long int)rt_InitSignalsStruct$$1$$9$$overhang);

      rt_InitSignalsStruct$$1$$9$$nbytes = rt_InitSignalsStruct$$1$$9$$dataOffset + (unsigned long int)rt_InitSignalsStruct$$1$$9$$dataLen * sizeof(signed short int) /*2ul*/ ;
      void *return_value_calloc$20;
      return_value_calloc$20=calloc(rt_InitSignalsStruct$$1$$9$$nbytes, (unsigned long int)1);
      sig->blockNames = (struct MatrixData_Tag *)return_value_calloc$20;
      if(sig->blockNames == (struct MatrixData_Tag *)0)
        goto ERROR_EXIT;

      rt_InitSignalsStruct$$1$$9$$data = (signed short int *)((char *)sig->blockNames + (signed long int)rt_InitSignalsStruct$$1$$9$$dataOffset);
      sigIdx = 0;
      for( ; !(sigIdx >= nSignals); sigIdx = sigIdx + 1)
      {
        signed int nameLen;
        if(blockNames[(signed long int)sigIdx] == (const char *)0)
          tmp_if_expr$22 = 0;

        else
        {
          //return_value_strlen$21=strlen(blockNames[(signed long int)sigIdx]);
          tmp_if_expr$22 = (signed int)return_value_strlen$21;
        }
        nameLen = tmp_if_expr$22;
        i = 0;
        for( ; !(i >= nameLen); i = i + 1)
        {
          tmp_post$23 = dataIdx;
          dataIdx = dataIdx + 1;
          rt_InitSignalsStruct$$1$$9$$data[(signed long int)tmp_post$23] = (signed short int)blockNames[(signed long int)sigIdx][(signed long int)i];
        }
      }
      i = 0;
      for( ; !(i >= nSignals); i = i + 1)
      {
        struct MatrixData_Tag *rt_InitSignalsStruct$$1$$9$$4$$mtxData = &sig->blockNames[(signed long int)i];
        signed int blockNameLen;
        unsigned long int return_value_strlen$24;
        //return_value_strlen$24=strlen(blockNames[(signed long int)i]);
        blockNameLen = (signed int)return_value_strlen$24;
        memcpy((void *)rt_InitSignalsStruct$$1$$9$$4$$mtxData->name, (const void *)&rtStructLogVarFieldNames[(signed long int)(2 * 64)], (unsigned long int)64);
        rt_InitSignalsStruct$$1$$9$$4$$mtxData->nRows = blockNameLen != 0 ? 1 : 0;
        rt_InitSignalsStruct$$1$$9$$4$$mtxData->nCols = blockNameLen;
        rt_InitSignalsStruct$$1$$9$$4$$mtxData->nDims = 1;
        rt_InitSignalsStruct$$1$$9$$4$$mtxData->dims = rt_InitSignalsStruct$$1$$9$$4$$mtxData->_dims;
        rt_InitSignalsStruct$$1$$9$$4$$mtxData->dims[(signed long int)0] = rt_InitSignalsStruct$$1$$9$$4$$mtxData->nCols;
        rt_InitSignalsStruct$$1$$9$$4$$mtxData->re = (void *)rt_InitSignalsStruct$$1$$9$$data;
        rt_InitSignalsStruct$$1$$9$$4$$mtxData->im = (void *)0;
        rt_InitSignalsStruct$$1$$9$$4$$mtxData->dTypeID = SS_INT16;
        rt_InitSignalsStruct$$1$$9$$4$$mtxData->mxID = (enum anonymous$32)mxCHAR_CLASS;
        rt_InitSignalsStruct$$1$$9$$4$$mtxData->elSize = sizeof(signed short int) /*2ul*/ ;
        rt_InitSignalsStruct$$1$$9$$4$$mtxData->logical = 0U;
        rt_InitSignalsStruct$$1$$9$$4$$mtxData->complex = 0U;
        rt_InitSignalsStruct$$1$$9$$data = rt_InitSignalsStruct$$1$$9$$data + (signed long int)blockNameLen;
      }
      sig->numActiveFields = sig->numActiveFields + 1;
      if(!(logValueDimensions == 0))
        sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;

      else
        sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;
    }

    else
      if(!(logValueDimensions == 0))
        sig->fieldNames = rtLocalLoggingSignalsStructFieldNames;

      else
        sig->fieldNames = rtLocalLoggingSignalsStructFieldNames_noValDims;
    if(!(stateNames == (const char **)0))
    {
      signed short int *rt_InitSignalsStruct$$1$$11$$data;
      unsigned long int rt_InitSignalsStruct$$1$$11$$nbytes;
      signed int rt_InitSignalsStruct$$1$$11$$dataLen = 0;
      unsigned long int rt_InitSignalsStruct$$1$$11$$dataOffset = (unsigned long int)nSignals * sizeof(struct MatrixData_Tag) /*200ul*/ ;
      unsigned int rt_InitSignalsStruct$$1$$11$$overhang = (unsigned int)(rt_InitSignalsStruct$$1$$11$$dataOffset % sizeof(signed short int) /*2ul*/ );
      signed int rt_InitSignalsStruct$$1$$11$$dataIdx = 0;
      i = 0;
      for( ; !(i >= nSignals); i = i + 1)
        if(!(stateNames[(signed long int)i] == (const char *)0))
        {
          unsigned long int return_value_strlen$25;
          //return_value_strlen$25=strlen(stateNames[(signed long int)i]);
          rt_InitSignalsStruct$$1$$11$$dataLen = rt_InitSignalsStruct$$1$$11$$dataLen + (signed int)return_value_strlen$25;
        }

      if(!(rt_InitSignalsStruct$$1$$11$$overhang == 0u))
        rt_InitSignalsStruct$$1$$11$$dataOffset = rt_InitSignalsStruct$$1$$11$$dataOffset + (sizeof(signed short int) /*2ul*/  - (unsigned long int)rt_InitSignalsStruct$$1$$11$$overhang);

      rt_InitSignalsStruct$$1$$11$$nbytes = rt_InitSignalsStruct$$1$$11$$dataOffset + (unsigned long int)rt_InitSignalsStruct$$1$$11$$dataLen * sizeof(signed short int) /*2ul*/ ;
      void *return_value_calloc$26;
      return_value_calloc$26=calloc(rt_InitSignalsStruct$$1$$11$$nbytes, (unsigned long int)1);
      sig->stateNames = (struct MatrixData_Tag *)return_value_calloc$26;
      if(sig->stateNames == (struct MatrixData_Tag *)0)
        goto ERROR_EXIT;

      rt_InitSignalsStruct$$1$$11$$data = (signed short int *)((char *)sig->stateNames + (signed long int)rt_InitSignalsStruct$$1$$11$$dataOffset);
      sigIdx = 0;
      for( ; !(sigIdx >= nSignals); sigIdx = sigIdx + 1)
      {
        signed int rt_InitSignalsStruct$$1$$11$$3$$nameLen;
        if(stateNames[(signed long int)sigIdx] == (const char *)0)
          tmp_if_expr$28 = 0;

        else
        {
          //return_value_strlen$27=strlen(stateNames[(signed long int)sigIdx]);
          tmp_if_expr$28 = (signed int)return_value_strlen$27;
        }
        rt_InitSignalsStruct$$1$$11$$3$$nameLen = tmp_if_expr$28;
        i = 0;
        for( ; !(i >= rt_InitSignalsStruct$$1$$11$$3$$nameLen); i = i + 1)
        {
          tmp_post$29 = rt_InitSignalsStruct$$1$$11$$dataIdx;
          rt_InitSignalsStruct$$1$$11$$dataIdx = rt_InitSignalsStruct$$1$$11$$dataIdx + 1;
          rt_InitSignalsStruct$$1$$11$$data[(signed long int)tmp_post$29] = (signed short int)stateNames[(signed long int)sigIdx][(signed long int)i];
        }
      }
      i = 0;
      for( ; !(i >= nSignals); i = i + 1)
      {
        struct MatrixData_Tag *rt_InitSignalsStruct$$1$$11$$4$$mtxData = &sig->stateNames[(signed long int)i];
        signed int stateNameLen;
        unsigned long int return_value_strlen$30;
        //return_value_strlen$30=strlen(stateNames[(signed long int)i]);
        stateNameLen = (signed int)return_value_strlen$30;
        memcpy((void *)rt_InitSignalsStruct$$1$$11$$4$$mtxData->name, (const void *)&rtGlobalLoggingSignalsStructFieldNames[(signed long int)(5 * 64)], (unsigned long int)64);
        rt_InitSignalsStruct$$1$$11$$4$$mtxData->nRows = stateNameLen != 0 ? 1 : 0;
        rt_InitSignalsStruct$$1$$11$$4$$mtxData->nCols = stateNameLen;
        rt_InitSignalsStruct$$1$$11$$4$$mtxData->nDims = 1;
        rt_InitSignalsStruct$$1$$11$$4$$mtxData->dims = rt_InitSignalsStruct$$1$$11$$4$$mtxData->_dims;
        rt_InitSignalsStruct$$1$$11$$4$$mtxData->dims[(signed long int)0] = rt_InitSignalsStruct$$1$$11$$4$$mtxData->nCols;
        rt_InitSignalsStruct$$1$$11$$4$$mtxData->re = (void *)rt_InitSignalsStruct$$1$$11$$data;
        rt_InitSignalsStruct$$1$$11$$4$$mtxData->im = (void *)0;
        rt_InitSignalsStruct$$1$$11$$4$$mtxData->dTypeID = SS_INT16;
        rt_InitSignalsStruct$$1$$11$$4$$mtxData->mxID = (enum anonymous$32)mxCHAR_CLASS;
        rt_InitSignalsStruct$$1$$11$$4$$mtxData->elSize = sizeof(signed short int) /*2ul*/ ;
        rt_InitSignalsStruct$$1$$11$$4$$mtxData->logical = 0U;
        rt_InitSignalsStruct$$1$$11$$4$$mtxData->complex = 0U;
        rt_InitSignalsStruct$$1$$11$$data = rt_InitSignalsStruct$$1$$11$$data + (signed long int)stateNameLen;
      }
      sig->numActiveFields = sig->numActiveFields + 1;
      if(!(logValueDimensions == 0))
        sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;

      else
        sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;
    }

    if(!(crossMdlRef == (const unsigned char *)0))
    {
      double *rt_InitSignalsStruct$$1$$12$$data;
      unsigned long int rt_InitSignalsStruct$$1$$12$$nbytes;
      unsigned long int rt_InitSignalsStruct$$1$$12$$dataOffset = (unsigned long int)nSignals * sizeof(struct MatrixData_Tag) /*200ul*/ ;
      unsigned int rt_InitSignalsStruct$$1$$12$$overhang = (unsigned int)(rt_InitSignalsStruct$$1$$12$$dataOffset % sizeof(double) /*8ul*/ );
      if(!(rt_InitSignalsStruct$$1$$12$$overhang == 0u))
        rt_InitSignalsStruct$$1$$12$$dataOffset = rt_InitSignalsStruct$$1$$12$$dataOffset + (sizeof(double) /*8ul*/  - (unsigned long int)rt_InitSignalsStruct$$1$$12$$overhang);

      rt_InitSignalsStruct$$1$$12$$nbytes = rt_InitSignalsStruct$$1$$12$$dataOffset + (unsigned long int)nSignals * sizeof(double) /*8ul*/ ;
      void *return_value_calloc$31;
      return_value_calloc$31=calloc(rt_InitSignalsStruct$$1$$12$$nbytes, (unsigned long int)1);
      sig->crossMdlRef = (struct MatrixData_Tag *)return_value_calloc$31;
      if(sig->crossMdlRef == (struct MatrixData_Tag *)0)
        goto ERROR_EXIT;

      rt_InitSignalsStruct$$1$$12$$data = (double *)((char *)sig->crossMdlRef + (signed long int)rt_InitSignalsStruct$$1$$12$$dataOffset);
      sigIdx = 0;
      for( ; !(sigIdx >= nSignals); sigIdx = sigIdx + 1)
        rt_InitSignalsStruct$$1$$12$$data[(signed long int)sigIdx] = (double)crossMdlRef[(signed long int)sigIdx];
      i = 0;
      for( ; !(i >= nSignals); i = i + 1)
      {
        struct MatrixData_Tag *rt_InitSignalsStruct$$1$$12$$3$$mtxData = &sig->crossMdlRef[(signed long int)i];
        memcpy((void *)rt_InitSignalsStruct$$1$$12$$3$$mtxData->name, (const void *)&rtGlobalLoggingSignalsStructFieldNames[(signed long int)(6 * 64)], (unsigned long int)64);
        rt_InitSignalsStruct$$1$$12$$3$$mtxData->nRows = 1;
        rt_InitSignalsStruct$$1$$12$$3$$mtxData->nCols = 1;
        rt_InitSignalsStruct$$1$$12$$3$$mtxData->nDims = 1;
        rt_InitSignalsStruct$$1$$12$$3$$mtxData->re = (void *)&rt_InitSignalsStruct$$1$$12$$data[(signed long int)i];
        rt_InitSignalsStruct$$1$$12$$3$$mtxData->im = (void *)0;
        rt_InitSignalsStruct$$1$$12$$3$$mtxData->dTypeID = SS_DOUBLE;
        rt_InitSignalsStruct$$1$$12$$3$$mtxData->mxID=rt_GetMxIdFromDTypeId((enum anonymous$35)SS_DOUBLE);
        rt_InitSignalsStruct$$1$$12$$3$$mtxData->elSize = sizeof(double) /*8ul*/ ;
        rt_InitSignalsStruct$$1$$12$$3$$mtxData->logical = (unsigned int)0x200;
        rt_InitSignalsStruct$$1$$12$$3$$mtxData->complex = 0U;
        rt_InitSignalsStruct$$1$$12$$3$$mtxData->frameData = (unsigned int)0;
        rt_InitSignalsStruct$$1$$12$$3$$mtxData->frameSize = (unsigned int)1;
      }
      sig->numActiveFields = sig->numActiveFields + 1;
    }

    return (const char *)(void *)0;
  }


ERROR_EXIT:
  ;
  //fprintf(stderr, "*** Error creating signals structure in the struct log variable %s\n", (const void *)var->name);
  if(*errStatus == (const char *)0)
    *errStatus = rtMemAllocError;

  rt_DestroyLogVar(sig->values);
  if(!(sig->labels == (struct MatrixData_Tag *)0))
    //free((void *)sig->labels);

  if(!(sig->plotStyles == (struct MatrixData_Tag *)0))
    //free((void *)sig->plotStyles);

  if(!(sig->dimensions == (struct MatrixData_Tag *)0))
    //free((void *)sig->dimensions);

  if(!(sig->titles == (struct MatrixData_Tag *)0))
    //free((void *)sig->titles);

  if(!(sig->blockNames == (struct MatrixData_Tag *)0))
    //free((void *)sig->blockNames);

  if(!(sig->stateNames == (struct MatrixData_Tag *)0))
    //free((void *)sig->stateNames);

  if(!(sig->crossMdlRef == (struct MatrixData_Tag *)0))
    //free((void *)sig->crossMdlRef);

  return *errStatus;
}

// rt_InitTimingEngine
// file ../R2013a/rtw/c/src/rt_sim.c line 537
extern const char * rt_InitTimingEngine(struct SimStruct_tag *S)
{
  const char *retVal;
  retVal=rt_SimInitTimingEngine(S->sizes.numSampleTimes, S->mdlInfo->stepSize, S->stInfo.sampleTimes, S->stInfo.offsetTimes, S->mdlInfo->sampleHits, S->stInfo.sampleTimeTaskIDs, S->mdlInfo->tStart, &S->mdlInfo->simTimeStep, &S->mdlInfo->timingData);
  return retVal;
}

// rt_LoadModifiedLogVarName
// file ../R2013a/rtw/c/src/rt_logging.c line 1350
static void rt_LoadModifiedLogVarName(const struct _RTWLogInfo_tag *li, const char *varName, char *logVarName)
{
  signed int nameLen;
  const char *nameModifier = li->logVarNameModifier;
  signed int return_value_strcmp$1;
  if(!(nameModifier == (const char *)0))
  {
    //return_value_strcmp$1=strcmp(nameModifier, "none");
    if(return_value_strcmp$1 == 0)
      nameModifier = (const char *)(void *)0;

  }

  logVarName[(signed long int)(64 - 1)] = (char)0;
  //if(nameModifier == (const char *)0)
    //strncpy(logVarName, varName, (unsigned long int)(64 - 1));

  //else
    if((signed int)*nameModifier == 95)
    {
      //strncpy(logVarName, varName, (unsigned long int)(64 - 1));
      unsigned long int return_value_strlen$2;
      //return_value_strlen$2=strlen(logVarName);
      nameLen = (signed int)return_value_strlen$2;
      //strncat(logVarName, nameModifier, (unsigned long int)((64 - 1) - nameLen));
    }

    else
    {
      //strncpy(logVarName, nameModifier, (unsigned long int)(64 - 1));
      unsigned long int return_value_strlen$3;
      //return_value_strlen$3=strlen(logVarName);
      nameLen = (signed int)return_value_strlen$3;
      //strncat(logVarName, varName, (unsigned long int)((64 - 1) - nameLen));
    }
}

// rt_ODECreateIntegrationData
// file ../R2013a/rtw/c/grt/classic_main.c line 664
extern void rt_ODECreateIntegrationData(struct _ssSolverInfo_tag *si)
{
  /* assertion 0 */
  //assert((_Bool)0);
}

// rt_ODEUpdateContinuousStates
// file ../R2013a/rtw/c/grt/classic_main.c line 667
extern void rt_ODEUpdateContinuousStates(struct _ssSolverInfo_tag *si)
{
  /* assertion 0 */
  //assert((_Bool)0);
}

// rt_OneStep
// file ../R2013a/rtw/c/grt/classic_main.c line 192
static void rt_OneStep(struct tag_RTM_DockingApproachExampl_T *S)
{
  double tnext;
  signed int tmp_post$1 = GBLbuf.isrOverrun;
  GBLbuf.isrOverrun = GBLbuf.isrOverrun + 1;
  if(!(tmp_post$1 == 0))
  {
    GBLbuf.stopExecutionFlag = 1;
    return;
  }

  if(!(S->errorStatus == (const char *)0))
  {
    GBLbuf.stopExecutionFlag = 1;
    return;
  }

  tnext=rt_SimGetNextSampleHit();
  (&S->solverInfo)->solverStopTime = tnext;
  MdlOutputs(0);
  GBLbuf.errmsg=rt_UpdateTXYLogVars(S->rtwLogInfo, S->Timing.t);
  if(!(GBLbuf.errmsg == (const char *)0))
  {
    GBLbuf.stopExecutionFlag = 1;
    return;
  }

  rt_UpdateSigLogVars(S->rtwLogInfo, S->Timing.t);
  MdlUpdate(0);
  rt_SimUpdateDiscreteTaskSampleHits(S->Sizes.numSampTimes, S->Timing.timingData, S->Timing.sampleHits, S->Timing.t);
  if(IEEE_FLOAT_EQUAL(*S->Timing.sampleTimes, 0.0))
    rt_ODEUpdateContinuousStates(&S->solverInfo);

  GBLbuf.isrOverrun = GBLbuf.isrOverrun - 1;
}

// rt_ProcessMatItem
// file ../R2013a/rtw/c/src/rt_logging.c line 554
static signed int rt_ProcessMatItem(struct _IO_FILE *fp, struct MatItem_tag *pItem, enum anonymous$33 itemKind, signed int cmd)
{
  enum anonymous$32 mxID = (enum anonymous$32)mxUNKNOWN_CLASS;
  unsigned int arrayFlags[2l] = { (unsigned int)0, (unsigned int)0 };
  signed int *dims = (signed int *)(void *)0;
  signed int _dims[3l] = { 0, 0, 0 };
  signed int nDims = 2;
  signed int nBytesInItem = 0;
  const char *itemName;
  struct MatItem_tag item;
  signed int retStat = 0;
  const struct MatrixData_Tag *rt_ProcessMatItem$$1$$1$$2$$var;
  const struct StructLogVar_Tag *rt_ProcessMatItem$$1$$1$$3$$var;
  const struct SignalsStruct_Tag *rt_ProcessMatItem$$1$$1$$4$$var;
  switch((signed int)itemKind)
  {
    case DATA_ITEM:
    {
      //fprintf(stderr, "Unexpected itemKind = DATA_ITEM in rt_ProcessMatItem @A\n");
      retStat = -1;
      goto EXIT_POINT;
    }
    case MATRIX_ITEM:
    {
      rt_ProcessMatItem$$1$$1$$2$$var = (const struct MatrixData_Tag *)pItem->data;
      mxID = rt_ProcessMatItem$$1$$1$$2$$var->mxID;
      arrayFlags[(signed long int)0] = (unsigned int)mxID;
      arrayFlags[(signed long int)0] = arrayFlags[(signed long int)0] | rt_ProcessMatItem$$1$$1$$2$$var->logical;
      arrayFlags[(signed long int)0] = arrayFlags[(signed long int)0] | rt_ProcessMatItem$$1$$1$$2$$var->complex;
      if(rt_ProcessMatItem$$1$$1$$2$$var->nDims < 2)
      {
        dims = _dims;
        dims[(signed long int)0] = rt_ProcessMatItem$$1$$1$$2$$var->nRows;
        dims[(signed long int)1] = rt_ProcessMatItem$$1$$1$$2$$var->nCols;
        nDims = 2;
      }

      else
        if(rt_ProcessMatItem$$1$$1$$2$$var->nDims >= 2)
        {
          signed int k;
          void *return_value_malloc$1;
          return_value_malloc$1=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)(rt_ProcessMatItem$$1$$1$$2$$var->nDims + 1));
          dims = (signed int *)return_value_malloc$1;
          k = 0;
          for( ; !(k >= rt_ProcessMatItem$$1$$1$$2$$var->nDims); k = k + 1)
            dims[(signed long int)k] = rt_ProcessMatItem$$1$$1$$2$$var->dims[(signed long int)k];
          dims[(signed long int)rt_ProcessMatItem$$1$$1$$2$$var->nDims] = rt_ProcessMatItem$$1$$1$$2$$var->nRows;
          nDims = rt_ProcessMatItem$$1$$1$$2$$var->nDims + 1;
        }

      itemName = rt_ProcessMatItem$$1$$1$$2$$var->name;
      break;
    }
    case STRUCT_LOG_VAR_ITEM:
    {
      rt_ProcessMatItem$$1$$1$$3$$var = (const struct StructLogVar_Tag *)pItem->data;
      mxID = (enum anonymous$32)mxSTRUCT_CLASS;
      arrayFlags[(signed long int)0] = (unsigned int)mxID;
      dims = _dims;
      dims[(signed long int)0] = 1;
      dims[(signed long int)1] = 1;
      itemName = rt_ProcessMatItem$$1$$1$$3$$var->name;
      break;
    }
    case SIGNALS_STRUCT_ITEM:
    {
      rt_ProcessMatItem$$1$$1$$4$$var = (const struct SignalsStruct_Tag *)pItem->data;
      mxID = (enum anonymous$32)mxSTRUCT_CLASS;
      arrayFlags[(signed long int)0] = (unsigned int)mxID;
      dims = _dims;
      dims[(signed long int)0] = 1;
      dims[(signed long int)1] = rt_ProcessMatItem$$1$$1$$4$$var->numSignals;
      itemName = &rtStructLogVarFieldNames[(signed long int)(1 * 64)];
      break;
    }
    default:
    {
      //fprintf(stderr, "Unexpected itemKind=%d in rt_ProcessMatItem @B\n", itemKind);
      retStat = -1;
      goto EXIT_POINT;
    }
  }
  item.nbytes = (unsigned int)((unsigned long int)2 * sizeof(unsigned int) /*4ul*/ );
  if(!(cmd == 0))
  {
    item.type = 6;
    item.data = (const void *)arrayFlags;
    signed int return_value_rt_WriteItemToMatFile$2;
    return_value_rt_WriteItemToMatFile$2=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)DATA_ITEM);
    if(!(return_value_rt_WriteItemToMatFile$2 == 0))
    {
      retStat = 1;
      goto EXIT_POINT;
    }

  }

  else
    nBytesInItem = nBytesInItem + (signed int)((unsigned int)((sizeof(signed int) /*4ul*/  << 1) + (unsigned long int)item.nbytes) + (unsigned int)7 & (unsigned int)~7);
  item.nbytes = (unsigned int)((unsigned long int)nDims * sizeof(signed int) /*4ul*/ );
  if(!(cmd == 0))
  {
    item.type = 5;
    item.data = (const void *)dims;
    signed int return_value_rt_WriteItemToMatFile$3;
    return_value_rt_WriteItemToMatFile$3=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)DATA_ITEM);
    if(!(return_value_rt_WriteItemToMatFile$3 == 0))
    {
      retStat = 1;
      goto EXIT_POINT;
    }

  }

  else
    nBytesInItem = nBytesInItem + (signed int)((unsigned int)((sizeof(signed int) /*4ul*/  << 1) + (unsigned long int)item.nbytes) + (unsigned int)7 & (unsigned int)~7);
  unsigned long int return_value_strlen$4;
  //return_value_strlen$4=strlen(itemName);
  item.nbytes = (unsigned int)(signed int)return_value_strlen$4;
  if(!(cmd == 0))
  {
    item.type = 1;
    item.data = (const void *)(const char *)itemName;
    signed int return_value_rt_WriteItemToMatFile$5;
    return_value_rt_WriteItemToMatFile$5=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)DATA_ITEM);
    if(!(return_value_rt_WriteItemToMatFile$5 == 0))
    {
      retStat = 1;
      goto EXIT_POINT;
    }

  }

  else
    nBytesInItem = nBytesInItem + (signed int)(item.nbytes <= (unsigned int)4 ? sizeof(signed int) /*4ul*/  << 1 : (unsigned long int)((unsigned int)((sizeof(signed int) /*4ul*/  << 1) + (unsigned long int)item.nbytes) + (unsigned int)7 & (unsigned int)~7));
  const struct StructLogVar_Tag *var;
  const struct SignalsStruct_Tag *rt_ProcessMatItem$$1$$9$$1$$2$$var;
  const struct StructLogVar_Tag *rt_ProcessMatItem$$1$$9$$4$$1$$var;
  const struct SignalsStruct_Tag *rt_ProcessMatItem$$1$$9$$4$$2$$var;
  const struct LogVar_Tag *values;
  const struct MatrixData_Tag *dimensions;
  const struct MatrixData_Tag *labels;
  const struct MatrixData_Tag *plotStyles;
  const struct MatrixData_Tag *titles;
  const struct MatrixData_Tag *blockNames;
  const struct MatrixData_Tag *stateNames;
  const struct MatrixData_Tag *crossMdlRef;
  unsigned char logValueDimensions;
  signed int i;
  if((signed int)itemKind == MATRIX_ITEM)
  {
    const struct MatrixData_Tag *rt_ProcessMatItem$$1$$8$$var = (const struct MatrixData_Tag *)pItem->data;
    signed int matID;
    matID=rt_GetMatIdFromMxId(mxID);
    unsigned long int elSize = rt_ProcessMatItem$$1$$8$$var->elSize;
    item.nbytes = (unsigned int)(signed int)((unsigned long int)(rt_ProcessMatItem$$1$$8$$var->nRows * rt_ProcessMatItem$$1$$8$$var->nCols) * elSize);
    if(!(cmd == 0))
    {
      item.type = matID;
      item.data = rt_ProcessMatItem$$1$$8$$var->re;
      signed int return_value_rt_WriteItemToMatFile$6;
      return_value_rt_WriteItemToMatFile$6=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)DATA_ITEM);
      if(!(return_value_rt_WriteItemToMatFile$6 == 0))
      {
        retStat = 1;
        goto EXIT_POINT;
      }

    }

    else
      nBytesInItem = nBytesInItem + (signed int)(item.nbytes <= (unsigned int)4 ? sizeof(signed int) /*4ul*/  << 1 : (unsigned long int)((unsigned int)((sizeof(signed int) /*4ul*/  << 1) + (unsigned long int)item.nbytes) + (unsigned int)7 & (unsigned int)~7));
    if(!(rt_ProcessMatItem$$1$$8$$var->complex == 0u))
    {
      item.nbytes = (unsigned int)(signed int)((unsigned long int)(rt_ProcessMatItem$$1$$8$$var->nRows * rt_ProcessMatItem$$1$$8$$var->nCols) * elSize);
      if(!(cmd == 0))
      {
        item.type = matID;
        item.data = rt_ProcessMatItem$$1$$8$$var->im;
        signed int return_value_rt_WriteItemToMatFile$7;
        return_value_rt_WriteItemToMatFile$7=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)DATA_ITEM);
        if(!(return_value_rt_WriteItemToMatFile$7 == 0))
        {
          retStat = 1;
          goto EXIT_POINT;
        }

      }

      else
        nBytesInItem = nBytesInItem + (signed int)(item.nbytes <= (unsigned int)4 ? sizeof(signed int) /*4ul*/  << 1 : (unsigned long int)((unsigned int)((sizeof(signed int) /*4ul*/  << 1) + (unsigned long int)item.nbytes) + (unsigned int)7 & (unsigned int)~7));
    }

  }

  else
  {
    const char *fieldNames;
    signed int sizeofFieldNames;
    switch((signed int)itemKind)
    {
      case STRUCT_LOG_VAR_ITEM:
      {
        var = (const struct StructLogVar_Tag *)pItem->data;
        fieldNames = rtStructLogVarFieldNames;
        sizeofFieldNames = var->numActiveFields * 64;
        break;
      }
      case SIGNALS_STRUCT_ITEM:
      {
        rt_ProcessMatItem$$1$$9$$1$$2$$var = (const struct SignalsStruct_Tag *)pItem->data;
        fieldNames = rt_ProcessMatItem$$1$$9$$1$$2$$var->fieldNames;
        sizeofFieldNames = rt_ProcessMatItem$$1$$9$$1$$2$$var->numActiveFields * 64;
        break;
      }
      default:
      {
        //fprintf(stderr, "Unexpected itemKind=%d in rt_ProcessMatItem @C\n", itemKind);
        retStat = -1;
        goto EXIT_POINT;
      }
    }
    if(!(cmd == 0))
    {
      signed int tmpInt = 64;
      item.nbytes = (unsigned int)sizeof(signed int) /*4ul*/ ;
      item.type = 5;
      item.data = (const void *)&tmpInt;
      signed int return_value_rt_WriteItemToMatFile$8;
      return_value_rt_WriteItemToMatFile$8=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)DATA_ITEM);
      if(!(return_value_rt_WriteItemToMatFile$8 == 0))
      {
        retStat = 1;
        goto EXIT_POINT;
      }

      item.nbytes = (unsigned int)sizeofFieldNames;
      item.type = 1;
      item.data = (const void *)(const char *)fieldNames;
      signed int return_value_rt_WriteItemToMatFile$9;
      return_value_rt_WriteItemToMatFile$9=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)DATA_ITEM);
      if(!(return_value_rt_WriteItemToMatFile$9 == 0))
      {
        retStat = 1;
        goto EXIT_POINT;
      }

    }

    else
      nBytesInItem = nBytesInItem + (signed int)((unsigned int)((sizeof(signed int) /*4ul*/  << 1) + (sizeof(signed int) /*4ul*/  << 1) + (unsigned long int)sizeofFieldNames) + (unsigned int)7 & (unsigned int)~7);
    switch((signed int)itemKind)
    {
      case STRUCT_LOG_VAR_ITEM:
      {
        rt_ProcessMatItem$$1$$9$$4$$1$$var = (const struct StructLogVar_Tag *)pItem->data;
        const void *data = rt_ProcessMatItem$$1$$9$$4$$1$$var->time;
        if(!(rt_ProcessMatItem$$1$$9$$4$$1$$var->logTime == 0))
          data = (const void *)&((const struct LogVar_Tag *)rt_ProcessMatItem$$1$$9$$4$$1$$var->time)->data;

        item.type = 14;
        item.data = data;
        if(!(cmd == 0))
        {
          signed int return_value_rt_WriteItemToMatFile$10;
          return_value_rt_WriteItemToMatFile$10=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)MATRIX_ITEM);
          if(!(return_value_rt_WriteItemToMatFile$10 == 0))
          {
            retStat = 1;
            goto EXIT_POINT;
          }

        }

        else
        {
          signed int return_value_rt_ProcessMatItem$11;
          return_value_rt_ProcessMatItem$11=rt_ProcessMatItem(fp, &item, (enum anonymous$33)MATRIX_ITEM, 0);
          if(!(return_value_rt_ProcessMatItem$11 == 0))
          {
            retStat = 1;
            goto EXIT_POINT;
          }

          nBytesInItem = nBytesInItem + (signed int)((unsigned long int)item.nbytes + (sizeof(signed int) /*4ul*/  << 1));
        }
        item.type = 14;
        item.data = (const void *)&rt_ProcessMatItem$$1$$9$$4$$1$$var->signals;
        if(!(cmd == 0))
        {
          signed int return_value_rt_WriteItemToMatFile$12;
          return_value_rt_WriteItemToMatFile$12=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)SIGNALS_STRUCT_ITEM);
          if(!(return_value_rt_WriteItemToMatFile$12 == 0))
          {
            retStat = 1;
            goto EXIT_POINT;
          }

        }

        else
        {
          signed int return_value_rt_ProcessMatItem$13;
          return_value_rt_ProcessMatItem$13=rt_ProcessMatItem(fp, &item, (enum anonymous$33)SIGNALS_STRUCT_ITEM, 0);
          if(!(return_value_rt_ProcessMatItem$13 == 0))
          {
            retStat = 1;
            goto EXIT_POINT;
          }

          nBytesInItem = nBytesInItem + (signed int)((unsigned long int)item.nbytes + (sizeof(signed int) /*4ul*/  << 1));
        }
        if(!(rt_ProcessMatItem$$1$$9$$4$$1$$var->blockName == (struct MatrixData_Tag *)0))
        {
          item.type = 14;
          item.data = (const void *)rt_ProcessMatItem$$1$$9$$4$$1$$var->blockName;
          if(!(cmd == 0))
          {
            signed int return_value_rt_WriteItemToMatFile$14;
            return_value_rt_WriteItemToMatFile$14=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)MATRIX_ITEM);
            if(!(return_value_rt_WriteItemToMatFile$14 == 0))
            {
              retStat = 1;
              goto EXIT_POINT;
            }

          }

          else
          {
            signed int return_value_rt_ProcessMatItem$15;
            return_value_rt_ProcessMatItem$15=rt_ProcessMatItem(fp, &item, (enum anonymous$33)MATRIX_ITEM, 0);
            if(!(return_value_rt_ProcessMatItem$15 == 0))
            {
              retStat = 1;
              goto EXIT_POINT;
            }

            nBytesInItem = nBytesInItem + (signed int)((unsigned long int)item.nbytes + (sizeof(signed int) /*4ul*/  << 1));
          }
        }

        break;
      }
      case SIGNALS_STRUCT_ITEM:
      {
        rt_ProcessMatItem$$1$$9$$4$$2$$var = (const struct SignalsStruct_Tag *)pItem->data;
        values = rt_ProcessMatItem$$1$$9$$4$$2$$var->values;
        dimensions = rt_ProcessMatItem$$1$$9$$4$$2$$var->dimensions;
        labels = rt_ProcessMatItem$$1$$9$$4$$2$$var->labels;
        plotStyles = rt_ProcessMatItem$$1$$9$$4$$2$$var->plotStyles;
        titles = rt_ProcessMatItem$$1$$9$$4$$2$$var->titles;
        blockNames = rt_ProcessMatItem$$1$$9$$4$$2$$var->blockNames;
        stateNames = rt_ProcessMatItem$$1$$9$$4$$2$$var->stateNames;
        crossMdlRef = rt_ProcessMatItem$$1$$9$$4$$2$$var->crossMdlRef;
        logValueDimensions = rt_ProcessMatItem$$1$$9$$4$$2$$var->logValueDimensions;
        i = 0;
        for( ; !(i >= rt_ProcessMatItem$$1$$9$$4$$2$$var->numSignals); i = i + 1)
        {
          item.type = 14;
          item.data = (const void *)&values->data;
          if(!(cmd == 0))
          {
            signed int return_value_rt_WriteItemToMatFile$16;
            return_value_rt_WriteItemToMatFile$16=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)MATRIX_ITEM);
            if(!(return_value_rt_WriteItemToMatFile$16 == 0))
            {
              retStat = 1;
              goto EXIT_POINT;
            }

          }

          else
          {
            signed int return_value_rt_ProcessMatItem$17;
            return_value_rt_ProcessMatItem$17=rt_ProcessMatItem(fp, &item, (enum anonymous$33)MATRIX_ITEM, 0);
            if(!(return_value_rt_ProcessMatItem$17 == 0))
            {
              retStat = 1;
              goto EXIT_POINT;
            }

            nBytesInItem = nBytesInItem + (signed int)((unsigned long int)item.nbytes + (sizeof(signed int) /*4ul*/  << 1));
          }
          if(!(logValueDimensions == 0))
          {
            struct MatrixData_Tag tempData;
            memcpy((void *)tempData.name, (const void *)&rtLocalLoggingSignalsStructFieldNames[(signed long int)(1 * 64)], (unsigned long int)64);
            tempData.nRows = values->valDims->nRows;
            tempData.nCols = values->valDims->nCols;
            tempData.nDims = 1;
            tempData._dims[(signed long int)0] = values->valDims->nCols;
            tempData.re = (void *)values->valDims->dimsData;
            tempData.im = (void *)0;
            tempData.dTypeID = SS_DOUBLE;
            tempData.elSize = sizeof(double) /*8ul*/ ;
            tempData.mxID = (enum anonymous$32)mxDOUBLE_CLASS;
            tempData.logical = (unsigned int)0;
            tempData.complex = (unsigned int)0;
            tempData.frameData = (unsigned int)0;
            tempData.frameSize = (unsigned int)1;
            item.type = 14;
            item.data = (const void *)&tempData;
            if(!(cmd == 0))
            {
              signed int return_value_rt_WriteItemToMatFile$18;
              return_value_rt_WriteItemToMatFile$18=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)MATRIX_ITEM);
              if(!(return_value_rt_WriteItemToMatFile$18 == 0))
              {
                retStat = 1;
                goto EXIT_POINT;
              }

            }

            else
            {
              signed int return_value_rt_ProcessMatItem$19;
              return_value_rt_ProcessMatItem$19=rt_ProcessMatItem(fp, &item, (enum anonymous$33)MATRIX_ITEM, 0);
              if(!(return_value_rt_ProcessMatItem$19 == 0))
              {
                retStat = 1;
                goto EXIT_POINT;
              }

              nBytesInItem = nBytesInItem + (signed int)((unsigned long int)item.nbytes + (sizeof(signed int) /*4ul*/  << 1));
            }
          }

          values = values->next;
          if(!(dimensions == (const struct MatrixData_Tag *)0))
          {
            item.type = 14;
            item.data = (const void *)&dimensions[(signed long int)i];
            if(!(cmd == 0))
            {
              signed int return_value_rt_WriteItemToMatFile$20;
              return_value_rt_WriteItemToMatFile$20=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)MATRIX_ITEM);
              if(!(return_value_rt_WriteItemToMatFile$20 == 0))
              {
                retStat = 1;
                goto EXIT_POINT;
              }

            }

            else
            {
              signed int return_value_rt_ProcessMatItem$21;
              return_value_rt_ProcessMatItem$21=rt_ProcessMatItem(fp, &item, (enum anonymous$33)MATRIX_ITEM, 0);
              if(!(return_value_rt_ProcessMatItem$21 == 0))
              {
                retStat = 1;
                goto EXIT_POINT;
              }

              nBytesInItem = nBytesInItem + (signed int)((unsigned long int)item.nbytes + (sizeof(signed int) /*4ul*/  << 1));
            }
          }

          item.type = 14;
          item.data = (const void *)&labels[(signed long int)i];
          if(!(cmd == 0))
          {
            signed int return_value_rt_WriteItemToMatFile$22;
            return_value_rt_WriteItemToMatFile$22=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)MATRIX_ITEM);
            if(!(return_value_rt_WriteItemToMatFile$22 == 0))
            {
              retStat = 1;
              goto EXIT_POINT;
            }

          }

          else
          {
            signed int return_value_rt_ProcessMatItem$23;
            return_value_rt_ProcessMatItem$23=rt_ProcessMatItem(fp, &item, (enum anonymous$33)MATRIX_ITEM, 0);
            if(!(return_value_rt_ProcessMatItem$23 == 0))
            {
              retStat = 1;
              goto EXIT_POINT;
            }

            nBytesInItem = nBytesInItem + (signed int)((unsigned long int)item.nbytes + (sizeof(signed int) /*4ul*/  << 1));
          }
          if(!(titles == (const struct MatrixData_Tag *)0))
          {
            item.type = 14;
            item.data = (const void *)&titles[(signed long int)i];
            if(!(cmd == 0))
            {
              signed int return_value_rt_WriteItemToMatFile$24;
              return_value_rt_WriteItemToMatFile$24=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)MATRIX_ITEM);
              if(!(return_value_rt_WriteItemToMatFile$24 == 0))
              {
                retStat = 1;
                goto EXIT_POINT;
              }

            }

            else
            {
              signed int return_value_rt_ProcessMatItem$25;
              return_value_rt_ProcessMatItem$25=rt_ProcessMatItem(fp, &item, (enum anonymous$33)MATRIX_ITEM, 0);
              if(!(return_value_rt_ProcessMatItem$25 == 0))
              {
                retStat = 1;
                goto EXIT_POINT;
              }

              nBytesInItem = nBytesInItem + (signed int)((unsigned long int)item.nbytes + (sizeof(signed int) /*4ul*/  << 1));
            }
          }

          if(!(plotStyles == (const struct MatrixData_Tag *)0))
          {
            item.type = 14;
            item.data = (const void *)&plotStyles[(signed long int)i];
            if(!(cmd == 0))
            {
              signed int return_value_rt_WriteItemToMatFile$26;
              return_value_rt_WriteItemToMatFile$26=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)MATRIX_ITEM);
              if(!(return_value_rt_WriteItemToMatFile$26 == 0))
              {
                retStat = 1;
                goto EXIT_POINT;
              }

            }

            else
            {
              signed int return_value_rt_ProcessMatItem$27;
              return_value_rt_ProcessMatItem$27=rt_ProcessMatItem(fp, &item, (enum anonymous$33)MATRIX_ITEM, 0);
              if(!(return_value_rt_ProcessMatItem$27 == 0))
              {
                retStat = 1;
                goto EXIT_POINT;
              }

              nBytesInItem = nBytesInItem + (signed int)((unsigned long int)item.nbytes + (sizeof(signed int) /*4ul*/  << 1));
            }
          }

          if(!(blockNames == (const struct MatrixData_Tag *)0))
          {
            item.type = 14;
            item.data = (const void *)&blockNames[(signed long int)i];
            if(!(cmd == 0))
            {
              signed int return_value_rt_WriteItemToMatFile$28;
              return_value_rt_WriteItemToMatFile$28=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)MATRIX_ITEM);
              if(!(return_value_rt_WriteItemToMatFile$28 == 0))
              {
                retStat = 1;
                goto EXIT_POINT;
              }

            }

            else
            {
              signed int return_value_rt_ProcessMatItem$29;
              return_value_rt_ProcessMatItem$29=rt_ProcessMatItem(fp, &item, (enum anonymous$33)MATRIX_ITEM, 0);
              if(!(return_value_rt_ProcessMatItem$29 == 0))
              {
                retStat = 1;
                goto EXIT_POINT;
              }

              nBytesInItem = nBytesInItem + (signed int)((unsigned long int)item.nbytes + (sizeof(signed int) /*4ul*/  << 1));
            }
          }

          if(!(stateNames == (const struct MatrixData_Tag *)0))
          {
            item.type = 14;
            item.data = (const void *)&stateNames[(signed long int)i];
            if(!(cmd == 0))
            {
              signed int return_value_rt_WriteItemToMatFile$30;
              return_value_rt_WriteItemToMatFile$30=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)MATRIX_ITEM);
              if(!(return_value_rt_WriteItemToMatFile$30 == 0))
              {
                retStat = 1;
                goto EXIT_POINT;
              }

            }

            else
            {
              signed int return_value_rt_ProcessMatItem$31;
              return_value_rt_ProcessMatItem$31=rt_ProcessMatItem(fp, &item, (enum anonymous$33)MATRIX_ITEM, 0);
              if(!(return_value_rt_ProcessMatItem$31 == 0))
              {
                retStat = 1;
                goto EXIT_POINT;
              }

              nBytesInItem = nBytesInItem + (signed int)((unsigned long int)item.nbytes + (sizeof(signed int) /*4ul*/  << 1));
            }
          }

          if(!(crossMdlRef == (const struct MatrixData_Tag *)0))
          {
            item.type = 14;
            item.data = (const void *)&crossMdlRef[(signed long int)i];
            if(!(cmd == 0))
            {
              signed int return_value_rt_WriteItemToMatFile$32;
              return_value_rt_WriteItemToMatFile$32=rt_WriteItemToMatFile(fp, &item, (enum anonymous$33)MATRIX_ITEM);
              if(!(return_value_rt_WriteItemToMatFile$32 == 0))
              {
                retStat = 1;
                goto EXIT_POINT;
              }

            } else
            {
              signed int return_value_rt_ProcessMatItem$33;
              return_value_rt_ProcessMatItem$33=rt_ProcessMatItem(fp, &item, (enum anonymous$33)MATRIX_ITEM, 0);
              if(!(return_value_rt_ProcessMatItem$33 == 0))
              {
                retStat = 1;
                goto EXIT_POINT;
              }

              nBytesInItem = nBytesInItem + (signed int)((unsigned long int)item.nbytes + (sizeof(signed int) /*4ul*/  << 1));
            }
          }

        }
        break;
      }
      default:
      {
        //fprintf(stderr, "Unexpected itemKind=%d in rt_ProcessMatItem @D\n", itemKind);
        retStat = -1;
        goto EXIT_POINT;
      }
    }
  }
  if(cmd == 0)
    pItem->nbytes = (unsigned int)nBytesInItem;


EXIT_POINT:
  ;
  if(!(dims == _dims))
  {
    //if(!(dims == (signed int *)0))
      //free((void *)dims);

  }

  return retStat;
}

// rt_ReallocLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 2311
void rt_ReallocLogVar(struct LogVar_Tag *var, unsigned char isVarDims)
{
  void *tmp;
  signed int nCols = var->data.nCols;
  signed int nRows = var->data.nRows + 1024;
  unsigned long int elSize = var->data.elSize;
  //tmp=realloc(var->data.re, (unsigned long int)(nRows * nCols) * elSize);
  if(tmp == (void *)0)
  {
    //fprintf(stderr, "*** Memory allocation error.\n");
    //fprintf(stderr, "    varName          = %s%s\n    nRows            = %d\n    nCols            = %d\n    elementSize      = %lu\n    Current Size     = %.16g\n    Failed resize    = %.16g\n\n", (const void *)var->data.name, var->data.complex != 0u ? " (real part)" : "", var->data.nRows, var->data.nCols, (signed long int)var->data.elSize, (double)nRows * (double)nCols * (double)elSize, (double)(nRows + 1024) * (double)nCols * (double)elSize);
    //exit(1);
  }

  var->data.re = tmp;
  if(!(var->data.complex == 0u))
  {
    //tmp=realloc(var->data.im, (unsigned long int)(nRows * nCols) * elSize);
    if(tmp == (void *)0)
    {
      //fprintf(stderr, "*** Memory allocation error.\n");
      //fprintf(stderr, "    varName          = %s (complex part)\n    nRows            = %d\n    nCols            = %d\n    elementSize      = %lu\n    Current Size     = %.16g\n    Failed resize    = %.16g\n\n", (const void *)var->data.name, var->data.nRows, var->data.nCols, (signed long int)var->data.elSize, (double)nRows * (double)nCols * (double)elSize, (double)(nRows + 1024) * (double)nCols * (double)elSize);
      //exit(1);
    }

    var->data.im = tmp;
  }

  var->data.nRows = nRows;
  if(!(isVarDims == 0))
  {
    signed int k;
    nCols = var->valDims->nCols;
    nRows = var->valDims->nRows + 1024;
    elSize = sizeof(double) /*8ul*/ ;
    //tmp=realloc((void *)var->valDims->dimsData, (unsigned long int)(nRows * nCols) * elSize);
    if(tmp == (void *)0)
    {
      //fprintf(stderr, "*** Memory allocation error.\n");
      //fprintf(stderr, "    varName          = %s\n    nRows            = %d\n    nCols            = %d\n    elementSize      = %lu\n    Current Size     = %.16g\n    Failed resize    = %.16g\n\n", (const void *)var->valDims->name, var->valDims->nRows, var->valDims->nCols, (signed long int)elSize, (double)nRows * (double)nCols * (double)elSize, (double)(nRows + 1024) * (double)nCols * (double)elSize);
      //exit(1);
    }

    k = var->data.nDims - 1;
    for( ; k > 0; k = k - 1)
      memcpy((void *)((double *)tmp + (signed long int)(k * nRows)), (const void *)((double *)tmp + (signed long int)(k * var->valDims->nRows)), elSize * (unsigned long int)var->valDims->nRows);
    var->valDims->dimsData = (double *)tmp;
    var->valDims->nRows = nRows;
  }

}

// rt_SimGetNextSampleHit
// file ../R2013a/rtw/c/src/rt_sim.c line 278
extern double rt_SimGetNextSampleHit(void)
{
  double timeOfNextHit;
  struct TimingData_Tag *td;
  signed int rtmNumSampTimes;
  td = &td_struct;
  rtmNumSampTimes = 10;
  td->clockTick[(signed long int)0] = td->clockTick[(signed long int)0] + (double)1;
  timeOfNextHit = td->clockTick[(signed long int)0] * td->period[(signed long int)0];
  if(rtmNumSampTimes > 1)
  {
    signed int i = 1;
    for( ; !(i >= rtmNumSampTimes); i = i + 1)
    {
      td->taskTick[(signed long int)i] = td->taskTick[(signed long int)i] + 1;
      if(td->taskTick[(signed long int)i] == td->nTaskTicks[(signed long int)i])
      {
        td->taskTick[(signed long int)i] = 0;
        td->clockTick[(signed long int)i] = td->clockTick[(signed long int)i] + 1.000000;
      }

    }
  }

  return timeOfNextHit;
}

// rt_SimInitTimingEngine
// file ../R2013a/rtw/c/src/rt_sim.c line 87
extern const char * rt_SimInitTimingEngine(signed int rtmNumSampTimes, double rtmStepSize, double *rtmSampleTimePtr, double *rtmOffsetTimePtr, signed int *rtmSampleHitPtr, signed int *rtmSampleTimeTaskIDPtr, double rtmTStart, enum anonymous$34 *rtmSimTimeStepPtr, void **rtmTimingDataPtr)
{
  signed int i;
  signed int *tsMap = rtmSampleTimeTaskIDPtr;
  double *period = rtmSampleTimePtr;
  double *offset = rtmOffsetTimePtr;
  signed int *sampleHit = rtmSampleHitPtr;
  double stepSize = rtmStepSize;
  struct TimingData_Tag *td = &td_struct;
  rtmNumSampTimes = 10;
  //if(IEEE_FLOAT_NOTEQUAL(rtmTStart, 0.0))
    //return "Start time must be zero for real-time systems.  For non-zero start times you must use the Simulink solver module";

  *rtmSimTimeStepPtr = (enum anonymous$34)MAJOR_TIME_STEP;
  *rtmTimingDataPtr = (void *)&td;
  i = 0;
  _Bool tmp_if_expr$3;
  // ~MDC Upsets learn in prior form:
  for( ; !(i >= nondet_int()); i = i + 1)
  {
    tsMap[(signed long int)i] = i;
    td->period[(signed long int)i] = period[(signed long int)i];
    td->offset[(signed long int)i] = offset[(signed long int)i];
    double return_value_floor$1;
    //return_value_floor$1=floor(period[(signed long int)i] / stepSize + 0.5);
    td->nTaskTicks[(signed long int)i] = (signed int)return_value_floor$1;
    if(IEEE_FLOAT_EQUAL(td->period[(signed long int)i], 0.0))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = IEEE_FLOAT_EQUAL(td->offset[(signed long int)i], 0.0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      td->taskTick[(signed long int)i] = 0;
      td->clockTick[(signed long int)i] = 0.0;
      sampleHit[(signed long int)i] = 1;
    }

    else
    {
      double return_value_floor$2;
      //return_value_floor$2=floor((td->period[(signed long int)i] - td->offset[(signed long int)i]) / stepSize + 0.5);
      td->taskTick[(signed long int)i] = (signed int)return_value_floor$2;
      td->clockTick[(signed long int)i] = -1.0;
      sampleHit[(signed long int)i] = 0;
    }
  }
  /*td->period[(signed long int)0] = stepSize;
  td->nTaskTicks[(signed long int)0] = 1;
  if(rtmNumSampTimes == 1)
    td->firstDiscIdx = (signed int)IEEE_FLOAT_EQUAL(period[(signed long int)0], (double)0.0);

  else
    td->firstDiscIdx = (signed int)IEEE_FLOAT_EQUAL(period[(signed long int)0], (double)0.0) + (signed int)IEEE_FLOAT_EQUAL(period[(signed long int)1], (double)0.0);
  return (const char *)(void *)0;*/
}

// rt_SimUpdateDiscreteTaskSampleHits
// file ../R2013a/rtw/c/src/rt_sim.c line 332
extern void rt_SimUpdateDiscreteTaskSampleHits(signed int rtmNumSampTimes, void *rtmTimingData, signed int *rtmSampleHitPtr, double *rtmTPtr)
{
  signed int i;
  signed int *sampleHit;
  struct TimingData_Tag *td;
  (void)rtmTimingData;
  td = &td_struct;
  rtmNumSampTimes = 10;
  sampleHit = rtmSampleHitPtr;
  i = td->firstDiscIdx;
  for( ; !(i >= rtmNumSampTimes); i = i + 1)
  {
    signed int hit = (signed int)(td->taskTick[(signed long int)i] == 0);
    if(!(hit == 0))
      rtmTPtr[(signed long int)i] = td->clockTick[(signed long int)i] * td->period[(signed long int)i] + td->offset[(signed long int)i];

    sampleHit[(signed long int)i] = hit;
  }
}

// rt_StartDataLogging
// file ../R2013a/rtw/c/src/rt_logging.h line 249
extern const char * rt_StartDataLogging(struct _RTWLogInfo_tag *li, const double finalTime, const double stepSize, const char **errStatus)
{
  const char *return_value_rt_StartDataLoggingWithStartTime$1;
  return_value_rt_StartDataLoggingWithStartTime$1=rt_StartDataLoggingWithStartTime(li, 0.0, finalTime, stepSize, errStatus);
  return return_value_rt_StartDataLoggingWithStartTime$1;
}

// rt_StartDataLoggingForOutput
// file ../R2013a/rtw/c/src/rt_logging.c line 2156
const char * rt_StartDataLoggingForOutput(struct _RTWLogInfo_tag *li, const double startTime, const double finalTime, const double stepSize, const char **errStatus)
{
  const char *varName;
  double sampleTime = stepSize;
  signed int maxRows = li->logMaxRows;
  signed int decimation = li->logDecimation;
  signed int logFormat = li->logFormat;
  unsigned char logTime = (unsigned char)(logFormat == 2 ? 1 : 0);
  struct LogInfo_Tag *logInfo = (struct LogInfo_Tag *)li->logInfo;
  *errStatus = (const char *)(void *)0;
  varName = li->logY;
  if(!((signed int)*varName == 0))
  {
    signed int i;
    signed int ny;
    signed int yIdx;
    char name[64l];
    const char *cp;
    //cp=strchr(varName, 44);
    const signed char * const *ySigPtrs = li->logYSignalPtrs.cptr;
    const struct RTWLogSignalInfo_tag *yInfo = li->logYSignalInfo.cptr;
    ny = 1;
    for( ; !(cp == (const char *)0); ny = ny + 1)
      //cp=strchr(cp + (signed long int)1, 44);
    logInfo->ny = ny;
    if(logFormat == 0)
    {
      void *return_value_calloc$1;
      return_value_calloc$1=calloc((unsigned long int)ny, sizeof(struct LogVar_Tag *) /*8ul*/ );
      logInfo->y = (void **)return_value_calloc$1;
      if(logInfo->y == (void **)0)
      {
        *errStatus = rtMemAllocError;
        goto ERROR_EXIT;
      }

    }

    else
    {
      void *return_value_calloc$2;
      return_value_calloc$2=calloc((unsigned long int)ny, sizeof(struct StructLogVar_Tag *) /*8ul*/ );
      logInfo->y = (void **)return_value_calloc$2;
      if(logInfo->y == (void **)0)
      {
        *errStatus = rtMemAllocError;
        goto ERROR_EXIT;
      }

    }
    yIdx = 0;
    i = yIdx;
    cp = varName;
    for( ; !(i >= ny); i = i + 1)
    {
      signed int len;
      const char *cp1;
      //cp1=strchr(cp + (signed long int)1, 44);
      if(!(cp1 == (const char *)0))
      {
        len = (signed int)(cp1 - cp);
        if(len >= 64)
          len = 64 - 1;

      }

      else
        len = 64 - 1;
      //strncpy(name, cp, (unsigned long int)len);
      name[(signed long int)len] = (char)0;
      if(ny > 1)
      {
        if(ySigPtrs[(signed long int)i] == (const signed char *)0)
          goto NEXT_NAME;

      }

      if(logFormat == 0)
      {
        signed int numCols;
        signed int nDims;
        const signed int *dims;
        enum anonymous$35 dataType;
        signed int isComplex;
        if(ny == 1)
        {
          signed int op;
          numCols = (yInfo + (signed long int)0)->numCols[(signed long int)0];
          op = 1;
          for( ; !(op >= yInfo->numSignals); op = op + 1)
            numCols = numCols + (yInfo + (signed long int)0)->numCols[(signed long int)op];
          if(yInfo->numSignals == 1)
          {
            nDims = (yInfo + (signed long int)0)->numDims[(signed long int)0];
            dims = (yInfo + (signed long int)0)->dims;
          }

          else
          {
            nDims = 1;
            dims = &numCols;
          }
          dataType = (yInfo + (signed long int)0)->dataTypes[(signed long int)0];
          isComplex = (yInfo + (signed long int)0)->complexSignals[(signed long int)0];
        }

        else
        {
          numCols = (yInfo + (signed long int)yIdx)->numCols[(signed long int)0];
          nDims = (yInfo + (signed long int)yIdx)->numDims[(signed long int)0];
          dims = (yInfo + (signed long int)yIdx)->dims;
          dataType = (yInfo + (signed long int)yIdx)->dataTypes[(signed long int)0];
          isComplex = (yInfo + (signed long int)yIdx)->complexSignals[(signed long int)0];
        }
        struct LogVar_Tag *return_value_rt_CreateLogVarWithConvert$3;
        return_value_rt_CreateLogVarWithConvert$3=rt_CreateLogVarWithConvert(li, startTime, finalTime, stepSize, errStatus, name, dataType, (yInfo + (signed long int)yIdx)->dataTypeConvert, 0, isComplex, 0, numCols, nDims, dims, (enum anonymous$36)NO_LOGVALDIMS, (void **)(void *)0, (signed int *)(void *)0, maxRows, decimation, sampleTime, 1);
        logInfo->y[(signed long int)yIdx] = (void *)return_value_rt_CreateLogVarWithConvert$3;
        if(logInfo->y[(signed long int)yIdx] == (void *)0)
          goto ERROR_EXIT;

      }

      else
      {
        struct StructLogVar_Tag *return_value_local_CreateStructLogVar$4;
        return_value_local_CreateStructLogVar$4=local_CreateStructLogVar(li, startTime, finalTime, stepSize, errStatus, name, logTime, maxRows, decimation, sampleTime, &yInfo[(signed long int)yIdx], (const char *)(void *)0);
        logInfo->y[(signed long int)yIdx] = (void *)return_value_local_CreateStructLogVar$4;
        if(logInfo->y[(signed long int)yIdx] == (void *)0)
          goto ERROR_EXIT;

      }
      yIdx = yIdx + 1;

    NEXT_NAME:
      ;
      cp = cp1;
      if(!(cp == (const char *)0))
      {
        if((signed int)*cp == 44)
          cp = cp + 1l;

      }

    }
  }

  return (const char *)(void *)0;

ERROR_EXIT:
  ;
  //fprintf(stderr, "*** Errors occurred when starting data logging.\n");
  if(*errStatus == (const char *)0)
    *errStatus = rtMemAllocError;

  if(!(logInfo == ((struct LogInfo_Tag *)NULL)))
  {
    rt_DestroyLogVar(logInfo->logVarsList);
    logInfo->logVarsList = (struct LogVar_Tag *)(void *)0;
    rt_DestroyStructLogVar(logInfo->structLogVarsList);
    logInfo->structLogVarsList = (struct StructLogVar_Tag *)(void *)0;
    if(!(logInfo->y == (void **)0))
      //free((void *)logInfo->y);

    logInfo->y = (void **)(void *)0;
  }

  return *errStatus;
}

// rt_StartDataLoggingWithStartTime
// file ../R2013a/rtw/c/src/rt_logging.c line 3018
extern const char * rt_StartDataLoggingWithStartTime(struct _RTWLogInfo_tag *li, const double startTime, const double finalTime, const double stepSize, const char **errStatus)
{
  const char *varName;
  struct LogInfo_Tag *logInfo;
  double sampleTime = stepSize;
  signed int maxRows = li->logMaxRows;
  signed int decimation = li->logDecimation;
  signed int logFormat = li->logFormat;
  unsigned char logTime = (unsigned char)(logFormat == 2 ? 1 : 0);
  *errStatus = (const char *)(void *)0;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct LogInfo_Tag) /*72ul*/ );
  logInfo = (struct LogInfo_Tag *)return_value_calloc$1;
  _Bool tmp_if_expr$6;
  if(logInfo == (struct LogInfo_Tag *)0)
    *errStatus = rtMemAllocError;

  else
  {
    li->logInfo = (void *)logInfo;
    varName = li->logT;
    if(!((signed int)*varName == 0))
    {
      signed int dims = 1;
      logInfo->t=rt_CreateLogVarWithConvert(li, startTime, finalTime, stepSize, errStatus, varName, (enum anonymous$35)SS_DOUBLE, (const struct RTWLogDataTypeConvert_tag *)(void *)0, 0, 0, 0, 1, 1, &dims, (enum anonymous$36)NO_LOGVALDIMS, (void **)(void *)0, (signed int *)(void *)0, maxRows, decimation, sampleTime, 1);
      if(logInfo->t == (struct LogVar_Tag *)0)
        goto ERROR_EXIT;

    }

    if(!((signed int)*li->logX == 0))
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = (signed int)li->logXFinal[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
    {
      const struct RTWLogSignalInfo_tag *xInfo = li->logXSignalInfo.cptr;
      if(logFormat == 0)
      {
        signed int numCols;
        signed int nDims;
        const signed int *rt_StartDataLoggingWithStartTime$$1$$3$$1$$dims;
        enum anonymous$35 dataType;
        signed int isComplex;
        signed int sIdx;
        const struct RTWLogDataTypeConvert_tag *pDTConvInfo;
        numCols = (xInfo + (signed long int)0)->numCols[(signed long int)0];
        sIdx = 1;
        for( ; !(sIdx >= xInfo->numSignals); sIdx = sIdx + 1)
          numCols = numCols + (xInfo + (signed long int)0)->numCols[(signed long int)sIdx];
        if(xInfo->numSignals == 1)
        {
          nDims = (xInfo + (signed long int)0)->numDims[(signed long int)0];
          rt_StartDataLoggingWithStartTime$$1$$3$$1$$dims = (xInfo + (signed long int)0)->dims;
        }

        else
        {
          nDims = 1;
          rt_StartDataLoggingWithStartTime$$1$$3$$1$$dims = &numCols;
        }
        dataType = (xInfo + (signed long int)0)->dataTypes[(signed long int)0];
        isComplex = (xInfo + (signed long int)0)->complexSignals[(signed long int)0];
        pDTConvInfo = (xInfo + (signed long int)0)->dataTypeConvert;
        if(!((signed int)*li->logX == 0))
        {
          struct LogVar_Tag *return_value_rt_CreateLogVarWithConvert$2;
          return_value_rt_CreateLogVarWithConvert$2=rt_CreateLogVarWithConvert(li, startTime, finalTime, stepSize, errStatus, li->logX, dataType, pDTConvInfo, 0, isComplex, 0, numCols, nDims, rt_StartDataLoggingWithStartTime$$1$$3$$1$$dims, (enum anonymous$36)NO_LOGVALDIMS, (void **)(void *)0, (signed int *)(void *)0, maxRows, decimation, sampleTime, 1);
          logInfo->x = (void *)return_value_rt_CreateLogVarWithConvert$2;
          if(logInfo->x == (void *)0)
            goto ERROR_EXIT;

        }

        if(!((signed int)*li->logXFinal == 0))
        {
          struct LogVar_Tag *return_value_rt_CreateLogVarWithConvert$3;
          return_value_rt_CreateLogVarWithConvert$3=rt_CreateLogVarWithConvert(li, startTime, finalTime, stepSize, errStatus, li->logXFinal, dataType, pDTConvInfo, 0, isComplex, 0, numCols, nDims, rt_StartDataLoggingWithStartTime$$1$$3$$1$$dims, (enum anonymous$36)NO_LOGVALDIMS, (void **)(void *)0, (signed int *)(void *)0, 1, decimation, sampleTime, 1);
          logInfo->xFinal = (void *)return_value_rt_CreateLogVarWithConvert$3;
          if(logInfo->xFinal == (void *)0)
            goto ERROR_EXIT;

        }

      }

      else
      {
        if(!((signed int)*li->logX == 0))
        {
          struct StructLogVar_Tag *return_value_local_CreateStructLogVar$4;
          return_value_local_CreateStructLogVar$4=local_CreateStructLogVar(li, startTime, finalTime, stepSize, errStatus, li->logX, logTime, maxRows, decimation, sampleTime, xInfo, (const char *)(void *)0);
          logInfo->x = (void *)return_value_local_CreateStructLogVar$4;
          if(logInfo->x == (void *)0)
            goto ERROR_EXIT;

        }

        if(!((signed int)*li->logXFinal == 0))
        {
          struct StructLogVar_Tag *return_value_local_CreateStructLogVar$5;
          return_value_local_CreateStructLogVar$5=local_CreateStructLogVar(li, startTime, finalTime, stepSize, errStatus, li->logXFinal, logTime, 1, decimation, sampleTime, xInfo, (const char *)(void *)0);
          logInfo->xFinal = (void *)return_value_local_CreateStructLogVar$5;
          if(logInfo->xFinal == (void *)0)
            goto ERROR_EXIT;

        }

      }
    }

    if(!((signed int)*li->logSL == 0))
    {
      const struct RTWLogSignalInfo_tag *slInfo = li->sigLogSignalInfo.cptr;
      struct StructLogVar_Tag *return_value_local_CreateStructLogVar$7;
      return_value_local_CreateStructLogVar$7=local_CreateStructLogVar(li, startTime, finalTime, stepSize, errStatus, li->logSL, logTime, maxRows, decimation, sampleTime, slInfo, (const char *)(void *)0);
      logInfo->sl = (void *)return_value_local_CreateStructLogVar$7;
      if(logInfo->sl == (void *)0)
        goto ERROR_EXIT;

    }

    *errStatus=rt_StartDataLoggingForOutput(li, startTime, finalTime, stepSize, errStatus);
    if(*errStatus == (const char *)0)
      return (const char *)(void *)0;

  }

ERROR_EXIT:
  ;
  //fprintf(stderr, "*** Errors occurred when starting data logging.\n");
  if(*errStatus == (const char *)0)
    *errStatus = rtMemAllocError;

  if(!(logInfo == ((struct LogInfo_Tag *)NULL)))
  {
    rt_DestroyLogVar(logInfo->logVarsList);
    logInfo->logVarsList = (struct LogVar_Tag *)(void *)0;
    rt_DestroyStructLogVar(logInfo->structLogVarsList);
    logInfo->structLogVarsList = (struct StructLogVar_Tag *)(void *)0;
  }

  return *errStatus;
}

// rt_StopDataLogging
// file ../R2013a/rtw/c/src/rt_logging.h line 264
extern void rt_StopDataLogging(const char *file, struct _RTWLogInfo_tag *li)
{
  rt_StopDataLoggingForRaccel(file, li, 1);
}

// rt_StopDataLoggingForRaccel
// file ../R2013a/rtw/c/src/rt_logging.c line 3938
extern void rt_StopDataLoggingForRaccel(const char *file, struct _RTWLogInfo_tag *li, signed int verbose)
{
  struct _IO_FILE *fptr;
  struct LogInfo_Tag *logInfo = (struct LogInfo_Tag *)li->logInfo;
  struct LogVar_Tag *var = logInfo->logVarsList;
  struct StructLogVar_Tag *svar = logInfo->structLogVarsList;
  unsigned char emptyFile = (unsigned char)1;
  unsigned char errFlag = (unsigned char)0;
  const char *msg;
  //fptr=fopen(file, "w+b");
  signed int return_value_rt_WriteMat5FileHeader$1;
    if(fptr == (struct _IO_FILE *)0) {
    //fprintf(stderr, "*** Error opening %s", file);
      }
  else
  {
    return_value_rt_WriteMat5FileHeader$1=rt_WriteMat5FileHeader(fptr);
      if(!(return_value_rt_WriteMat5FileHeader$1 == 0)) {
      //fprintf(stderr, "*** Error writing to %s", file);
      }
    else
    {
      for( ; !(var == (struct LogVar_Tag *)0); var = var->next)
      {
        msg=rt_FixupLogVar(var, verbose);
        if(!(msg == (const char *)0))
        {
          //fprintf(stderr, "*** Error writing %s due to: %s\n", file, msg);
          errFlag = (unsigned char)1;
          break;
        }

        if(var->nDataPoints > 0)
        {
          struct MatItem_tag item;
          item.type = 14;
          item.nbytes = (unsigned int)0;
          item.data = (const void *)&var->data;
          signed int return_value_rt_WriteItemToMatFile$2;
          return_value_rt_WriteItemToMatFile$2=rt_WriteItemToMatFile(fptr, &item, (enum anonymous$33)MATRIX_ITEM);
          if(!(return_value_rt_WriteItemToMatFile$2 == 0))
          {
            //fprintf(stderr, "*** Error writing log variable %s to file %s", (const void *)var->data.name, file);
            errFlag = (unsigned char)1;
            break;
          }

          emptyFile = (unsigned char)0;
        }

      }
      rt_DestroyLogVar(logInfo->logVarsList);
      logInfo->logVarsList = (struct LogVar_Tag *)(void *)0;
      while(!(svar == (struct StructLogVar_Tag *)0))
      {
        struct MatItem_tag rt_StopDataLoggingForRaccel$$1$$4$$item;
        if(!(svar->logTime == 0))
        {
          var = (struct LogVar_Tag *)svar->time;
          msg=rt_FixupLogVar(var, verbose);
          if(!(msg == (const char *)0))
          {
            //fprintf(stderr, "*** Error writing %s due to: %s\n", file, msg);
            errFlag = (unsigned char)1;
            break;
          }

        }

        var = svar->signals.values;
        for( ; !(var == ((struct LogVar_Tag *)NULL)); var = var->next)
        {
          msg=rt_FixupLogVar(var, verbose);
          if(!(msg == (const char *)0))
          {
            //fprintf(stderr, "*** Error writing %s due to: %s\n", file, msg);
            errFlag = (unsigned char)1;
            break;
          }

        }
        rt_StopDataLoggingForRaccel$$1$$4$$item.type = 14;
        rt_StopDataLoggingForRaccel$$1$$4$$item.nbytes = (unsigned int)0;
        rt_StopDataLoggingForRaccel$$1$$4$$item.data = (const void *)svar;
        signed int return_value_rt_WriteItemToMatFile$3;
        return_value_rt_WriteItemToMatFile$3=rt_WriteItemToMatFile(fptr, &rt_StopDataLoggingForRaccel$$1$$4$$item, (enum anonymous$33)STRUCT_LOG_VAR_ITEM);
        if(!(return_value_rt_WriteItemToMatFile$3 == 0))
        {
          //fprintf(stderr, "*** Error writing structure log variable %s to file %s", (const void *)svar->name, file);
          errFlag = (unsigned char)1;
          break;
        }

        emptyFile = (unsigned char)0;
        svar = svar->next;
      }
      //fclose(fptr);
      if(emptyFile == 0)
      {
        if(errFlag != 0)
          goto __CPROVER_DUMP_L14;

      }

      else
      {

      __CPROVER_DUMP_L14:
        ;
        //remove(file);
        goto EXIT_POINT;
      }
      if(!(verbose == 0))
        printf("** created %s **\n\n", file);

    }
  }

EXIT_POINT:
  ;
  rt_DestroyLogVar(logInfo->logVarsList);
  logInfo->logVarsList = (struct LogVar_Tag *)(void *)0;
  rt_DestroyStructLogVar(logInfo->structLogVarsList);
  logInfo->structLogVarsList = (struct StructLogVar_Tag *)(void *)0;
  if(!(logInfo == (struct LogInfo_Tag *)0))
    //free((void *)logInfo);

  li->logInfo = (void *)0;
}

// rt_UpdateDiscreteTaskSampleHits
// file ../R2013a/rtw/c/src/rt_sim.c line 553
extern void rt_UpdateDiscreteTaskSampleHits(struct SimStruct_tag *S)
{
  rt_SimUpdateDiscreteTaskSampleHits(S->sizes.numSampleTimes, S->mdlInfo->timingData, S->mdlInfo->sampleHits, S->mdlInfo->t);
}

// rt_UpdateLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 3209
extern void rt_UpdateLogVar(struct LogVar_Tag *var, const void *data, unsigned char isVarDims)
{
  unsigned long int elSize = var->data.elSize;
  const char *cData = (const char *)data;
  const signed int frameData = (const signed int)var->data.frameData;
  signed int frameSize;
  unsigned int tmp_if_expr$1;
  if(!(frameData == 0))
    tmp_if_expr$1 = var->data.frameSize;

  else
    tmp_if_expr$1 = (unsigned int)1;
  frameSize = (const signed int)tmp_if_expr$1;
  const signed int logWidth = var->data.nCols;
  enum anonymous$35 dTypeID = (enum anonymous$35)var->data.dTypeID;
  signed int offset = 0;
  char *currRealRow = (char *)(void *)0;
  char *currImagRow = (char *)(void *)0;
  signed int pointSize;
  unsigned long int tmp_if_expr$3;
  unsigned long int return_value_rt_GetSizeofComplexType$2;
  if(!(var->data.complex == 0u))
  {
    return_value_rt_GetSizeofComplexType$2=rt_GetSizeofComplexType(dTypeID);
    tmp_if_expr$3 = return_value_rt_GetSizeofComplexType$2;
  }

  else
    tmp_if_expr$3 = elSize;
  pointSize = (signed int)tmp_if_expr$3;
  signed int i;
  signed int j;
  signed int k;
  const signed int nDims = var->data.nDims;
  const signed int *dims = var->data.dims;
  const void * const *currDimsPtr = (const void * const *)(void *)0;
  const signed int *currDimsSizePtr = (const signed int *)(void *)0;
  signed int offset_valDims = 0;
  char *currValDimsRow = (char *)(void *)0;
  unsigned long int elSize_valDims = sizeof(double) /*8ul*/ ;
  double currentSigDims = (double)0;
  signed int nRows_valDims = 0;
  signed int logWidth_valDims = 0;
  i = 0;
  signed int tmp_if_expr$4;
  char *tmp_if_expr$5;
  unsigned long int tmp_if_expr$8;
  unsigned long int return_value_rt_GetSizeofComplexType$6;
  unsigned long int return_value_rt_GetSizeofDataType$7;
  for( ; !(i >= frameSize); i = i + 1)
  {
    var->numHits = var->numHits + 1;
    if(var->numHits % var->decimation == 0)
    {
      var->numHits = 0;
      if(var->rowIdx == var->data.nRows)
      {
        if(var->okayToRealloc == 1)
          rt_ReallocLogVar(var, isVarDims);

        else
        {
          var->rowIdx = 0;
          var->wrapped = var->wrapped + 1;
        }
      }

      if(!(isVarDims == 0))
      {
        currDimsPtr = (const void * const *)var->valDims->currSigDims;
        currDimsSizePtr = (const signed int *)var->valDims->currSigDimsSize;
        if(!(frameData == 0))
          tmp_if_expr$4 = 1;

        else
          tmp_if_expr$4 = var->valDims->nCols;
        logWidth_valDims = tmp_if_expr$4;
        nRows_valDims = var->valDims->nRows;
        var->strides[(signed long int)0] = 1;
        var->currStrides[(signed long int)0] = 1;
        k = 1;
        for( ; !(k >= nDims); k = k + 1)
        {
          signed int rt_UpdateLogVar$$1$$1$$2$$1$$currDimsVal = 0;
          switch(currDimsSizePtr[(signed long int)(k - 1)])
          {
            case 1:
            {
              rt_UpdateLogVar$$1$$1$$2$$1$$currDimsVal = (signed int)*((const unsigned char * const *)currDimsPtr)[(signed long int)(k - 1)];
              break;
            }
            case 2:
            {
              rt_UpdateLogVar$$1$$1$$2$$1$$currDimsVal = (signed int)*((const unsigned short int * const *)currDimsPtr)[(signed long int)(k - 1)];
              break;
            }
            case 4:
              rt_UpdateLogVar$$1$$1$$2$$1$$currDimsVal = (signed int)*((const unsigned int * const *)currDimsPtr)[(signed long int)(k - 1)];
          }
          var->strides[(signed long int)k] = var->strides[(signed long int)(k - 1)] * dims[(signed long int)(k - 1)];
          var->currStrides[(signed long int)k] = var->currStrides[(signed long int)(k - 1)] * rt_UpdateLogVar$$1$$1$$2$$1$$currDimsVal;
        }
      }

      offset = (signed int)(elSize * (unsigned long int)var->rowIdx * (unsigned long int)logWidth);
      currRealRow = (char *)var->data.re + (signed long int)offset;
      if(!(var->data.complex == 0u))
        tmp_if_expr$5 = (char *)var->data.im + (signed long int)offset;

      else
        tmp_if_expr$5 = (char *)(void *)0;
      currImagRow = tmp_if_expr$5;
      j = 0;
      for( ; !(j >= logWidth); j = j + 1)
      {
        unsigned char inRange = (unsigned char)1;
        signed int idx = j;
        if(!(isVarDims == 0))
        {
          signed int rem = j;
          idx = 0;
          k = nDims - 1;
          for( ; k >= 0; k = k - 1)
          {
            signed int currDimsVal = 0;
            switch(currDimsSizePtr[(signed long int)k])
            {
              case 1:
              {
                currDimsVal = (signed int)*((const unsigned char * const *)currDimsPtr)[(signed long int)k];
                break;
              }
              case 2:
              {
                currDimsVal = (signed int)*((const unsigned short int * const *)currDimsPtr)[(signed long int)k];
                break;
              }
              case 4:
                currDimsVal = (signed int)*((const unsigned int * const *)currDimsPtr)[(signed long int)k];
            }
            var->coords[(signed long int)k] = rem / var->strides[(signed long int)k];
            if(var->coords[(signed long int)k] >= currDimsVal)
            {
              inRange = (unsigned char)0;
              break;
            }

            rem = rem - var->coords[(signed long int)k] * var->strides[(signed long int)k];
          }
          if(!(inRange == 0))
          {
            idx = var->coords[(signed long int)0];
            k = 1;
            for( ; !(k >= nDims); k = k + 1)
              idx = idx + var->coords[(signed long int)k] * var->currStrides[(signed long int)k];
          }

        }

        if(var->data.dataTypeConvertInfo.conversionNeeded == 0)
        {
          if(!(inRange == 0))
          {
            const char *cDataPoint = cData + (signed long int)((i + frameSize * idx) * pointSize);
            memcpy((void *)currRealRow, (const void *)cDataPoint, elSize);
            currRealRow = currRealRow + (signed long int)elSize;
            if(!(var->data.complex == 0u))
            {
              memcpy((void *)currImagRow, (const void *)(cDataPoint + (signed long int)(pointSize / 2)), elSize);
              currImagRow = currImagRow + (signed long int)elSize;
            }

          }

          else
          {
            if((signed int)dTypeID == SS_DOUBLE)
              memcpy((void *)currRealRow, (const void *)&rtNaN, elSize);

            else
              if((signed int)dTypeID == SS_SINGLE)
                memcpy((void *)currRealRow, (const void *)&rtNaNF, elSize);

              else
                memset((void *)currRealRow, 0, elSize);
            currRealRow = currRealRow + (signed long int)elSize;
            if(!(var->data.complex == 0u))
            {
              memset((void *)currImagRow, 0, elSize);
              currImagRow = currImagRow + (signed long int)elSize;
            }

          }
        }

        else
        {
          signed int dataTypeIdOriginal = var->data.dataTypeConvertInfo.dataTypeIdOriginal;
          signed int DpSize;
          if(!(var->data.complex == 0u))
          {
            return_value_rt_GetSizeofComplexType$6=rt_GetSizeofComplexType((enum anonymous$35)dataTypeIdOriginal);
            tmp_if_expr$8 = return_value_rt_GetSizeofComplexType$6;
          }

          else
          {
            return_value_rt_GetSizeofDataType$7=rt_GetSizeofDataType((enum anonymous$35)dataTypeIdOriginal);
            tmp_if_expr$8 = return_value_rt_GetSizeofDataType$7;
          }
          DpSize = (signed int)tmp_if_expr$8;
          signed int dataTypeIdLoggingTo = (signed int)var->data.dataTypeConvertInfo.dataTypeIdLoggingTo;
          signed int bitsPerChunk = var->data.dataTypeConvertInfo.bitsPerChunk;
          signed int numOfChunk = var->data.dataTypeConvertInfo.numOfChunk;
          unsigned int isSigned = var->data.dataTypeConvertInfo.isSigned;
          double fracSlope = var->data.dataTypeConvertInfo.fracSlope;
          signed int fixedExp = var->data.dataTypeConvertInfo.fixedExp;
          double bias = var->data.dataTypeConvertInfo.bias;
          double curRealValue = -0.12345678987654;
          double curImagValue = -0.12345678987654;
          signed int adjIndexIfComplex = var->data.complex != 0u ? 2 : 1;
          if(!(inRange == 0))
          {
            if(numOfChunk > 1)
            {
              const char *rt_UpdateLogVar$$1$$1$$3$$3$$1$$1$$pInData = (const char *)cData;
              signed int dtSize = (bitsPerChunk * numOfChunk) / 8;
              rt_UpdateLogVar$$1$$1$$3$$3$$1$$1$$pInData = rt_UpdateLogVar$$1$$1$$3$$3$$1$$1$$pInData + (signed long int)((i + frameSize * idx) * adjIndexIfComplex * dtSize);
              curRealValue=rt_GetDblValueFromOverSizedData((const void *)rt_UpdateLogVar$$1$$1$$3$$3$$1$$1$$pInData, bitsPerChunk, numOfChunk, isSigned, fracSlope, fixedExp, bias);
              if(!(var->data.complex == 0u))
                curImagValue=rt_GetDblValueFromOverSizedData((const void *)(rt_UpdateLogVar$$1$$1$$3$$3$$1$$1$$pInData + (signed long int)dtSize), bitsPerChunk, numOfChunk, isSigned, fracSlope, fixedExp, bias);

            }

            else
              switch(dataTypeIdOriginal)
              {
                case SS_DOUBLE:
                {
                  const double *rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$1$$pInData = (const double *)(cData + (signed long int)((i + frameSize * idx) * DpSize));
                  double return_value_ldexp$9;
                  //return_value_ldexp$9=ldexp(fracSlope * (double)*rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$1$$pInData, fixedExp);
                  curRealValue = return_value_ldexp$9 + bias;
                  if(!(var->data.complex == 0u))
                  {
                    rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$1$$pInData = (const double *)(cData + (signed long int)((i + frameSize * idx) * DpSize) + (signed long int)(DpSize / 2));
                    double return_value_ldexp$10;
                    //return_value_ldexp$10=ldexp(fracSlope * (double)*rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$1$$pInData, fixedExp);
                    curImagValue = return_value_ldexp$10 + bias;
                  }

                  break;
                }
                case SS_SINGLE:
                {
                  const float *pInData = (const float *)(cData + (signed long int)((i + frameSize * idx) * DpSize));
                  double return_value_ldexp$11;
                  //return_value_ldexp$11=ldexp(fracSlope * (double)*pInData, fixedExp);
                  curRealValue = return_value_ldexp$11 + bias;
                  if(!(var->data.complex == 0u))
                  {
                    pInData = (const float *)(cData + (signed long int)((i + frameSize * idx) * DpSize) + (signed long int)(DpSize / 2));
                    double return_value_ldexp$12;
                    //return_value_ldexp$12=ldexp(fracSlope * (double)*pInData, fixedExp);
                    curImagValue = return_value_ldexp$12 + bias;
                  }

                  break;
                }
                case SS_INT8:
                {
                  const signed char *rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$3$$pInData = (const signed char *)(cData + (signed long int)((i + frameSize * idx) * DpSize));
                  double return_value_ldexp$13;
                  //return_value_ldexp$13=ldexp(fracSlope * (double)*rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$3$$pInData, fixedExp);
                  curRealValue = return_value_ldexp$13 + bias;
                  if(!(var->data.complex == 0u))
                  {
                    rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$3$$pInData = (const signed char *)(cData + (signed long int)((i + frameSize * idx) * DpSize) + (signed long int)(DpSize / 2));
                    double return_value_ldexp$14;
                    //return_value_ldexp$14=ldexp(fracSlope * (double)*rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$3$$pInData, fixedExp);
                    curImagValue = return_value_ldexp$14 + bias;
                  }

                  break;
                }
                case SS_UINT8:
                {
                  const unsigned char *rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$4$$pInData = (const unsigned char *)(cData + (signed long int)((i + frameSize * idx) * DpSize));
                  double return_value_ldexp$15;
                  //return_value_ldexp$15=ldexp(fracSlope * (double)*rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$4$$pInData, fixedExp);
                  curRealValue = return_value_ldexp$15 + bias;
                  if(!(var->data.complex == 0u))
                  {
                    rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$4$$pInData = (const unsigned char *)(cData + (signed long int)((i + frameSize * idx) * DpSize) + (signed long int)(DpSize / 2));
                    double return_value_ldexp$16;
                    //return_value_ldexp$16=ldexp(fracSlope * (double)*rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$4$$pInData, fixedExp);
                    curImagValue = return_value_ldexp$16 + bias;
                  }

                  break;
                }
                case SS_INT16:
                {
                  const signed short int *rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$5$$pInData = (const signed short int *)(cData + (signed long int)((i + frameSize * idx) * DpSize));
                  double return_value_ldexp$17;
                  //return_value_ldexp$17=ldexp(fracSlope * (double)*rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$5$$pInData, fixedExp);
                  curRealValue = return_value_ldexp$17 + bias;
                  if(!(var->data.complex == 0u))
                  {
                    rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$5$$pInData = (const signed short int *)(cData + (signed long int)((i + frameSize * idx) * DpSize) + (signed long int)(DpSize / 2));
                    double return_value_ldexp$18;
                    //return_value_ldexp$18=ldexp(fracSlope * (double)*rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$5$$pInData, fixedExp);
                    curImagValue = return_value_ldexp$18 + bias;
                  }

                  break;
                }
                case SS_UINT16:
                {
                  const unsigned short int *rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$6$$pInData = (const unsigned short int *)(cData + (signed long int)((i + frameSize * idx) * DpSize));
                  double return_value_ldexp$19;
                  //return_value_ldexp$19=ldexp(fracSlope * (double)*rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$6$$pInData, fixedExp);
                  curRealValue = return_value_ldexp$19 + bias;
                  if(!(var->data.complex == 0u))
                  {
                    rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$6$$pInData = (const unsigned short int *)(cData + (signed long int)((i + frameSize * idx) * DpSize) + (signed long int)(DpSize / 2));
                    double return_value_ldexp$20;
                    //return_value_ldexp$20=ldexp(fracSlope * (double)*rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$6$$pInData, fixedExp);
                    curImagValue = return_value_ldexp$20 + bias;
                  }

                  break;
                }
                case SS_INT32:
                {
                  const signed int *rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$7$$pInData = (const signed int *)(cData + (signed long int)((i + frameSize * idx) * DpSize));
                  double return_value_ldexp$21;
                  //return_value_ldexp$21=ldexp(fracSlope * (double)*rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$7$$pInData, fixedExp);
                  curRealValue = return_value_ldexp$21 + bias;
                  if(!(var->data.complex == 0u))
                  {
                    rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$7$$pInData = (const signed int *)(cData + (signed long int)((i + frameSize * idx) * DpSize) + (signed long int)(DpSize / 2));
                    double return_value_ldexp$22;
                    //return_value_ldexp$22=ldexp(fracSlope * (double)*rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$7$$pInData, fixedExp);
                    curImagValue = return_value_ldexp$22 + bias;
                  }

                  break;
                }
                case SS_UINT32:
                {
                  const unsigned int *rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$8$$pInData = (const unsigned int *)(cData + (signed long int)((i + frameSize * idx) * DpSize));
                  double return_value_ldexp$23;
                  //return_value_ldexp$23=ldexp(fracSlope * (double)*rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$8$$pInData, fixedExp);
                  curRealValue = return_value_ldexp$23 + bias;
                  if(!(var->data.complex == 0u))
                  {
                    rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$8$$pInData = (const unsigned int *)(cData + (signed long int)((i + frameSize * idx) * DpSize) + (signed long int)(DpSize / 2));
                    double return_value_ldexp$24;
                    //return_value_ldexp$24=ldexp(fracSlope * (double)*rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$8$$pInData, fixedExp);
                    curImagValue = return_value_ldexp$24 + bias;
                  }

                  break;
                }
                case SS_BOOLEAN:
                {
                  const unsigned char *rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$9$$pInData = (const unsigned char *)cData;
                  rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$9$$pInData = rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$9$$pInData + (signed long int)((i + frameSize * idx) * adjIndexIfComplex);
                  double return_value_ldexp$25;
                  //return_value_ldexp$25=ldexp(fracSlope * (double)*rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$9$$pInData, fixedExp);
                  curRealValue = return_value_ldexp$25 + bias;
                  if(!(var->data.complex == 0u))
                  {
                    double return_value_ldexp$26;
                    //return_value_ldexp$26=ldexp(fracSlope * (double)*rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$9$$pInData, fixedExp);
                    curImagValue = return_value_ldexp$26 + bias;
                  }

                  break;
                }
                default:
                {
                  const char *rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$10$$pInData = (const char *)cData;
                  signed int rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$10$$dtSize = (bitsPerChunk * numOfChunk) / 8;
                  rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$10$$pInData = rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$10$$pInData + (signed long int)((i + frameSize * idx) * adjIndexIfComplex * rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$10$$dtSize);
                  curRealValue=rt_GetDblValueFromOverSizedData((const void *)rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$10$$pInData, bitsPerChunk, numOfChunk, isSigned, fracSlope, fixedExp, bias);
                  if(!(var->data.complex == 0u))
                    curImagValue=rt_GetDblValueFromOverSizedData((const void *)(rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$10$$pInData + (signed long int)rt_UpdateLogVar$$1$$1$$3$$3$$1$$2$$1$$10$$dtSize), bitsPerChunk, numOfChunk, isSigned, fracSlope, fixedExp, bias);

                }
              }
          }

          else
          {
            if(!((signed int)dTypeID == SS_DOUBLE))
            {
              if((signed int)dTypeID == SS_SINGLE)
                goto __CPROVER_DUMP_L62;

            }

            else
            {

            __CPROVER_DUMP_L62:
              ;
              double return_value_ldexp$27;
              //return_value_ldexp$27=ldexp(rtNaN, fixedExp);
              curRealValue = return_value_ldexp$27 + bias;
              goto __CPROVER_DUMP_L64;
            }
            double return_value_ldexp$28;
            //return_value_ldexp$28=ldexp((double)0, fixedExp);
            curRealValue = return_value_ldexp$28 + bias;

          __CPROVER_DUMP_L64:
            ;
            if(!(var->data.complex == 0u))
            {
              double return_value_ldexp$29;
              //return_value_ldexp$29=ldexp((double)0, fixedExp);
              curImagValue = return_value_ldexp$29 + bias;
            }

          }
          switch(dataTypeIdLoggingTo)
          {
            case SS_DOUBLE:
            {
              *((double *)currRealRow) = (double)curRealValue;
              if(!(var->data.complex == 0u))
                *((double *)currImagRow) = (double)curImagValue;

              break;
            }
            case SS_SINGLE:
            {
              *((float *)currRealRow) = (float)curRealValue;
              if(!(var->data.complex == 0u))
                *((float *)currImagRow) = (float)curImagValue;

              break;
            }
            case SS_INT8:
            {
              *((signed char *)currRealRow) = (signed char)curRealValue;
              if(!(var->data.complex == 0u))
                *((signed char *)currImagRow) = (signed char)curImagValue;

              break;
            }
            case SS_UINT8:
            {
              *((unsigned char *)currRealRow) = (unsigned char)curRealValue;
              if(!(var->data.complex == 0u))
                *((unsigned char *)currImagRow) = (unsigned char)curImagValue;

              break;
            }
            case SS_INT16:
            {
              *((signed short int *)currRealRow) = (signed short int)curRealValue;
              if(!(var->data.complex == 0u))
                *((signed short int *)currImagRow) = (signed short int)curImagValue;

              break;
            }
            case SS_UINT16:
            {
              *((unsigned short int *)currRealRow) = (unsigned short int)curRealValue;
              if(!(var->data.complex == 0u))
                *((unsigned short int *)currImagRow) = (unsigned short int)curImagValue;

              break;
            }
            case SS_INT32:
            {
              *((signed int *)currRealRow) = (signed int)curRealValue;
              if(!(var->data.complex == 0u))
                *((signed int *)currImagRow) = (signed int)curImagValue;

              break;
            }
            case SS_UINT32:
            {
              *((unsigned int *)currRealRow) = (unsigned int)curRealValue;
              if(!(var->data.complex == 0u))
                *((unsigned int *)currImagRow) = (unsigned int)curImagValue;

              break;
            }
            case SS_BOOLEAN:
            {
              *((unsigned char *)currRealRow) = (unsigned char)IEEE_FLOAT_NOTEQUAL(curRealValue, 0.0);
              if(!(var->data.complex == 0u))
                *((unsigned char *)currImagRow) = (unsigned char)IEEE_FLOAT_NOTEQUAL(curImagValue, 0.0);

            }
          }
          currRealRow = currRealRow + (signed long int)elSize;
          if(!(var->data.complex == 0u))
            currImagRow = currImagRow + (signed long int)elSize;

        }
      }
      if(!(isVarDims == 0))
      {
        j = 0;
        for( ; !(j >= logWidth_valDims); j = j + 1)
        {
          signed int rt_UpdateLogVar$$1$$1$$4$$1$$currDimsVal = 0;
          switch(currDimsSizePtr[(signed long int)j])
          {
            case 1:
            {
              rt_UpdateLogVar$$1$$1$$4$$1$$currDimsVal = (signed int)*((const unsigned char * const *)currDimsPtr)[(signed long int)j];
              break;
            }
            case 2:
            {
              rt_UpdateLogVar$$1$$1$$4$$1$$currDimsVal = (signed int)*((const unsigned short int * const *)currDimsPtr)[(signed long int)j];
              break;
            }
            case 4:
              rt_UpdateLogVar$$1$$1$$4$$1$$currDimsVal = (signed int)*((const unsigned int * const *)currDimsPtr)[(signed long int)j];
          }
          offset_valDims = (signed int)(elSize_valDims * (unsigned long int)(var->rowIdx + nRows_valDims * j));
          currValDimsRow = (char *)var->valDims->dimsData + (signed long int)offset_valDims;
          currentSigDims = (double)rt_UpdateLogVar$$1$$1$$4$$1$$currDimsVal;
          memcpy((void *)currValDimsRow, (const void *)&currentSigDims, elSize_valDims);
          currValDimsRow = currValDimsRow + (signed long int)elSize_valDims;
        }
      }

      var->rowIdx = var->rowIdx + 1;
    }

  }
  return;
}

// rt_UpdateLogVarWithDiscontiguousData
// file ../R2013a/rtw/c/src/rt_logging.c line 2439
void rt_UpdateLogVarWithDiscontiguousData(struct LogVar_Tag *var, const signed char * const *data, const signed int *segmentLengths, signed int nSegments)
{
  unsigned long int elSize = (unsigned long int)0;
  signed int offset = 0;
  signed int segIdx = 0;
  var->numHits = var->numHits + 1;
  if(!(var->numHits % var->decimation == 0))
    return;

  var->numHits = 0;
  if(var->rowIdx == var->data.nRows)
  {
    if(var->okayToRealloc == 1)
      rt_ReallocLogVar(var, (unsigned char)0);

    else
    {
      var->rowIdx = 0;
      var->wrapped = var->wrapped + 1;
    }
  }

  elSize = var->data.elSize;
  offset = (signed int)(elSize * (unsigned long int)var->rowIdx * (unsigned long int)var->data.nCols);
  if(!(var->data.complex == 0u))
  {
    char *dstRe = (char *)var->data.re + (signed long int)offset;
    char *dstIm = (char *)var->data.im + (signed long int)offset;
    segIdx = 0;
    for( ; !(segIdx >= nSegments); segIdx = segIdx + 1)
    {
      signed int nEl = segmentLengths[(signed long int)segIdx];
      const char *rt_UpdateLogVarWithDiscontiguousData$$1$$2$$1$$src = (const char *)(const void *)data[(signed long int)segIdx];
      signed int el = 0;
      for( ; !(el >= nEl); el = el + 1)
      {
        memcpy((void *)dstRe, (const void *)rt_UpdateLogVarWithDiscontiguousData$$1$$2$$1$$src, elSize);
        dstRe = dstRe + (signed long int)elSize;
        rt_UpdateLogVarWithDiscontiguousData$$1$$2$$1$$src = rt_UpdateLogVarWithDiscontiguousData$$1$$2$$1$$src + (signed long int)elSize;
        memcpy((void *)dstIm, (const void *)rt_UpdateLogVarWithDiscontiguousData$$1$$2$$1$$src, elSize);
        dstIm = dstIm + (signed long int)elSize;
        rt_UpdateLogVarWithDiscontiguousData$$1$$2$$1$$src = rt_UpdateLogVarWithDiscontiguousData$$1$$2$$1$$src + (signed long int)elSize;
      }
    }
  }

  else
  {
    char *dst = (char *)var->data.re + (signed long int)offset;
    segIdx = 0;
    for( ; !(segIdx >= nSegments); segIdx = segIdx + 1)
    {
      unsigned long int segSize = elSize * (unsigned long int)segmentLengths[(signed long int)segIdx];
      const void *src = (const void *)data[(signed long int)segIdx];
      memcpy((void *)dst, src, segSize);
      dst = dst + (signed long int)segSize;
    }
  }
  var->rowIdx = var->rowIdx + 1;
  return;
}

// rt_UpdateSigLogVars
// file ../R2013a/rtw/c/src/rt_logging.h line 260
extern void rt_UpdateSigLogVars(struct _RTWLogInfo_tag *li, double *tPtr)
{
  struct LogInfo_Tag *logInfo = (struct LogInfo_Tag *)li->logInfo;
  if(!(logInfo->sl == (void *)0))
  {
    signed int i;
    struct StructLogVar_Tag *var = (struct StructLogVar_Tag *)logInfo->sl;
    struct LogVar_Tag *val = var->signals.values;
    signed int nsig = var->signals.numSignals;
    const signed char * const *data = li->sigLogSignalPtrs.cptr;
    if(!(var->logTime == 0))
      rt_UpdateLogVar((struct LogVar_Tag *)var->time, (const void *)tPtr, (unsigned char)0);

    i = 0;
    for( ; !(i >= nsig); i = i + 1)
    {
      rt_UpdateLogVar(val, (const void *)data[(signed long int)i], (unsigned char)0);
      val = val->next;
    }
  }

}

// rt_UpdateStructLogVar
// file ../R2013a/rtw/c/src/rt_logging.c line 3693
extern void rt_UpdateStructLogVar(struct StructLogVar_Tag *var, const double *t, const void *data)
{
  struct LogVar_Tag *values = var->signals.values;
  const char *signal = (const char *)data;
  unsigned char *isVarDims = var->signals.isVarDims;
  signed int i = 0;
  if(!(var->logTime == 0))
    rt_UpdateLogVar((struct LogVar_Tag *)var->time, (const void *)t, (unsigned char)0);

  while(!(values == ((struct LogVar_Tag *)NULL)))
  {
    unsigned long int elSz = values->data.elSize;
    rt_UpdateLogVar(values, (const void *)signal, isVarDims[(signed long int)i]);
    if(!(values->data.complex == 0u))
      elSz = elSz * (unsigned long int)2;

    signal = signal + (signed long int)(elSz * (unsigned long int)values->data.nCols);
    values = values->next;
    i = i + 1;
  }
}

// rt_UpdateTXYLogVars
// file ../R2013a/rtw/c/src/rt_logging.h line 258
extern const char * rt_UpdateTXYLogVars(struct _RTWLogInfo_tag *li, double *tPtr)
{
  struct LogInfo_Tag *logInfo = (struct LogInfo_Tag *)li->logInfo;
  signed int matrixFormat = (signed int)(li->logFormat == 0);
  if(!(logInfo->t == (struct LogVar_Tag *)0))
    rt_UpdateLogVar(logInfo->t, (const void *)tPtr, (unsigned char)0);

  _Bool tmp_if_expr$1;
  signed int tmp_post$2;
  _Bool tmp_if_expr$3;
  if(!(matrixFormat == 0))
  {
    if(!(logInfo->x == (void *)0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = logInfo->xFinal != (void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      const struct RTWLogSignalInfo_tag *xInfo = li->logXSignalInfo.cptr;
      const signed char * const *segAddr = li->logXSignalPtrs.cptr;
      const signed int *segLengths = xInfo->numCols;
      signed int nSegments = xInfo->numSignals;
      if(!(logInfo->x == (void *)0))
        rt_UpdateLogVarWithDiscontiguousData((struct LogVar_Tag *)logInfo->x, segAddr, segLengths, nSegments);

      if(!(logInfo->xFinal == (void *)0))
        rt_UpdateLogVarWithDiscontiguousData((struct LogVar_Tag *)logInfo->xFinal, segAddr, segLengths, nSegments);

    }

    if(!(logInfo->y == (void **)0))
    {
      struct LogVar_Tag **var = (struct LogVar_Tag **)logInfo->y;
      signed int ny = logInfo->ny;
      signed int rt_UpdateTXYLogVars$$1$$2$$2$$i;
      signed int yIdx;
      const signed char * const *rt_UpdateTXYLogVars$$1$$2$$2$$data = li->logYSignalPtrs.cptr;
      rt_UpdateTXYLogVars$$1$$2$$2$$i = 0;
      yIdx = 0;
      for( ; !(rt_UpdateTXYLogVars$$1$$2$$2$$i >= ny); rt_UpdateTXYLogVars$$1$$2$$2$$i = rt_UpdateTXYLogVars$$1$$2$$2$$i + 1)
        if(!(rt_UpdateTXYLogVars$$1$$2$$2$$data[(signed long int)rt_UpdateTXYLogVars$$1$$2$$2$$i] == (const signed char *)0))
        {
          tmp_post$2 = yIdx;
          yIdx = yIdx + 1;
          rt_UpdateLogVar(var[(signed long int)tmp_post$2], (const void *)rt_UpdateTXYLogVars$$1$$2$$2$$data[(signed long int)rt_UpdateTXYLogVars$$1$$2$$2$$i], (unsigned char)0);
        }

    }

  }

  else
  {
    if(!(logInfo->x == (void *)0))
    {
      signed int rt_UpdateTXYLogVars$$1$$3$$1$$i;
      struct StructLogVar_Tag *rt_UpdateTXYLogVars$$1$$3$$1$$var = (struct StructLogVar_Tag *)logInfo->x;
      struct LogVar_Tag *rt_UpdateTXYLogVars$$1$$3$$1$$val = rt_UpdateTXYLogVars$$1$$3$$1$$var->signals.values;
      signed int rt_UpdateTXYLogVars$$1$$3$$1$$nsig = rt_UpdateTXYLogVars$$1$$3$$1$$var->signals.numSignals;
      const signed char * const *rt_UpdateTXYLogVars$$1$$3$$1$$data = li->logXSignalPtrs.cptr;
      if(!(rt_UpdateTXYLogVars$$1$$3$$1$$var->logTime == 0))
        rt_UpdateLogVar((struct LogVar_Tag *)rt_UpdateTXYLogVars$$1$$3$$1$$var->time, (const void *)tPtr, (unsigned char)0);

      rt_UpdateTXYLogVars$$1$$3$$1$$i = 0;
      for( ; !(rt_UpdateTXYLogVars$$1$$3$$1$$i >= rt_UpdateTXYLogVars$$1$$3$$1$$nsig); rt_UpdateTXYLogVars$$1$$3$$1$$i = rt_UpdateTXYLogVars$$1$$3$$1$$i + 1)
      {
        rt_UpdateLogVar(rt_UpdateTXYLogVars$$1$$3$$1$$val, (const void *)rt_UpdateTXYLogVars$$1$$3$$1$$data[(signed long int)rt_UpdateTXYLogVars$$1$$3$$1$$i], (unsigned char)0);
        rt_UpdateTXYLogVars$$1$$3$$1$$val = rt_UpdateTXYLogVars$$1$$3$$1$$val->next;
      }
    }

    if(!(logInfo->y == (void **)0))
    {
      signed int rt_UpdateTXYLogVars$$1$$3$$2$$ny = logInfo->ny;
      const signed char * const *rt_UpdateTXYLogVars$$1$$3$$2$$data = li->logYSignalPtrs.cptr;
      struct StructLogVar_Tag **rt_UpdateTXYLogVars$$1$$3$$2$$var = (struct StructLogVar_Tag **)logInfo->y;
      if(rt_UpdateTXYLogVars$$1$$3$$2$$ny == 1)
      {
        signed int i;
        signed int dataIdx;
        struct LogVar_Tag *rt_UpdateTXYLogVars$$1$$3$$2$$1$$val = rt_UpdateTXYLogVars$$1$$3$$2$$var[(signed long int)0]->signals.values;
        signed int rt_UpdateTXYLogVars$$1$$3$$2$$1$$nsig = rt_UpdateTXYLogVars$$1$$3$$2$$var[(signed long int)0]->signals.numSignals;
        unsigned char *isVarDims = rt_UpdateTXYLogVars$$1$$3$$2$$var[(signed long int)0]->signals.isVarDims;
        if(!((*rt_UpdateTXYLogVars$$1$$3$$2$$var)->logTime == 0))
          rt_UpdateLogVar((struct LogVar_Tag *)rt_UpdateTXYLogVars$$1$$3$$2$$var[(signed long int)0]->time, (const void *)tPtr, (unsigned char)0);

        i = 0;
        dataIdx = 0;
        for( ; !(i >= rt_UpdateTXYLogVars$$1$$3$$2$$1$$nsig); i = i + 1)
        {
          for( ; rt_UpdateTXYLogVars$$1$$3$$2$$data[(signed long int)dataIdx] == (const signed char *)0; dataIdx = dataIdx + 1)
            ;
          rt_UpdateLogVar(rt_UpdateTXYLogVars$$1$$3$$2$$1$$val, (const void *)rt_UpdateTXYLogVars$$1$$3$$2$$data[(signed long int)dataIdx], isVarDims[(signed long int)i]);
          rt_UpdateTXYLogVars$$1$$3$$2$$1$$val = rt_UpdateTXYLogVars$$1$$3$$2$$1$$val->next;
          dataIdx = dataIdx + 1;
        }
      }

      else
      {
        signed int rt_UpdateTXYLogVars$$1$$3$$2$$2$$i;
        signed int rt_UpdateTXYLogVars$$1$$3$$2$$2$$dataIdx;
        rt_UpdateTXYLogVars$$1$$3$$2$$2$$i = 0;
        rt_UpdateTXYLogVars$$1$$3$$2$$2$$dataIdx = 0;
        do
        {
          if(!(rt_UpdateTXYLogVars$$1$$3$$2$$2$$i >= rt_UpdateTXYLogVars$$1$$3$$2$$ny))
            tmp_if_expr$3 = rt_UpdateTXYLogVars$$1$$3$$2$$var[(signed long int)rt_UpdateTXYLogVars$$1$$3$$2$$2$$i] != (struct StructLogVar_Tag *)(void *)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          if(!tmp_if_expr$3)
            break;

          struct LogVar_Tag *rt_UpdateTXYLogVars$$1$$3$$2$$2$$1$$val = rt_UpdateTXYLogVars$$1$$3$$2$$var[(signed long int)rt_UpdateTXYLogVars$$1$$3$$2$$2$$i]->signals.values;
          unsigned char *rt_UpdateTXYLogVars$$1$$3$$2$$2$$1$$isVarDims = rt_UpdateTXYLogVars$$1$$3$$2$$var[(signed long int)rt_UpdateTXYLogVars$$1$$3$$2$$2$$i]->signals.isVarDims;
          if(!(rt_UpdateTXYLogVars$$1$$3$$2$$var[(signed long int)rt_UpdateTXYLogVars$$1$$3$$2$$2$$i]->logTime == 0))
            rt_UpdateLogVar((struct LogVar_Tag *)rt_UpdateTXYLogVars$$1$$3$$2$$var[(signed long int)rt_UpdateTXYLogVars$$1$$3$$2$$2$$i]->time, (const void *)tPtr, (unsigned char)0);

          for( ; rt_UpdateTXYLogVars$$1$$3$$2$$data[(signed long int)rt_UpdateTXYLogVars$$1$$3$$2$$2$$dataIdx] == (const signed char *)0; rt_UpdateTXYLogVars$$1$$3$$2$$2$$dataIdx = rt_UpdateTXYLogVars$$1$$3$$2$$2$$dataIdx + 1)
            ;
          rt_UpdateLogVar(rt_UpdateTXYLogVars$$1$$3$$2$$2$$1$$val, (const void *)rt_UpdateTXYLogVars$$1$$3$$2$$data[(signed long int)rt_UpdateTXYLogVars$$1$$3$$2$$2$$dataIdx], rt_UpdateTXYLogVars$$1$$3$$2$$2$$1$$isVarDims[(signed long int)0]);
          rt_UpdateTXYLogVars$$1$$3$$2$$2$$1$$val = rt_UpdateTXYLogVars$$1$$3$$2$$2$$1$$val->next;
          rt_UpdateTXYLogVars$$1$$3$$2$$2$$dataIdx = rt_UpdateTXYLogVars$$1$$3$$2$$2$$dataIdx + 1;
          rt_UpdateTXYLogVars$$1$$3$$2$$2$$i = rt_UpdateTXYLogVars$$1$$3$$2$$2$$i + 1;
        }
        while((_Bool)1);
      }
    }

    if(!(logInfo->xFinal == (void *)0))
    {
      struct StructLogVar_Tag *xf = (struct StructLogVar_Tag *)logInfo->xFinal;
      struct LogVar_Tag *val = xf->signals.values;
      signed int nsig = xf->signals.numSignals;
      signed int rt_UpdateTXYLogVars$$1$$3$$3$$i;
      if(!(xf->logTime == 0))
        rt_UpdateLogVar((struct LogVar_Tag *)xf->time, (const void *)tPtr, (unsigned char)0);

      rt_UpdateTXYLogVars$$1$$3$$3$$i = 0;
      for( ; !(rt_UpdateTXYLogVars$$1$$3$$3$$i >= nsig); rt_UpdateTXYLogVars$$1$$3$$3$$i = rt_UpdateTXYLogVars$$1$$3$$3$$i + 1)
      {
        const signed char * const *data = li->logXSignalPtrs.cptr;
        rt_UpdateLogVar(val, (const void *)data[(signed long int)rt_UpdateTXYLogVars$$1$$3$$3$$i], (unsigned char)0);
        val = val->next;
      }
    }

  }
  return (const char *)(void *)0;
}

// rt_WriteItemToMatFile
// file ../R2013a/rtw/c/src/rt_logging.c line 1039
static signed int rt_WriteItemToMatFile(struct _IO_FILE *fp, struct MatItem_tag *pItem, enum anonymous$33 itemKind)
{
  if(pItem->type == 14)
  {
    signed int return_value_rt_ProcessMatItem$1;
    return_value_rt_ProcessMatItem$1=rt_ProcessMatItem(fp, pItem, itemKind, 0);
    if(!(return_value_rt_ProcessMatItem$1 == 0))
      return 1;

  }

  if(pItem->nbytes > 4u)
  {
    signed int nAlignBytes;
    unsigned long int return_value_fwrite$2;
    //return_value_fwrite$2=fwrite((const void *)pItem, (unsigned long int)1, sizeof(signed int) /*4ul*/  << 1, fp);
    if(!(return_value_fwrite$2 == 8ul))
      return 1;

    if(pItem->type == 14)
    {
      signed int return_value_rt_ProcessMatItem$3;
      return_value_rt_ProcessMatItem$3=rt_ProcessMatItem(fp, pItem, itemKind, 1);
      if(!(return_value_rt_ProcessMatItem$3 == 0))
        return 1;

    }

    else
    {
      unsigned long int return_value_fwrite$4;
      //return_value_fwrite$4=fwrite(pItem->data, (unsigned long int)1, (unsigned long int)pItem->nbytes, fp);
      if(!(return_value_fwrite$4 == (unsigned long int)pItem->nbytes))
        return 1;

    }
    nAlignBytes = (signed int)(((unsigned int)pItem->nbytes + (unsigned int)7 & (unsigned int)~7) - pItem->nbytes);
    if(nAlignBytes > 0)
    {
      signed int pad[2l] = { 0, 0 };
      unsigned long int return_value_fwrite$5;
      //return_value_fwrite$5=fwrite((const void *)pad, (unsigned long int)1, (unsigned long int)nAlignBytes, fp);
      if(!(return_value_fwrite$5 == (unsigned long int)nAlignBytes))
        return 1;

    }

  }

  else
  {
    struct MatItem_tag item = { .type=0, .nbytes=(unsigned int)0, .data=(void *)0 };
    item.type = (signed int)((unsigned int)pItem->type | (unsigned int)pItem->nbytes << 16);
    memcpy((void *)&item.nbytes, pItem->data, (unsigned long int)pItem->nbytes);
    unsigned long int return_value_fwrite$6;
    //return_value_fwrite$6=fwrite((const void *)&item, (unsigned long int)1, sizeof(signed int) /*4ul*/  << 1, fp);
    if(!(return_value_fwrite$6 == 8ul))
      return 1;

  }
  return 0;
}

// rt_WriteMat5FileHeader
// file ../R2013a/rtw/c/src/rt_logging.c line 1090
static signed int rt_WriteMat5FileHeader(struct _IO_FILE *fp)
{
  signed int nbytes;
  signed int nspaces;
  signed int i;
  signed int n;
  unsigned short int ver[2l];
  char spaces[16l];
  const char *matversion = "MATLAB 5.0 MAT-file";
  memset((void *)spaces, 32, sizeof(char [16l]) /*16ul*/ );
  unsigned long int return_value_strlen$1;
  //return_value_strlen$1=strlen(matversion);
  n = (signed int)return_value_strlen$1;
  unsigned long int return_value_fwrite$2;
  //return_value_fwrite$2=fwrite((const void *)matversion, (unsigned long int)1, (unsigned long int)n, fp);
  nbytes = (signed int)return_value_fwrite$2;
  nspaces = (signed int)(124L - (signed long int)nbytes);
  n = (signed int)((unsigned long int)nspaces % sizeof(char [16l]) /*16ul*/ );
  unsigned long int return_value_fwrite$3;
  //return_value_fwrite$3=fwrite((const void *)spaces, (unsigned long int)1, (unsigned long int)n, fp);
  nbytes = nbytes + (signed int)return_value_fwrite$3;
  n = (signed int)((unsigned long int)nspaces / sizeof(char [16l]) /*16ul*/ );
  i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    unsigned long int return_value_fwrite$4;
    //return_value_fwrite$4=fwrite((const void *)spaces, (unsigned long int)1, sizeof(char [16l]) /*16ul*/ , fp);
    nbytes = nbytes + (signed int)return_value_fwrite$4;
  }
  if((signed long int)nbytes == 124L)
  {
    ver[(signed long int)0] = (unsigned short int)0x0100;
    ver[(signed long int)1] = (unsigned short int)0x4D49;
    unsigned long int return_value_fwrite$5;
    //return_value_fwrite$5=fwrite((const void *)ver, (unsigned long int)1, sizeof(unsigned short int [2l]) /*4ul*/ , fp);
    nbytes = nbytes + (signed int)return_value_fwrite$5;
  }

  return (signed int)((unsigned long int)nbytes != (unsigned long int)124L + sizeof(unsigned short int [2l]) /*4ul*/ );
}

// space_dummy_bool
// file ../R2013a/rtw/c/grt/classic_main.c line 30
void space_dummy_bool(void)
{
  _Bool local_true = TRUE;
  _Bool local_false = FALSE;
  if(!(local_true == FALSE))
    local_false = !(local_true != FALSE);

}
